---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:12Z
part: 158
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 158 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/layouts/Root/index.tsx
Signals: React, Next.js

```typescript
import type { AcceptedLanguages } from '@payloadcms/translations'
import type { ImportMap, LanguageOptions, SanitizedConfig, ServerFunctionClient } from 'payload'

import { rtlLanguages } from '@payloadcms/translations'
import { ProgressBar, RootProvider } from '@payloadcms/ui'
import { getClientConfig } from '@payloadcms/ui/utilities/getClientConfig'
import { cookies as nextCookies } from 'next/headers.js'
import { applyLocaleFiltering } from 'payload/shared'
import React from 'react'

import { getNavPrefs } from '../../elements/Nav/getNavPrefs.js'
import { getRequestTheme } from '../../utilities/getRequestTheme.js'
import { initReq } from '../../utilities/initReq.js'
import { checkDependencies } from './checkDependencies.js'
import { NestProviders } from './NestProviders.js'

import '@payloadcms/ui/scss/app.scss'

export const metadata = {
  description: 'Generated by Next.js',
  title: 'Next.js',
}

export const RootLayout = async ({
  children,
  config: configPromise,
  htmlProps = {},
  importMap,
  serverFunction,
}: {
  readonly children: React.ReactNode
  readonly config: Promise<SanitizedConfig>
  readonly htmlProps?: React.HtmlHTMLAttributes<HTMLHtmlElement>
  readonly importMap: ImportMap
  readonly serverFunction: ServerFunctionClient
}) => {
  checkDependencies()

  const {
    cookies,
    headers,
    languageCode,
    permissions,
    req,
    req: {
      payload: { config },
    },
  } = await initReq({ configPromise, importMap, key: 'RootLayout' })

  const theme = getRequestTheme({
    config,
    cookies,
    headers,
  })

  const dir = (rtlLanguages as unknown as AcceptedLanguages[]).includes(languageCode)
    ? 'RTL'
    : 'LTR'

  const languageOptions: LanguageOptions = Object.entries(
    config.i18n.supportedLanguages || {},
  ).reduce((acc, [language, languageConfig]) => {
    if (Object.keys(config.i18n.supportedLanguages).includes(language)) {
      acc.push({
        label: languageConfig.translations.general.thisLanguage,
        value: language,
      })
    }

    return acc
  }, [])

  async function switchLanguageServerAction(lang: string): Promise<void> {
    'use server'
    const cookies = await nextCookies()
    cookies.set({
      name: `${config.cookiePrefix || 'payload'}-lng`,
      path: '/',
      value: lang,
    })
  }

  const navPrefs = await getNavPrefs(req)

  const clientConfig = getClientConfig({
    config,
    i18n: req.i18n,
    importMap,
    user: req.user,
  })

  await applyLocaleFiltering({ clientConfig, config, req })

  return (
    <html
      data-theme={theme}
      dir={dir}
      lang={languageCode}
      suppressHydrationWarning={config?.admin?.suppressHydrationWarning ?? false}
      {...htmlProps}
    >
      <head>
        <style>{`@layer payload-default, payload;`}</style>
      </head>
      <body>
        <RootProvider
          config={clientConfig}
          dateFNSKey={req.i18n.dateFNSKey}
          fallbackLang={config.i18n.fallbackLanguage}
          isNavOpen={navPrefs?.open ?? true}
          languageCode={languageCode}
          languageOptions={languageOptions}
          locale={req.locale}
          permissions={req.user ? permissions : null}
          serverFunction={serverFunction}
          switchLanguageServerAction={switchLanguageServerAction}
          theme={theme}
          translations={req.i18n.translations}
          user={req.user}
        >
          <ProgressBar />
          {Array.isArray(config.admin?.components?.providers) &&
          config.admin?.components?.providers.length > 0 ? (
            <NestProviders
              importMap={req.payload.importMap}
              providers={config.admin?.components?.providers}
              serverProps={{
                i18n: req.i18n,
                payload: req.payload,
                permissions,
                user: req.user,
              }}
            >
              {children}
            </NestProviders>
          ) : (
            children
          )}
        </RootProvider>
        <div id="portal" />
      </body>
    </html>
  )
}
```

--------------------------------------------------------------------------------

---[FILE: NestProviders.tsx]---
Location: payload-main/packages/next/src/layouts/Root/NestProviders.tsx
Signals: React

```typescript
import type { Config, ImportMap, ServerProps } from 'payload'

import { RenderServerComponent } from '@payloadcms/ui/elements/RenderServerComponent'
import '@payloadcms/ui/scss/app.scss'
import React from 'react'

type Args = {
  readonly children: React.ReactNode
  readonly importMap: ImportMap
  readonly providers: Config['admin']['components']['providers']
  readonly serverProps: ServerProps
}

export function NestProviders({
  children,
  importMap,
  providers,
  serverProps,
}: Args): React.ReactNode {
  return RenderServerComponent({
    clientProps: {
      children:
        providers.length > 1 ? (
          <NestProviders
            importMap={importMap}
            providers={providers.slice(1)}
            serverProps={serverProps}
          >
            {children}
          </NestProviders>
        ) : (
          children
        ),
    },
    Component: providers[0],
    importMap,
    serverProps,
  })
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/packages/next/src/routes/index.ts

```typescript
export { GRAPHQL_PLAYGROUND_GET, GRAPHQL_POST } from './graphql/index.js'

export {
  DELETE as REST_DELETE,
  GET as REST_GET,
  OPTIONS as REST_OPTIONS,
  PATCH as REST_PATCH,
  POST as REST_POST,
} from './rest/index.js'
```

--------------------------------------------------------------------------------

---[FILE: handler.ts]---
Location: payload-main/packages/next/src/routes/graphql/handler.ts

```typescript
import type { GraphQLError, GraphQLFormattedError } from 'graphql'
import type { APIError, Payload, PayloadRequest, SanitizedConfig } from 'payload'

import { configToSchema } from '@payloadcms/graphql'
import { createHandler } from 'graphql-http/lib/use/fetch'
import { status as httpStatus } from 'http-status'
import {
  addDataAndFileToRequest,
  addLocalesToRequestFromData,
  createPayloadRequest,
  headersWithCors,
  logError,
  mergeHeaders,
} from 'payload'

const handleError = async ({
  err,
  payload,
  req,
}: {
  err: GraphQLError
  payload: Payload
  req: PayloadRequest
}): Promise<GraphQLFormattedError> => {
  const status = (err.originalError as APIError).status || httpStatus.INTERNAL_SERVER_ERROR
  let errorMessage = err.message
  logError({ err, payload })

  // Internal server errors can contain anything, including potentially sensitive data.
  // Therefore, error details will be hidden from the response unless `config.debug` is `true`
  if (!payload.config.debug && status === httpStatus.INTERNAL_SERVER_ERROR) {
    errorMessage = 'Something went wrong.'
  }

  let response: GraphQLFormattedError = {
    extensions: {
      name: err?.originalError?.name || undefined,
      data: (err && err.originalError && (err.originalError as APIError).data) || undefined,
      stack: payload.config.debug ? err.stack : undefined,
      statusCode: status,
    },
    locations: err.locations,
    message: errorMessage,
    path: err.path,
  }

  await payload.config.hooks.afterError?.reduce(async (promise, hook) => {
    await promise

    const result = await hook({
      context: req.context,
      error: err,
      graphqlResult: response,
      req,
    })

    if (result) {
      response = result.graphqlResult || response
    }
  }, Promise.resolve())

  return response
}

let cached = global._payload_graphql

if (!cached) {
  cached = global._payload_graphql = { graphql: null, promise: null }
}

export const getGraphql = async (config: Promise<SanitizedConfig> | SanitizedConfig) => {
  if (process.env.NODE_ENV === 'development') {
    cached = global._payload_graphql = { graphql: null, promise: null }
  }

  if (cached.graphql) {
    return cached.graphql
  }

  if (!cached.promise) {
    const resolvedConfig = await config
    cached.promise = new Promise((resolve) => {
      const schema = configToSchema(resolvedConfig)
      resolve(cached.graphql || schema)
    })
  }

  try {
    cached.graphql = await cached.promise
  } catch (e) {
    cached.promise = null
    throw e
  }

  return cached.graphql
}

export const POST =
  (config: Promise<SanitizedConfig> | SanitizedConfig) => async (request: Request) => {
    const originalRequest = request.clone()
    const req = await createPayloadRequest({
      canSetHeaders: true,
      config,
      request,
    })

    await addDataAndFileToRequest(req)
    addLocalesToRequestFromData(req)

    const { schema, validationRules } = await getGraphql(config)

    const { payload } = req

    const headers = {}
    const apiResponse = await createHandler({
      context: { headers, req },
      onOperation: async (request, args, result) => {
        const response =
          typeof payload.extensions === 'function'
            ? await payload.extensions({
                args,
                req: request,
                result,
              })
            : result
        if (response.errors) {
          const errors = (await Promise.all(
            result.errors.map((error) => {
              return handleError({ err: error, payload, req })
            }),
          )) as GraphQLError[]
          // errors type should be FormattedGraphQLError[] but onOperation has a return type of ExecutionResult instead of FormattedExecutionResult
          return { ...response, errors }
        }
        return response
      },
      schema,
      validationRules: (_, args, defaultRules) => defaultRules.concat(validationRules(args)),
    })(originalRequest)

    const resHeaders = headersWithCors({
      headers: new Headers(apiResponse.headers),
      req,
    })

    for (const key in headers) {
      resHeaders.append(key, headers[key])
    }

    return new Response(apiResponse.body, {
      headers: req.responseHeaders ? mergeHeaders(req.responseHeaders, resHeaders) : resHeaders,
      status: apiResponse.status,
    })
  }
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/packages/next/src/routes/graphql/index.ts

```typescript
export { POST as GRAPHQL_POST } from './handler.js'

export { GET as GRAPHQL_PLAYGROUND_GET } from './playground.js'
```

--------------------------------------------------------------------------------

---[FILE: playground.ts]---
Location: payload-main/packages/next/src/routes/graphql/playground.ts

```typescript
import { renderPlaygroundPage } from 'graphql-playground-html'
import { createPayloadRequest, type SanitizedConfig } from 'payload'

export const GET = (config: Promise<SanitizedConfig>) => async (request: Request) => {
  const req = await createPayloadRequest({
    config,
    request,
  })

  if (
    (!req.payload.config.graphQL.disable &&
      !req.payload.config.graphQL.disablePlaygroundInProduction &&
      process.env.NODE_ENV === 'production') ||
    process.env.NODE_ENV !== 'production'
  ) {
    return new Response(
      renderPlaygroundPage({
        endpoint: `${req.payload.config.routes.api}${req.payload.config.routes.graphQL}`,
        settings: {
          'request.credentials': 'include',
        },
      }),
      {
        headers: {
          'Content-Type': 'text/html',
        },
        status: 200,
      },
    )
  } else {
    return new Response('Route Not Found', { status: 404 })
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/packages/next/src/routes/rest/index.ts

```typescript
import { handleEndpoints, type SanitizedConfig } from 'payload'

import { generateOGImage } from './og/index.js'

let initedOGEndpoint = false

const handlerBuilder =
  (config: Promise<SanitizedConfig> | SanitizedConfig) =>
  async (
    request: Request,
    args: {
      params: Promise<{ slug?: string[] }>
    },
  ): Promise<Response> => {
    const awaitedConfig = await config

    // Add this endpoint only when using Next.js, still can be overridden.
    if (
      initedOGEndpoint === false &&
      !awaitedConfig.endpoints.some(
        (endpoint) => endpoint.path === '/og' && endpoint.method === 'get',
      )
    ) {
      awaitedConfig.endpoints.push({
        handler: generateOGImage,
        method: 'get',
        path: '/og',
      })
    }

    initedOGEndpoint = true

    const awaitedParams = await args.params

    const response = await handleEndpoints({
      config,
      path: awaitedParams
        ? `${awaitedConfig.routes.api}/${awaitedParams.slug.join('/')}`
        : undefined,
      request,
    })

    return response
  }

export const OPTIONS = handlerBuilder

export const GET = handlerBuilder

export const POST = handlerBuilder

export const DELETE = handlerBuilder

export const PATCH = handlerBuilder

export const PUT = handlerBuilder
```

--------------------------------------------------------------------------------

---[FILE: image.tsx]---
Location: payload-main/packages/next/src/routes/rest/og/image.tsx
Signals: React

```typescript
import type { ImportMap, PayloadComponent } from 'payload'

import { RenderServerComponent } from '@payloadcms/ui/elements/RenderServerComponent'
import React from 'react'

export const OGImage: React.FC<{
  description?: string
  Fallback: React.ComponentType
  fontFamily?: string
  Icon: PayloadComponent
  importMap: ImportMap
  leader?: string
  title?: string
}> = ({
  description,
  Fallback,
  fontFamily = 'Arial, sans-serif',
  Icon,
  importMap,
  leader,
  title,
}) => {
  const IconComponent = RenderServerComponent({
    clientProps: {
      fill: 'white',
    },
    Component: Icon,
    Fallback,
    importMap,
  })
  return (
    <div
      style={{
        backgroundColor: '#000',
        color: '#fff',
        display: 'flex',
        flexDirection: 'column',
        fontFamily,
        height: '100%',
        justifyContent: 'space-between',
        padding: '100px',
        width: '100%',
      }}
    >
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          flexGrow: 1,
          fontSize: 50,
          height: '100%',
        }}
      >
        {leader && (
          <div
            style={{
              fontSize: 30,
              marginBottom: 10,
            }}
          >
            {leader}
          </div>
        )}
        <p
          style={{
            display: '-webkit-box',
            fontSize: 90,
            lineHeight: 1,
            marginBottom: 0,
            marginTop: 0,
            textOverflow: 'ellipsis',
            WebkitBoxOrient: 'vertical',
            WebkitLineClamp: 2,
          }}
        >
          {title}
        </p>
        {description && (
          <p
            style={{
              display: '-webkit-box',
              flexGrow: 1,
              fontSize: 30,
              lineHeight: 1,
              marginBottom: 0,
              marginTop: 40,
              textOverflow: 'ellipsis',
              WebkitBoxOrient: 'vertical',
              WebkitLineClamp: 2,
            }}
          >
            {description}
          </p>
        )}
      </div>
      <div
        style={{
          alignItems: 'flex-end',
          display: 'flex',
          flexShrink: 0,
          height: '38px',
          justifyContent: 'center',
          width: '38px',
        }}
      >
        {IconComponent}
      </div>
    </div>
  )
}
```

--------------------------------------------------------------------------------

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/routes/rest/og/index.tsx
Signals: React, Next.js

```typescript
import type { PayloadHandler } from 'payload'

import { PayloadIcon } from '@payloadcms/ui/shared'
import fs from 'fs/promises'
import { ImageResponse } from 'next/og.js'
import path from 'path'
import React from 'react'
import { fileURLToPath } from 'url'

import { OGImage } from './image.js'

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

export const runtime = 'nodejs'

export const contentType = 'image/png'

export const generateOGImage: PayloadHandler = async (req) => {
  const config = req.payload.config

  if (config.admin.meta.defaultOGImageType === 'off') {
    return Response.json({ error: `Open Graph images are disabled` }, { status: 400 })
  }

  try {
    const { searchParams } = new URL(req.url)

    const hasTitle = searchParams.has('title')
    const title = hasTitle ? searchParams.get('title')?.slice(0, 100) : ''
    const hasLeader = searchParams.has('leader')
    const leader = hasLeader ? searchParams.get('leader')?.slice(0, 100).replace('-', ' ') : ''
    const description = searchParams.has('description') ? searchParams.get('description') : ''

    let fontData

    try {
      // TODO: replace with `.woff2` file when supported
      // See https://github.com/vercel/next.js/issues/63935
      // Or better yet, use a CDN like Google Fonts if ever supported
      fontData = fs.readFile(path.join(dirname, 'roboto-regular.woff'))
    } catch (e) {
      req.payload.logger.error(`Error reading font file or not readable: ${e.message}`)
    }

    const fontFamily = 'Roboto, sans-serif'

    return new ImageResponse(
      (
        <OGImage
          description={description}
          Fallback={PayloadIcon}
          fontFamily={fontFamily}
          Icon={config.admin?.components?.graphics?.Icon}
          importMap={req.payload.importMap}
          leader={leader}
          title={title}
        />
      ),
      {
        ...(fontData
          ? {
              fonts: [
                {
                  name: 'Roboto',
                  data: await fontData,
                  style: 'normal',
                  weight: 400,
                },
              ],
            }
          : {}),
        height: 630,
        width: 1200,
      },
    )
  } catch (e: any) {
    req.payload.logger.error(`Error generating Open Graph image: ${e.message}`)
    return Response.json({ error: `Internal Server Error: ${e.message}` }, { status: 500 })
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.scss]---
Location: payload-main/packages/next/src/templates/Default/index.scss

```text
@import '~@payloadcms/ui/scss';

@layer payload-default {
  .template-default {
    background-color: var(--theme-bg);
    color: var(--theme-text);

    [dir='rtl'] &__nav-toggler-wrapper {
      left: unset;
      right: 0;
    }

    &__nav-toggler-wrapper {
      position: sticky;
      z-index: var(--z-modal);
      top: 0;
      left: 0;
      height: 0;
      width: var(--gutter-h);
      display: flex;
      justify-content: center;
    }

    &__nav-toggler-container {
      height: var(--app-header-height);
      display: flex;
      align-items: center;
    }

    &__nav-toggler {
      display: flex;
      align-items: center;
    }

    &__wrap {
      min-width: 0;
      width: 100%;
      flex-grow: 1;
      position: relative;
      background-color: var(--theme-bg);
      &:before {
        content: '';
        display: block;
        position: absolute;
        inset: 0;
        background-color: inherit;
        opacity: 0;
        z-index: var(--z-status);
        visibility: hidden;
        transition: all var(--nav-trans-time) linear;
      }
    }

    @include mid-break {
      &__nav-toggler-wrapper {
        .hamburger {
          left: unset;
        }
      }
    }

    @include small-break {
      &__nav-toggler-wrapper {
        width: unset;
        justify-content: unset;

        .hamburger {
          display: none;
        }
      }

      .template-default {
        &__wrap {
          min-width: 100%;
        }
      }
    }
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/templates/Default/index.tsx
Signals: React

```typescript
import type {
  CustomComponent,
  DocumentSubViewTypes,
  PayloadRequest,
  ServerProps,
  ViewTypes,
  VisibleEntities,
} from 'payload'

import {
  ActionsProvider,
  AppHeader,
  BulkUploadProvider,
  EntityVisibilityProvider,
  NavToggler,
} from '@payloadcms/ui'
import { RenderServerComponent } from '@payloadcms/ui/elements/RenderServerComponent'

import './index.scss'

import React from 'react'

import { DefaultNav } from '../../elements/Nav/index.js'
import { NavHamburger } from './NavHamburger/index.js'
import { Wrapper } from './Wrapper/index.js'

const baseClass = 'template-default'

export type DefaultTemplateProps = {
  children?: React.ReactNode
  className?: string
  collectionSlug?: string
  docID?: number | string
  documentSubViewType?: DocumentSubViewTypes
  globalSlug?: string
  req?: PayloadRequest
  viewActions?: CustomComponent[]
  viewType?: ViewTypes
  visibleEntities: VisibleEntities
} & ServerProps

export const DefaultTemplate: React.FC<DefaultTemplateProps> = ({
  children,
  className,
  collectionSlug,
  docID,
  documentSubViewType,
  globalSlug,
  i18n,
  locale,
  params,
  payload,
  permissions,
  req,
  searchParams,
  user,
  viewActions,
  viewType,
  visibleEntities,
}) => {
  const {
    admin: {
      avatar,
      components,
      components: { header: CustomHeader, Nav: CustomNav } = {
        header: undefined,
        Nav: undefined,
      },
    } = {},
  } = payload.config || {}

  const clientProps = {
    documentSubViewType,
    viewType,
    visibleEntities,
  }

  const serverProps: {
    collectionSlug: string
    docID: number | string
    globalSlug: string
    req: PayloadRequest
  } & ServerProps = {
    collectionSlug,
    docID,
    globalSlug,
    i18n,
    locale,
    params,
    payload,
    permissions,
    req,
    searchParams,
    user,
  }

  const Actions: Record<string, React.ReactNode> = {}
  for (const action of viewActions ?? []) {
    if (!action) {
      continue
    }
    const key = typeof action === 'object' ? action.path : action
    Actions[key] = RenderServerComponent({
      clientProps,
      Component: action,
      importMap: payload.importMap,
      serverProps,
    })
  }

  const NavComponent = RenderServerComponent({
    clientProps,
    Component: CustomNav,
    Fallback: DefaultNav,
    importMap: payload.importMap,
    serverProps,
  })

  return (
    <EntityVisibilityProvider visibleEntities={visibleEntities}>
      <BulkUploadProvider drawerSlugPrefix={collectionSlug}>
        <ActionsProvider Actions={Actions}>
          {RenderServerComponent({
            clientProps,
            Component: CustomHeader,
            importMap: payload.importMap,
            serverProps,
          })}
          <div style={{ position: 'relative' }}>
            <div className={`${baseClass}__nav-toggler-wrapper`} id="nav-toggler">
              <div className={`${baseClass}__nav-toggler-container`} id="nav-toggler">
                <NavToggler className={`${baseClass}__nav-toggler`}>
                  <NavHamburger />
                </NavToggler>
              </div>
            </div>
            <Wrapper baseClass={baseClass} className={className}>
              {NavComponent}
              <div className={`${baseClass}__wrap`}>
                <AppHeader
                  CustomAvatar={
                    avatar !== 'gravatar' && avatar !== 'default'
                      ? RenderServerComponent({
                          Component: avatar.Component,
                          importMap: payload.importMap,
                          serverProps,
                        })
                      : undefined
                  }
                  CustomIcon={
                    components?.graphics?.Icon
                      ? RenderServerComponent({
                          Component: components.graphics.Icon,
                          importMap: payload.importMap,
                          serverProps,
                        })
                      : undefined
                  }
                />
                {children}
              </div>
            </Wrapper>
          </div>
        </ActionsProvider>
      </BulkUploadProvider>
    </EntityVisibilityProvider>
  )
}
```

--------------------------------------------------------------------------------

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/templates/Default/NavHamburger/index.tsx
Signals: React

```typescript
'use client'
import { Hamburger, useNav } from '@payloadcms/ui'
import React from 'react'

export const NavHamburger: React.FC = () => {
  const { navOpen } = useNav()
  return <Hamburger closeIcon="collapse" isActive={navOpen} />
}
```

--------------------------------------------------------------------------------

---[FILE: index.scss]---
Location: payload-main/packages/next/src/templates/Default/Wrapper/index.scss

```text
@import '~@payloadcms/ui/scss';

@layer payload-default {
  .template-default {
    min-height: 100vh;
    display: grid;
    position: relative;
    isolation: isolate;

    @media (prefers-reduced-motion) {
      transition: none;
    }

    &--nav-animate {
      transition: grid-template-columns var(--nav-trans-time) linear;
    }

    &--nav-open {
      .template-default {
        &__nav-overlay {
          transition: opacity var(--nav-trans-time) linear;
        }
      }
    }
  }

  @media (min-width: 1441px) {
    .template-default {
      grid-template-columns: 0 auto;

      &--nav-open {
        grid-template-columns: var(--nav-width) auto;
      }
    }
  }

  @media (max-width: 1440px) {
    .template-default--nav-hydrated.template-default--nav-open {
      grid-template-columns: var(--nav-width) auto;
    }

    .template-default {
      grid-template-columns: 1fr auto;

      .nav {
        display: none;
      }

      &--nav-hydrated {
        grid-template-columns: 0 auto;

        .nav {
          display: unset;
        }
      }
    }
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/templates/Default/Wrapper/index.tsx
Signals: React

```typescript
'use client'
import { useNav } from '@payloadcms/ui'
import React from 'react'

import './index.scss'

export const Wrapper: React.FC<{
  baseClass?: string
  children?: React.ReactNode
  className?: string
}> = (props) => {
  const { baseClass, children, className } = props
  const { hydrated, navOpen, shouldAnimate } = useNav()

  return (
    <div
      className={[
        baseClass,
        className,
        navOpen && `${baseClass}--nav-open`,
        shouldAnimate && `${baseClass}--nav-animate`,
        hydrated && `${baseClass}--nav-hydrated`,
      ]
        .filter(Boolean)
        .join(' ')}
    >
      {children}
    </div>
  )
}
```

--------------------------------------------------------------------------------

---[FILE: index.scss]---
Location: payload-main/packages/next/src/templates/Minimal/index.scss

```text
@import '~@payloadcms/ui/scss';

@layer payload-default {
  .template-minimal {
    display: flex;
    width: 100%;
    justify-content: center;
    align-items: center;
    padding: base(3) $baseline;
    margin-left: auto;
    margin-right: auto;
    min-height: 100%;
    background-color: var(--theme-bg-color);
    color: var(--theme-text);

    &--width-normal {
      .template-minimal__wrap {
        max-width: base(24);
        width: 100%;
      }
    }

    &--width-wide {
      .template-minimal__wrap {
        max-width: base(48);
        width: 100%;
      }
    }
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.tsx]---
Location: payload-main/packages/next/src/templates/Minimal/index.tsx
Signals: React

```typescript
import React from 'react'

import './index.scss'

const baseClass = 'template-minimal'

export type MinimalTemplateProps = {
  children?: React.ReactNode
  className?: string
  style?: React.CSSProperties
  width?: 'normal' | 'wide'
}

export const MinimalTemplate: React.FC<MinimalTemplateProps> = (props) => {
  const { children, className, style = {}, width = 'normal' } = props

  const classes = [className, baseClass, `${baseClass}--width-${width}`].filter(Boolean).join(' ')

  return (
    <section className={classes} style={style}>
      <div className={`${baseClass}__wrap`}>{children}</div>
    </section>
  )
}
```

--------------------------------------------------------------------------------

---[FILE: getExistingAuthToken.ts]---
Location: payload-main/packages/next/src/utilities/getExistingAuthToken.ts
Signals: Next.js

```typescript
import { cookies as getCookies } from 'next/headers.js'

type Cookie = {
  name: string
  value: string
}
export async function getExistingAuthToken(cookiePrefix: string): Promise<Cookie | undefined> {
  const cookies = await getCookies()
  return cookies.getAll().find((cookie) => cookie.name.startsWith(cookiePrefix))
}
```

--------------------------------------------------------------------------------

---[FILE: getNextRequestI18n.ts]---
Location: payload-main/packages/next/src/utilities/getNextRequestI18n.ts
Signals: Next.js

```typescript
import type { ClientTranslationsObject, I18nClient } from '@payloadcms/translations'

import { initI18n } from '@payloadcms/translations'
import { cookies, headers } from 'next/headers.js'
import { getRequestLanguage, type SanitizedConfig } from 'payload'

/**
 * In the context of Next.js, this function initializes the i18n object for the current request.
 *
 * It must be called on the server side, and within the lifecycle of a request since it relies on the request headers and cookies.
 */
export const getNextRequestI18n = async <
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  TAdditionalTranslations = {},
  TAdditionalClientTranslationKeys extends string = never,
>({
  config,
}: {
  config: SanitizedConfig
}): Promise<
  [TAdditionalClientTranslationKeys] extends [never]
    ? I18nClient
    : TAdditionalTranslations extends object
      ? I18nClient<TAdditionalTranslations, TAdditionalClientTranslationKeys>
      : I18nClient<ClientTranslationsObject, TAdditionalClientTranslationKeys>
> => {
  return (await initI18n({
    config: config.i18n,
    context: 'client',
    language: getRequestLanguage({ config, cookies: await cookies(), headers: await headers() }),
  })) as any
}
```

--------------------------------------------------------------------------------

---[FILE: getPayloadHMR.ts]---
Location: payload-main/packages/next/src/utilities/getPayloadHMR.ts

```typescript
import type { InitOptions, Payload } from 'payload'

import { getPayload } from 'payload'

/**
 *  getPayloadHMR is no longer preferred.
 *  You can now use in all contexts:
 *  ```ts
 *   import { getPayload } from 'payload'
 *  ```
 * @deprecated
 */
export const getPayloadHMR = async (
  options: Pick<InitOptions, 'config' | 'importMap'>,
): Promise<Payload> => {
  const result = await getPayload(options)

  result.logger.warn(
    "Deprecation warning: getPayloadHMR is no longer preferred. You can now use `import { getPayload } from 'payload' in all contexts.",
  )

  return result
}
```

--------------------------------------------------------------------------------

---[FILE: getPreferences.ts]---
Location: payload-main/packages/next/src/utilities/getPreferences.ts
Signals: React

```typescript
import type { DefaultDocumentIDType, Payload } from 'payload'

import { cache } from 'react'

export const getPreferences = cache(
  async <T>(
    key: string,
    payload: Payload,
    userID: DefaultDocumentIDType,
    userSlug: string,
  ): Promise<{ id: DefaultDocumentIDType; value: T }> => {
    const result = (await payload
      .find({
        collection: 'payload-preferences',
        depth: 0,
        limit: 1,
        pagination: false,
        where: {
          and: [
            {
              key: {
                equals: key,
              },
            },
            {
              'user.relationTo': {
                equals: userSlug,
              },
            },
            {
              'user.value': {
                equals: userID,
              },
            },
          ],
        },
      })
      .then((res) => res.docs?.[0])) as { id: DefaultDocumentIDType; value: T }

    return result
  },
)
```

--------------------------------------------------------------------------------

---[FILE: getRequestLocale.ts]---
Location: payload-main/packages/next/src/utilities/getRequestLocale.ts

```typescript
import type { Locale, PayloadRequest } from 'payload'

import { upsertPreferences } from '@payloadcms/ui/rsc'
import { findLocaleFromCode } from '@payloadcms/ui/shared'

import { getPreferences } from './getPreferences.js'

type GetRequestLocalesArgs = {
  req: PayloadRequest
}

export async function getRequestLocale({ req }: GetRequestLocalesArgs): Promise<Locale> {
  if (req.payload.config.localization) {
    const localeFromParams = req.query.locale as string | undefined

    if (req.user && localeFromParams) {
      await upsertPreferences<Locale['code']>({ key: 'locale', req, value: localeFromParams })
    }

    return (
      (req.user &&
        findLocaleFromCode(
          req.payload.config.localization,
          localeFromParams ||
            (
              await getPreferences<Locale['code']>(
                'locale',
                req.payload,
                req.user.id,
                req.user.collection,
              )
            )?.value,
        )) ||
      findLocaleFromCode(
        req.payload.config.localization,
        req.payload.config.localization.defaultLocale || 'en',
      )
    )
  }

  return undefined
}
```

--------------------------------------------------------------------------------

---[FILE: getRequestTheme.ts]---
Location: payload-main/packages/next/src/utilities/getRequestTheme.ts
Signals: Next.js

```typescript
import type { ReadonlyRequestCookies } from 'next/dist/server/web/spec-extension/adapters/request-cookies.js'
import type { SanitizedConfig } from 'payload'

import { defaultTheme, type Theme } from '@payloadcms/ui'

type GetRequestLanguageArgs = {
  config: SanitizedConfig
  cookies: Map<string, string> | ReadonlyRequestCookies
  headers: Request['headers']
}

const acceptedThemes: Theme[] = ['dark', 'light']

export const getRequestTheme = ({ config, cookies, headers }: GetRequestLanguageArgs): Theme => {
  if (config.admin.theme !== 'all' && acceptedThemes.includes(config.admin.theme)) {
    return config.admin.theme
  }

  const themeCookie = cookies.get(`${config.cookiePrefix || 'payload'}-theme`)

  const themeFromCookie: Theme = (
    typeof themeCookie === 'string' ? themeCookie : themeCookie?.value
  ) as Theme

  if (themeFromCookie && acceptedThemes.includes(themeFromCookie)) {
    return themeFromCookie
  }

  const themeFromHeader = headers.get('Sec-CH-Prefers-Color-Scheme') as Theme

  if (themeFromHeader && acceptedThemes.includes(themeFromHeader)) {
    return themeFromHeader
  }

  return defaultTheme
}
```

--------------------------------------------------------------------------------

---[FILE: getRouteWithoutAdmin.ts]---
Location: payload-main/packages/next/src/utilities/getRouteWithoutAdmin.ts

```typescript
export const getRouteWithoutAdmin = ({
  adminRoute,
  route,
}: {
  adminRoute: string
  route: string
}): string => {
  return adminRoute && adminRoute !== '/' ? route.replace(adminRoute, '') : route
}
```

--------------------------------------------------------------------------------

---[FILE: getVisibleEntities.ts]---
Location: payload-main/packages/next/src/utilities/getVisibleEntities.ts

```typescript
import type { PayloadRequest, VisibleEntities } from 'payload'

import { isEntityHidden } from 'payload'

export function getVisibleEntities({ req }: { req: PayloadRequest }): VisibleEntities {
  return {
    collections: req.payload.config.collections
      .map(({ slug, admin: { hidden } }) =>
        !isEntityHidden({ hidden, user: req.user }) ? slug : null,
      )
      .filter(Boolean),
    globals: req.payload.config.globals
      .map(({ slug, admin: { hidden } }) =>
        !isEntityHidden({ hidden, user: req.user }) ? slug : null,
      )
      .filter(Boolean),
  }
}
```

--------------------------------------------------------------------------------

---[FILE: handleAuthRedirect.ts]---
Location: payload-main/packages/next/src/utilities/handleAuthRedirect.ts

```typescript
import type { TypedUser } from 'payload'

import { formatAdminURL } from 'payload/shared'
import * as qs from 'qs-esm'

type Args = {
  config
  route: string
  searchParams: { [key: string]: string | string[] }
  user?: TypedUser
}

export const handleAuthRedirect = ({ config, route, searchParams, user }: Args): string => {
  const {
    admin: {
      routes: { login: loginRouteFromConfig, unauthorized: unauthorizedRoute },
    },
    routes: { admin: adminRoute },
  } = config

  if (searchParams && 'redirect' in searchParams) {
    delete searchParams.redirect
  }

  const redirectRoute =
    (route !== adminRoute ? route : '') +
    (Object.keys(searchParams ?? {}).length > 0
      ? `${qs.stringify(searchParams, { addQueryPrefix: true })}`
      : '')

  const redirectTo = formatAdminURL({
    adminRoute,
    path: user ? unauthorizedRoute : loginRouteFromConfig,
    serverURL: config.serverURL,
  })

  const parsedLoginRouteSearchParams = qs.parse(redirectTo.split('?')[1] ?? '')

  const searchParamsWithRedirect = `${qs.stringify(
    {
      ...parsedLoginRouteSearchParams,
      ...(redirectRoute ? { redirect: redirectRoute } : {}),
    },
    { addQueryPrefix: true },
  )}`

  return `${redirectTo.split('?', 1)[0]}${searchParamsWithRedirect}`
}
```

--------------------------------------------------------------------------------

````
