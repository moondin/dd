---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:14Z
part: 958
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 958 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: 0687_set_default_value_for_can_resolve_topics_group.py]---
Location: zulip-main/zerver/migrations/0687_set_default_value_for_can_resolve_topics_group.py
Signals: Django

```python
# Generated by Django 5.0.6 on 2024-05-16 18:28

from collections import defaultdict

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import OuterRef, Value


def set_default_value_for_can_resolve_topics_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    UserGroup = apps.get_model("zerver", "UserGroup")
    UserGroupMembership = apps.get_model("zerver", "UserGroupMembership")
    GroupGroupMembership = apps.get_model("zerver", "GroupGroupMembership")

    Realm.objects.filter(can_resolve_topics_group=None).exclude(
        can_move_messages_between_topics_group__named_user_group=None
    ).update(
        can_resolve_topics_group=NamedUserGroup.objects.filter(
            usergroup_ptr=OuterRef("can_move_messages_between_topics_group")
        ).values("pk")
    )

    realms_with_setting_set_to_anonymous_group = Realm.objects.filter(
        can_move_messages_between_topics_group__named_user_group=None, can_resolve_topics_group=None
    )

    if len(realms_with_setting_set_to_anonymous_group) == 0:
        return

    user_groups_to_create = []
    realms_to_update = []
    anonymous_group_ids = []

    with transaction.atomic():
        for realm in realms_with_setting_set_to_anonymous_group:
            anonymous_group_ids.append(realm.can_move_messages_between_topics_group_id)

            setting_group = UserGroup(realm=realm)
            realm.can_resolve_topics_group = setting_group

            user_groups_to_create.append(setting_group)
            realms_to_update.append(realm)

        UserGroup.objects.bulk_create(user_groups_to_create)
        Realm.objects.bulk_update(realms_to_update, fields=["can_resolve_topics_group"])

        user_members = (
            UserGroupMembership.objects.filter(user_group_id__in=anonymous_group_ids)
            .annotate(member_type=Value("user"))
            .values_list("member_type", "user_group_id", "user_profile_id")
        )

        group_subgroups = (
            GroupGroupMembership.objects.filter(supergroup_id__in=anonymous_group_ids)
            .annotate(member_type=Value("group"))
            .values_list("member_type", "supergroup_id", "subgroup_id")
        )

        all_members = user_members.union(group_subgroups)

        members_dict = defaultdict(list)
        subgroups_dict = defaultdict(list)

        for member_type, group_id, member_id in all_members:
            if member_type == "user":
                members_dict[group_id].append(member_id)
            else:
                subgroups_dict[group_id].append(member_id)

        user_membership_objects = []
        group_membership_objects = []
        for realm in realms_with_setting_set_to_anonymous_group:
            members_to_add = members_dict[realm.can_move_messages_between_topics_group_id]
            subgroups_to_add = subgroups_dict[realm.can_move_messages_between_topics_group_id]

            setting_group_id = realm.can_resolve_topics_group_id
            user_membership_objects.extend(
                [
                    UserGroupMembership(user_group_id=setting_group_id, user_profile_id=user_id)
                    for user_id in members_to_add
                ]
            )
            group_membership_objects.extend(
                [
                    GroupGroupMembership(supergroup_id=setting_group_id, subgroup_id=subgroup_id)
                    for subgroup_id in subgroups_to_add
                ]
            )

        UserGroupMembership.objects.bulk_create(user_membership_objects)
        GroupGroupMembership.objects.bulk_create(group_membership_objects)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0686_realm_can_resolve_topics_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_resolve_topics_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0688_alter_realm_can_resolve_topics_group.py]---
Location: zulip-main/zerver/migrations/0688_alter_realm_can_resolve_topics_group.py
Signals: Django

```python
# Generated by Django 5.0.6 on 2024-05-16 18:44

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0687_set_default_value_for_can_resolve_topics_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realm",
            name="can_resolve_topics_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0689_mark_navigation_tour_video_as_read.py]---
Location: zulip-main/zerver/migrations/0689_mark_navigation_tour_video_as_read.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-21 15:55

from django.db import connection, migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.utils.timezone import now as timezone_now
from psycopg2.sql import SQL


def mark_navigation_tour_video_as_read(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    with connection.cursor() as cursor:
        cursor.execute(SQL("SELECT MAX(id) FROM zerver_userprofile;"))
        (max_id,) = cursor.fetchone()

    if max_id is None:
        return

    BATCH_SIZE = 10000
    max_id += BATCH_SIZE / 2
    lower_id_bound = 0
    timestamp_value = timezone_now()
    while lower_id_bound < max_id:
        upper_id_bound = min(lower_id_bound + BATCH_SIZE, max_id)
        with connection.cursor() as cursor:
            query = SQL("""
                INSERT INTO zerver_onboardingstep (user_id, onboarding_step, timestamp)
                SELECT id, 'navigation_tour_video', %(timestamp_value)s
                FROM zerver_userprofile
                WHERE is_bot = False
                AND is_mirror_dummy = False
                AND id > %(lower_id_bound)s AND id <= %(upper_id_bound)s;
                """)
            cursor.execute(
                query,
                {
                    "timestamp_value": timestamp_value,
                    "lower_id_bound": lower_id_bound,
                    "upper_id_bound": upper_id_bound,
                },
            )

        print(f"Processed {upper_id_bound} / {max_id}")
        lower_id_bound += BATCH_SIZE


def mark_navigation_tour_video_as_unread(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    OnboardingStep = apps.get_model("zerver", "OnboardingStep")

    OnboardingStep.objects.filter(onboarding_step="navigation_tour_video").delete()


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ("zerver", "0688_alter_realm_can_resolve_topics_group"),
    ]

    operations = [
        migrations.RunPython(
            mark_navigation_tour_video_as_read,
            reverse_code=mark_navigation_tour_video_as_unread,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0690_message_is_channel_message.py]---
Location: zulip-main/zerver/migrations/0690_message_is_channel_message.py
Signals: Django

```python
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0689_mark_navigation_tour_video_as_read"),
    ]

    operations = [
        migrations.AddField(
            model_name="archivedmessage",
            name="is_channel_message",
            field=models.BooleanField(db_index=True, default=True, null=True),
        ),
        migrations.AddField(
            model_name="message",
            name="is_channel_message",
            field=models.BooleanField(db_index=True, default=True, null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0691_backfill_message_is_channel_message.py]---
Location: zulip-main/zerver/migrations/0691_backfill_message_is_channel_message.py
Signals: Django

```python
from django.db import connection, migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from psycopg2.sql import SQL

from zerver.lib.migrate import do_batch_update


def update_is_channel_message(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    Message = apps.get_model("zerver", "Message")
    ArchivedMessage = apps.get_model("zerver", "ArchivedMessage")

    with connection.cursor() as cursor:
        for message_model in [Message, ArchivedMessage]:
            do_batch_update(
                cursor,
                message_model._meta.db_table,
                [
                    SQL(
                        "is_channel_message = (SELECT type = 2 FROM zerver_recipient WHERE zerver_recipient.id = recipient_id)"
                    )
                ],
            )


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0690_message_is_channel_message"),
    ]

    operations = [
        migrations.RunPython(
            update_is_channel_message, reverse_code=migrations.RunPython.noop, elidable=True
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0692_alter_message_is_channel_message.py]---
Location: zulip-main/zerver/migrations/0692_alter_message_is_channel_message.py
Signals: Django

```python
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0691_backfill_message_is_channel_message"),
    ]

    operations = [
        migrations.AlterField(
            model_name="archivedmessage",
            name="is_channel_message",
            field=models.BooleanField(db_index=True, default=True),
        ),
        migrations.AlterField(
            model_name="message",
            name="is_channel_message",
            field=models.BooleanField(db_index=True, default=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0693_add_conditional_indexes_for_topic.py]---
Location: zulip-main/zerver/migrations/0693_add_conditional_indexes_for_topic.py
Signals: Django

```python
import django.db.models.functions.text
from django.contrib.postgres.operations import AddIndexConcurrently
from django.db import migrations, models


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0692_alter_message_is_channel_message"),
    ]

    operations = [
        migrations.RenameIndex(
            model_name="message",
            new_name="zerver_message_realm_upper_subject_all",
            old_name="zerver_message_realm_upper_subject",
        ),
        migrations.RenameIndex(
            model_name="message",
            new_name="zerver_message_realm_recipient_upper_subject_all",
            old_name="zerver_message_realm_recipient_upper_subject",
        ),
        migrations.RenameIndex(
            model_name="message",
            new_name="zerver_message_realm_recipient_subject_all",
            old_name="zerver_message_realm_recipient_subject",
        ),
        AddIndexConcurrently(
            model_name="message",
            index=models.Index(
                models.F("realm_id"),
                django.db.models.functions.text.Upper("subject"),
                models.OrderBy(models.F("id"), descending=True, nulls_last=True),
                condition=models.Q(("is_channel_message", True)),
                name="zerver_message_realm_upper_subject",
            ),
        ),
        AddIndexConcurrently(
            model_name="message",
            index=models.Index(
                models.F("realm_id"),
                models.F("recipient_id"),
                django.db.models.functions.text.Upper("subject"),
                models.OrderBy(models.F("id"), descending=True, nulls_last=True),
                condition=models.Q(("is_channel_message", True)),
                name="zerver_message_realm_recipient_upper_subject",
            ),
        ),
        AddIndexConcurrently(
            model_name="message",
            index=models.Index(
                models.F("realm_id"),
                models.F("recipient_id"),
                models.F("subject"),
                models.OrderBy(models.F("id"), descending=True, nulls_last=True),
                condition=models.Q(("is_channel_message", True)),
                name="zerver_message_realm_recipient_subject",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0694_remove_message_unconditional_topic_indexes.py]---
Location: zulip-main/zerver/migrations/0694_remove_message_unconditional_topic_indexes.py
Signals: Django

```python
from django.contrib.postgres.operations import RemoveIndexConcurrently
from django.db import migrations


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0693_add_conditional_indexes_for_topic"),
    ]

    operations = [
        RemoveIndexConcurrently(
            model_name="message",
            name="zerver_message_realm_upper_subject_all",
        ),
        RemoveIndexConcurrently(
            model_name="message",
            name="zerver_message_realm_recipient_upper_subject_all",
        ),
        RemoveIndexConcurrently(
            model_name="message",
            name="zerver_message_realm_recipient_subject_all",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0695_is_channel_message_stats.py]---
Location: zulip-main/zerver/migrations/0695_is_channel_message_stats.py
Signals: Django

```python
from django.db import migrations


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0694_remove_message_unconditional_topic_indexes"),
    ]

    operations = [
        migrations.RunSQL(
            sql="CREATE STATISTICS IF NOT EXISTS zerver_message_subject_is_channel_message ON subject, is_channel_message FROM zerver_message",
            reverse_sql="DROP STATISTICS IF EXISTS zerver_message_subject_is_channel_message",
        ),
        migrations.RunSQL(
            sql="ALTER STATISTICS zerver_message_subject_is_channel_message SET STATISTICS 1500",
            reverse_sql="ALTER STATISTICS zerver_message_subject_is_channel_message SET STATISTICS -1",
        ),
        migrations.RunSQL("ANALYZE zerver_message"),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0696_rename_no_topic_to_empty_string_topic.py]---
Location: zulip-main/zerver/migrations/0696_rename_no_topic_to_empty_string_topic.py
Signals: Django

```python
from typing import Any

import orjson
from django.conf import settings
from django.db import connection, migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import F, Func, JSONField, TextField, Value
from django.db.models.functions import Cast
from django.utils.timezone import now as timezone_now
from psycopg2.sql import SQL, Literal

LAST_EDIT_TIME = timezone_now()
LAST_EDIT_TIMESTAMP = int(LAST_EDIT_TIME.timestamp())


def update_messages_for_topic_edit(message_queryset: Any, notification_bot: Any) -> None:
    edit_history_entry = {
        "user_id": notification_bot.id,
        "timestamp": LAST_EDIT_TIMESTAMP,
        "prev_topic": "(no topic)",
        "topic": "",
    }
    update_fields: dict[str, object] = {
        "subject": "",
        "last_edit_time": LAST_EDIT_TIME,
        "edit_history": Cast(
            Func(
                Cast(
                    Value(orjson.dumps([edit_history_entry]).decode()),
                    JSONField(),
                ),
                Cast(
                    Func(
                        F("edit_history"),
                        Value("[]"),
                        function="COALESCE",
                    ),
                    JSONField(),
                ),
                function="",
                arg_joiner=" || ",
            ),
            TextField(),
        ),
    }
    message_queryset.update(**update_fields)


def update_user_topic(channel_ids: list[int], user_topic_model: type[Any]) -> None:
    if not channel_ids:
        return

    # Both insert and delete query uses index "zerver_mutedtopic_stream_topic".
    channel_ids_str = SQL(",").join(map(Literal, channel_ids))
    query = SQL(
        """
        INSERT INTO zerver_usertopic(user_profile_id, stream_id, recipient_id, topic_name, last_updated, visibility_policy)
        SELECT user_profile_id, stream_id, recipient_id, '', last_updated, visibility_policy
        FROM zerver_usertopic
        WHERE stream_id IN ({channel_ids})
        AND lower(topic_name) = '(no topic)'
        ON CONFLICT (user_profile_id, stream_id, lower(topic_name)) DO UPDATE SET
        last_updated = EXCLUDED.last_updated,
        visibility_policy = EXCLUDED.visibility_policy;
        """
    ).format(channel_ids=channel_ids_str)
    with connection.cursor() as cursor:
        cursor.execute(query)

    user_topic_model.objects.filter(
        stream_id__in=channel_ids, topic_name__iexact="(no topic)"
    ).delete()


def move_messages_from_no_topic_to_empty_string_topic(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    """Move messages from "(no topic)" to the empty string topic.

    This helps in our plan to interpret messages sent to
    "(no topic)" as being sent to "".

    That interpretation is particularly helpful for older
    clients where sending messages with empty topic input box
    results in messages being sent to "(no topic)" topic.

    Note: In 0680, we moved messages from the "general chat" topic
    to the empty string topic. Therefore, we skip moving messages
    from "(no topic)" if an empty string topic already exists.

    Such cases—where both "(no topic)" and an empty string topic
    coexist in a channel—should be rare. The solution is to either
    manually rename the "(no topic)" topic or manually move its
    messages to the empty string topic.
    """
    Realm = apps.get_model("zerver", "Realm")
    Message = apps.get_model("zerver", "Message")
    UserTopic = apps.get_model("zerver", "UserTopic")
    ArchivedMessage = apps.get_model("zerver", "ArchivedMessage")
    ScheduledMessage = apps.get_model("zerver", "ScheduledMessage")
    UserProfile = apps.get_model("zerver", "UserProfile")

    try:
        internal_realm = Realm.objects.get(string_id=settings.SYSTEM_BOT_REALM)
    except Realm.DoesNotExist:
        # Server not initialized.
        return
    notification_bot = UserProfile.objects.get(
        email__iexact=settings.NOTIFICATION_BOT, realm=internal_realm
    )

    for realm in Realm.objects.all().iterator():
        with transaction.atomic(durable=True):
            # Uses index "zerver_message_realm_recipient_subject"
            channel_ids_with_empty_string_topic = set(
                Message.objects.filter(realm=realm, is_channel_message=True, subject="")
                .distinct("recipient__type_id")
                .values_list("recipient__type_id", flat=True)
            )
            # Uses index "zerver_message_realm_upper_subject"
            message_queryset = Message.objects.filter(
                realm=realm, is_channel_message=True, subject__iexact="(no topic)"
            ).exclude(recipient__type_id__in=channel_ids_with_empty_string_topic)
            channel_ids = list(
                message_queryset.distinct("recipient__type_id").values_list(
                    "recipient__type_id", flat=True
                )
            )

            update_messages_for_topic_edit(message_queryset, notification_bot)

            update_user_topic(channel_ids, UserTopic)

            # Uses index zerver_archivedmessage_realm_id_fab86889
            archived_channel_ids_with_empty_string_topic = set(
                ArchivedMessage.objects.filter(realm=realm, is_channel_message=True, subject="")
                .distinct("recipient__type_id")
                .values_list("recipient__type_id", flat=True)
            )
            channel_ids_with_empty_string_topic = channel_ids_with_empty_string_topic.union(
                archived_channel_ids_with_empty_string_topic
            )
            # Uses index zerver_archivedmessage_realm_id_fab86889
            archived_message_queryset = ArchivedMessage.objects.filter(
                realm=realm, is_channel_message=True, subject__iexact="(no topic)"
            ).exclude(recipient__type_id__in=channel_ids_with_empty_string_topic)
            update_messages_for_topic_edit(archived_message_queryset, notification_bot)

            ScheduledMessage.objects.filter(realm=realm, subject__iexact="(no topic)").update(
                subject=""
            )


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0695_is_channel_message_stats"),
    ]

    operations = [
        migrations.RunPython(
            move_messages_from_no_topic_to_empty_string_topic,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0697_empty_topic_name_for_dms_from_third_party_imports.py]---
Location: zulip-main/zerver/migrations/0697_empty_topic_name_for_dms_from_third_party_imports.py
Signals: Django

```python
# Generated by Django 5.1.6 on 2025-03-06 08:13
import time

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps

BATCH_SIZE = 10000
RECIPIENT_PERSONAL = 1
RECIPIENT_HUDDLE = 3


def update_dm_and_gdm_topic_name(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    Message = apps.get_model("zerver", "Message")

    if not Message.objects.exists():
        # Nothing to do, and Message.objects.latest() will crash.
        return

    last_id = Message.objects.latest("id").id

    Client = apps.get_model("zerver", "Client")

    try:
        third_party_import_client = Client.objects.get(name="populate_db")
    except (Client.DoesNotExist, Client.MultipleObjectsReturned):
        return

    def process_batch(id_start: int, id_end: int) -> None:
        messages_to_update = Message.objects.filter(
            id__gte=id_start,
            id__lte=id_end,
            sending_client_id=third_party_import_client.id,
            recipient__type__in=[RECIPIENT_PERSONAL, RECIPIENT_HUDDLE],
        ).exclude(subject="")

        messages_to_update.update(subject="")

    id_range_lower_bound = 0
    id_range_upper_bound = min(BATCH_SIZE, last_id)

    while id_range_lower_bound < last_id:
        process_batch(id_range_lower_bound, id_range_upper_bound)
        print(f"Processed messages up to ID {id_range_upper_bound} / {last_id}")

        id_range_lower_bound = id_range_upper_bound
        id_range_upper_bound = min(id_range_lower_bound + BATCH_SIZE, last_id)

        time.sleep(0.1)


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ("zerver", "0696_rename_no_topic_to_empty_string_topic"),
    ]

    operations = [
        migrations.RunPython(update_dm_and_gdm_topic_name),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0698_scheduledmessage_request_timestamp.py]---
Location: zulip-main/zerver/migrations/0698_scheduledmessage_request_timestamp.py
Signals: Django

```python
# Generated by Django 5.1.8 on 2025-04-24 05:47

import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0697_empty_topic_name_for_dms_from_third_party_imports"),
    ]

    operations = [
        migrations.AddField(
            model_name="scheduledmessage",
            name="request_timestamp",
            field=models.DateTimeField(default=django.utils.timezone.now),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0699_scheduledmessage_reminder_target_message_id.py]---
Location: zulip-main/zerver/migrations/0699_scheduledmessage_reminder_target_message_id.py
Signals: Django

```python
# Generated by Django 5.1.8 on 2025-04-28 08:16

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0698_scheduledmessage_request_timestamp"),
    ]

    operations = [
        migrations.AddField(
            model_name="scheduledmessage",
            name="reminder_target_message_id",
            field=models.IntegerField(null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0700_fix_user_role_system_groups.py]---
Location: zulip-main/zerver/migrations/0700_fix_user_role_system_groups.py
Signals: Django

```python
from collections import defaultdict
from typing import Any

from django.conf import settings
from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Count
from django.utils.timezone import now as timezone_now

ROLE_REALM_OWNER = 100
ROLE_REALM_ADMINISTRATOR = 200
ROLE_MODERATOR = 300
ROLE_MEMBER = 400
ROLE_GUEST = 600


class SystemGroups:
    FULL_MEMBERS = "role:fullmembers"
    EVERYONE_ON_INTERNET = "role:internet"
    OWNERS = "role:owners"
    ADMINISTRATORS = "role:administrators"
    MODERATORS = "role:moderators"
    MEMBERS = "role:members"
    EVERYONE = "role:everyone"
    NOBODY = "role:nobody"


def fix_system_group_memberships_based_on_role(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    """
    Our ldap integration supports syncing the user's .role based on their
    LDAP groups. It had a bug, updating only the .role value, without updating
    the system group memberships for the user accordingly. Additionally,
    the RealmAuditLog USER_ROLE_CHANGED entry was not created either.

    This migration fixes the group memberships for users whose .role
    doesn't match them, additionally also creating the missing RealmAuditLog
    object.
    """
    UserProfile = apps.get_model("zerver", "UserProfile")
    Realm = apps.get_model("zerver", "Realm")
    RealmAuditLog = apps.get_model("zerver", "RealmAuditLog")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    UserGroupMembership = apps.get_model("zerver", "UserGroupMembership")

    if settings.CORPORATE_ENABLED:
        # Zulip Cloud doesn't support LDAP, and this migration isn't
        # entirely race-safe, so it's better to not run in there.
        #
        # Self-hosted systems generally stop the server to apply
        # migrations, so rare races between role changes and this
        # migration are quite unlikely to impact anyone.
        return

    def get_system_user_group_by_name(group_name: str, realm_id: int) -> Any:
        return NamedUserGroup.objects.get(name=group_name, realm_id=realm_id, is_system_group=True)

    def realm_user_count_by_role(realm: Any) -> dict[str, Any]:
        """
        Code copied from the implementation in zerver.lib.user_counts
        """
        ROLE_COUNT_HUMANS = "11"
        ROLE_COUNT_BOTS = "12"

        human_counts = {
            str(ROLE_REALM_ADMINISTRATOR): 0,
            str(ROLE_REALM_OWNER): 0,
            str(ROLE_MODERATOR): 0,
            str(ROLE_MEMBER): 0,
            str(ROLE_GUEST): 0,
        }
        for value_dict in (
            UserProfile.objects.filter(realm=realm, is_bot=False, is_active=True)
            .values("role")
            .annotate(Count("role"))
        ):
            human_counts[str(value_dict["role"])] = value_dict["role__count"]
        bot_count = UserProfile.objects.filter(realm=realm, is_bot=True, is_active=True).count()
        return {
            ROLE_COUNT_HUMANS: human_counts,
            ROLE_COUNT_BOTS: bot_count,
        }

    def fix_user_memberships_if_needed(
        user_profile: Any,
        direct_memberships: list[Any],
        fullmembers_membership: Any | None,
        guest_group: Any,
        member_group: Any,
        fullmember_group: Any,
        moderator_group: Any,
        admin_group: Any,
        owner_group: Any,
    ) -> tuple[list[Any], list[Any], list[Any]]:
        new_memberships: list[Any] = []
        delete_memberships: list[Any] = []
        new_realmauditlogs: list[Any] = []

        group_id_to_group_name = {
            guest_group.id: "Guests",
            member_group.id: "Members",
            moderator_group.id: "Moderators",
            admin_group.id: "Administrators",
            owner_group.id: "Owners",
        }
        role_to_group = {
            ROLE_GUEST: guest_group,
            ROLE_MEMBER: member_group,
            ROLE_MODERATOR: moderator_group,
            ROLE_REALM_ADMINISTRATOR: admin_group,
            ROLE_REALM_OWNER: owner_group,
        }
        group_id_to_role = {v.id: k for k, v in role_to_group.items()}

        role = user_profile.role
        group_implied_by_role = role_to_group[role]

        if len(direct_memberships) == 0:
            print(
                f"User {user_profile.id} has no role group memberships. This is unexpected. Skipping."
            )
            return [], [], []

        if len(direct_memberships) > 1:
            group_names = [group_id_to_group_name[m.user_group_id] for m in direct_memberships]
            print(
                f"User {user_profile.id} has more than one role group membership: {group_names}. "
                f"Expected group based on role value of {role}: {group_id_to_group_name[group_implied_by_role.id]}. Skipping."
            )
            return [], [], []

        assert len(direct_memberships) == 1
        role_membership = direct_memberships[0]

        if role_membership.user_group_id == group_implied_by_role.id:
            # This user's state is correct.
            return [], [], []

        print(f"User {user_profile.id} will be fixed.")

        # We can determine what the user's previous role was based on the current incorrect membership.
        old_role = group_id_to_role[role_membership.user_group_id]

        # Fix the membership to point to the correct group for the user's role.
        memberships_to_delete.append(role_membership)
        new_memberships.append(
            UserGroupMembership(user_profile=user_profile, user_group=group_implied_by_role)
        )

        if role != ROLE_MEMBER and fullmembers_membership is not None:
            memberships_to_delete.append(fullmembers_membership)
        elif (
            role == ROLE_MEMBER
            and fullmembers_membership is None
            and realm.waiting_period_threshold == 0
        ):
            # For realms without waiting_period_threshold=0, this will get calculated correctly
            # by the promote_new_full_members cronjob.
            new_memberships.append(
                UserGroupMembership(user_profile=user_profile, user_group=fullmember_group)
            )

        # Create the RealmAuditLog that must be missing in these situations as well.
        USER_ROLE_CHANGED = 105
        OLD_VALUE = "1"
        NEW_VALUE = "2"
        ROLE_COUNT = "10"
        new_realmauditlogs.append(
            RealmAuditLog(
                backfilled=True,
                realm=user_profile.realm,
                modified_user=user_profile,
                acting_user=None,
                event_type=USER_ROLE_CHANGED,
                event_time=timezone_now(),
                extra_data={
                    OLD_VALUE: old_role,
                    NEW_VALUE: role,
                    # This could be done much more efficiently than
                    # calling the function that re-calculates all
                    # counts for every user we process, but we expect
                    # this fixup code path to only be relevant for a
                    # very small number of users.
                    ROLE_COUNT: realm_user_count_by_role(user_profile.realm),
                },
            )
        )

        return new_memberships, delete_memberships, new_realmauditlogs

    print()
    for realm in Realm.objects.exclude(string_id=settings.SYSTEM_BOT_REALM):
        print(f"Processing realm {realm.id}")
        guest_group = get_system_user_group_by_name(SystemGroups.EVERYONE, realm.id)
        member_group = get_system_user_group_by_name(SystemGroups.MEMBERS, realm.id)
        moderator_group = get_system_user_group_by_name(SystemGroups.MODERATORS, realm.id)
        admin_group = get_system_user_group_by_name(SystemGroups.ADMINISTRATORS, realm.id)
        owner_group = get_system_user_group_by_name(SystemGroups.OWNERS, realm.id)

        fullmember_group = get_system_user_group_by_name(SystemGroups.FULL_MEMBERS, realm.id)

        role_group_ids = [
            guest_group.id,
            member_group.id,
            moderator_group.id,
            admin_group.id,
            owner_group.id,
        ]

        direct_memberships = UserGroupMembership.objects.filter(user_group_id__in=role_group_ids)
        user_id_to_group_memberships = defaultdict(list)
        for membership in direct_memberships:
            user_id_to_group_memberships[membership.user_profile_id].append(membership)

        # Full members work differently than other roles - membership in this group is not mutually
        # exclusive with membership in other groups. More concretely, a user can be in the Members
        # group and Fullmembers group simultaneously.
        # Due to this trait, it requires different handling and the info will be kept in a separate
        # structure.
        fullmembers_memberships = UserGroupMembership.objects.filter(user_group=fullmember_group)
        user_id_fullmembers_membership: dict[int, Any] = defaultdict(lambda: None)
        for membership in fullmembers_memberships:
            user_id_fullmembers_membership[membership.user_profile_id] = membership

        memberships_to_create: list[Any] = []
        memberships_to_delete: list[Any] = []
        realmauditlogs_to_create: list[Any] = []
        for user_profile in UserProfile.objects.filter(realm=realm):
            new_memberships, delete_memberships, new_realmauditlogs = (
                fix_user_memberships_if_needed(
                    user_profile,
                    user_id_to_group_memberships[user_profile.id],
                    user_id_fullmembers_membership[user_profile.id],
                    guest_group=guest_group,
                    member_group=member_group,
                    fullmember_group=fullmember_group,
                    moderator_group=moderator_group,
                    admin_group=admin_group,
                    owner_group=owner_group,
                )
            )
            memberships_to_create += new_memberships
            memberships_to_delete + delete_memberships
            realmauditlogs_to_create += new_realmauditlogs

        with transaction.atomic(durable=True):
            UserGroupMembership.objects.filter(
                id__in=[m.id for m in memberships_to_delete]
            ).delete()
            UserGroupMembership.objects.bulk_create(memberships_to_create)
            RealmAuditLog.objects.bulk_create(realmauditlogs_to_create)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        # Because this will be backported to 10.x, we only depend on the last migration in 10.x
        ("zerver", "0697_empty_topic_name_for_dms_from_third_party_imports"),
    ]

    operations = [
        migrations.RunPython(
            fix_system_group_memberships_based_on_role,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0701_merge.py]---
Location: zulip-main/zerver/migrations/0701_merge.py
Signals: Django

```python
from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0699_scheduledmessage_reminder_target_message_id"),
        ("zerver", "0700_fix_user_role_system_groups"),
    ]

    operations = []
```

--------------------------------------------------------------------------------

---[FILE: 0702_rename_populate_db_client_to_zulip_data_import.py]---
Location: zulip-main/zerver/migrations/0702_rename_populate_db_client_to_zulip_data_import.py
Signals: Django

```python
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def rename_populate_db_client(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    """Renames the 'populate_db' client to 'ZulipDataImport' to
    better reflect its use in production, which is messages imported
    into Zulip via official data import tools.
    """
    Client = apps.get_model("zerver", "Client")

    Client.objects.filter(name="populate_db").update(name="ZulipDataImport")


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0701_merge"),
    ]

    operations = [
        migrations.RunPython(
            rename_populate_db_client,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0703_realmuserdefault_resolved_topic_notice_auto_read_policy_and_more.py]---
Location: zulip-main/zerver/migrations/0703_realmuserdefault_resolved_topic_notice_auto_read_policy_and_more.py
Signals: Django

```python
# Generated by Django 5.1.8 on 2025-04-25 10:20

from django.db import migrations, models


class Migration(migrations.Migration):
    except_followed = 2
    dependencies = [
        ("zerver", "0702_rename_populate_db_client_to_zulip_data_import"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmuserdefault",
            name="resolved_topic_notice_auto_read_policy",
            field=models.PositiveSmallIntegerField(
                default=except_followed,
                db_default=except_followed,
            ),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="resolved_topic_notice_auto_read_policy",
            field=models.PositiveSmallIntegerField(
                default=except_followed,
                db_default=except_followed,
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0704_stream_subscriber_count.py]---
Location: zulip-main/zerver/migrations/0704_stream_subscriber_count.py
Signals: Django

```python
# Generated by Django 5.1.7 on 2025-04-08 20:19

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0703_realmuserdefault_resolved_topic_notice_auto_read_policy_and_more"),
    ]

    operations = [
        migrations.AddField(
            model_name="stream",
            name="subscriber_count",
            field=models.PositiveIntegerField(db_default=0, default=0),
        ),
    ]
```

--------------------------------------------------------------------------------

````
