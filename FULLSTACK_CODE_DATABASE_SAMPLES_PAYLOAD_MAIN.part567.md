---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:13Z
part: 567
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 567 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: int.spec.ts]---
Location: payload-main/test/fields-relationship/int.spec.ts

```typescript
import type { Payload } from 'payload'

import path from 'path'
import { fileURLToPath } from 'url'

import type { NextRESTClient } from '../helpers/NextRESTClient.js'
import type { Collection1 } from './payload-types.js'

import { devUser } from '../credentials.js'
import { initPayloadInt } from '../helpers/initPayloadInt.js'
import { collection1Slug, versionedRelationshipFieldSlug } from './slugs.js'

let payload: Payload
let restClient: NextRESTClient

const { email, password } = devUser

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

describe('Relationship Fields', () => {
  beforeAll(async () => {
    const initialized = await initPayloadInt(dirname)
    ;({ payload, restClient } = initialized)

    await restClient.login({
      slug: 'users',
      credentials: {
        email,
        password,
      },
    })
  })

  afterAll(async () => {
    await payload.destroy()
  })

  describe('Versioned Relationship Field', () => {
    let version2ID: string
    const relatedDocName = 'Related Doc'
    beforeAll(async () => {
      const relatedDoc = await payload.create({
        collection: collection1Slug,
        data: {
          name: relatedDocName,
        },
      })

      const version1 = await payload.create({
        collection: versionedRelationshipFieldSlug,
        data: {
          title: 'Version 1 Title',
          relationshipField: {
            value: relatedDoc.id,
            relationTo: collection1Slug,
          },
        },
      })

      const version2 = await payload.update({
        collection: versionedRelationshipFieldSlug,
        id: version1.id,
        data: {
          title: 'Version 2 Title',
        },
      })

      const versions = await payload.findVersions({
        collection: versionedRelationshipFieldSlug,
        where: {
          parent: {
            equals: version2.id,
          },
        },
        sort: '-updatedAt',
        limit: 1,
      })

      version2ID = versions.docs[0].id
    })
    it('should return the correct versioned relationship field via REST', async () => {
      const version2Data = await restClient
        .GET(`/${versionedRelationshipFieldSlug}/versions/${version2ID}?locale=all`)
        .then((res) => res.json())

      expect(version2Data.version.title).toEqual('Version 2 Title')
      expect(version2Data.version.relationshipField[0].value.name).toEqual(relatedDocName)
    })

    it('should return the correct versioned relationship field via LocalAPI', async () => {
      const version2Data = await payload.findVersionByID({
        collection: versionedRelationshipFieldSlug,
        id: version2ID,
        locale: 'all',
      })

      expect(version2Data.version.title).toEqual('Version 2 Title')
      expect((version2Data.version.relationshipField[0].value as Collection1).name).toEqual(
        relatedDocName,
      )
    })
  })
})
```

--------------------------------------------------------------------------------

---[FILE: payload-types.ts]---
Location: payload-main/test/fields-relationship/payload-types.ts

```typescript
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:types` to regenerate this file.
 */

/**
 * Supported timezones in IANA format.
 *
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "supportedTimezones".
 */
export type SupportedTimezones =
  | 'Pacific/Midway'
  | 'Pacific/Niue'
  | 'Pacific/Honolulu'
  | 'Pacific/Rarotonga'
  | 'America/Anchorage'
  | 'Pacific/Gambier'
  | 'America/Los_Angeles'
  | 'America/Tijuana'
  | 'America/Denver'
  | 'America/Phoenix'
  | 'America/Chicago'
  | 'America/Guatemala'
  | 'America/New_York'
  | 'America/Bogota'
  | 'America/Caracas'
  | 'America/Santiago'
  | 'America/Buenos_Aires'
  | 'America/Sao_Paulo'
  | 'Atlantic/South_Georgia'
  | 'Atlantic/Azores'
  | 'Atlantic/Cape_Verde'
  | 'Europe/London'
  | 'Europe/Berlin'
  | 'Africa/Lagos'
  | 'Europe/Athens'
  | 'Africa/Cairo'
  | 'Europe/Moscow'
  | 'Asia/Riyadh'
  | 'Asia/Dubai'
  | 'Asia/Baku'
  | 'Asia/Karachi'
  | 'Asia/Tashkent'
  | 'Asia/Calcutta'
  | 'Asia/Dhaka'
  | 'Asia/Almaty'
  | 'Asia/Jakarta'
  | 'Asia/Bangkok'
  | 'Asia/Shanghai'
  | 'Asia/Singapore'
  | 'Asia/Tokyo'
  | 'Asia/Seoul'
  | 'Australia/Brisbane'
  | 'Australia/Sydney'
  | 'Pacific/Guam'
  | 'Pacific/Noumea'
  | 'Pacific/Auckland'
  | 'Pacific/Fiji';

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  blocks: {};
  collections: {
    'fields-relationship': FieldsRelationship;
    'relation-filter-false': RelationFilterFalse;
    'relation-filter-true': RelationFilterTrue;
    'relation-one': RelationOne;
    'relation-two': RelationTwo;
    'relation-restricted': RelationRestricted;
    'relation-with-title': RelationWithTitle;
    'relation-updated-externally': RelationUpdatedExternally;
    'collection-1': Collection1;
    'collection-2': Collection2;
    videos: Video;
    podcasts: Podcast;
    'mixed-media': MixedMedia;
    'versioned-relationship-field': VersionedRelationshipField;
    'payload-kv': PayloadKv;
    users: User;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsJoins: {};
  collectionsSelect: {
    'fields-relationship': FieldsRelationshipSelect<false> | FieldsRelationshipSelect<true>;
    'relation-filter-false': RelationFilterFalseSelect<false> | RelationFilterFalseSelect<true>;
    'relation-filter-true': RelationFilterTrueSelect<false> | RelationFilterTrueSelect<true>;
    'relation-one': RelationOneSelect<false> | RelationOneSelect<true>;
    'relation-two': RelationTwoSelect<false> | RelationTwoSelect<true>;
    'relation-restricted': RelationRestrictedSelect<false> | RelationRestrictedSelect<true>;
    'relation-with-title': RelationWithTitleSelect<false> | RelationWithTitleSelect<true>;
    'relation-updated-externally': RelationUpdatedExternallySelect<false> | RelationUpdatedExternallySelect<true>;
    'collection-1': Collection1Select<false> | Collection1Select<true>;
    'collection-2': Collection2Select<false> | Collection2Select<true>;
    videos: VideosSelect<false> | VideosSelect<true>;
    podcasts: PodcastsSelect<false> | PodcastsSelect<true>;
    'mixed-media': MixedMediaSelect<false> | MixedMediaSelect<true>;
    'versioned-relationship-field': VersionedRelationshipFieldSelect<false> | VersionedRelationshipFieldSelect<true>;
    'payload-kv': PayloadKvSelect<false> | PayloadKvSelect<true>;
    users: UsersSelect<false> | UsersSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  fallbackLocale: ('false' | 'none' | 'null') | false | null | 'en' | 'en'[];
  globals: {};
  globalsSelect: {};
  locale: 'en';
  user: User & {
    collection: 'users';
  };
  jobs: {
    tasks: unknown;
    workflows: unknown;
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "fields-relationship".
 */
export interface FieldsRelationship {
  id: string;
  relationToSelf?: (string | null) | FieldsRelationship;
  relationship?: (string | null) | RelationOne;
  relationshipHasMany?: (string | RelationOne)[] | null;
  relationshipMultiple?:
    | ({
        relationTo: 'relation-one';
        value: string | RelationOne;
      } | null)
    | ({
        relationTo: 'relation-two';
        value: string | RelationTwo;
      } | null);
  relationshipHasManyMultiple?:
    | (
        | {
            relationTo: 'relation-one';
            value: string | RelationOne;
          }
        | {
            relationTo: 'relation-two';
            value: string | RelationTwo;
          }
      )[]
    | null;
  relationshipRestricted?: (string | null) | RelationRestricted;
  relationshipWithTitle?: (string | null) | RelationWithTitle;
  /**
   * This will filter the relationship options based on id, which is the same as the relationship field in this document
   */
  relationshipFilteredByID?: (string | null) | RelationOne;
  /**
   * This will filter the relationship options if the filter field in this document is set to "Include me"
   */
  relationshipFilteredByField?: (string | null) | FieldsRelationship;
  /**
   * This will filter the relationship options if the filter field in this document is set to "Include me"
   */
  filteredByFieldInCollapsible?: (string | null) | FieldsRelationship;
  array?:
    | {
        /**
         * This will filter the relationship options if the filter field in this document is set to "Include me"
         */
        filteredByFieldInArray?: (string | null) | FieldsRelationship;
        id?: string | null;
      }[]
    | null;
  relationshipFilteredAsync?: (string | null) | RelationOne;
  relationshipManyFiltered?:
    | (
        | {
            relationTo: 'relation-with-title';
            value: string | RelationWithTitle;
          }
        | {
            relationTo: 'relation-filter-false';
            value: string | RelationFilterFalse;
          }
        | {
            relationTo: 'relation-filter-true';
            value: string | RelationFilterTrue;
          }
        | {
            relationTo: 'relation-one';
            value: string | RelationOne;
          }
      )[]
    | null;
  filter?: string | null;
  relationshipReadOnly?: (string | null) | RelationOne;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-one".
 */
export interface RelationOne {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-two".
 */
export interface RelationTwo {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-restricted".
 */
export interface RelationRestricted {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-with-title".
 */
export interface RelationWithTitle {
  id: string;
  name?: string | null;
  meta?: {
    title?: string | null;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-filter-false".
 */
export interface RelationFilterFalse {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-filter-true".
 */
export interface RelationFilterTrue {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-updated-externally".
 */
export interface RelationUpdatedExternally {
  id: string;
  relationPrePopulate?: (string | null) | Collection1;
  relationHasMany?: (string | Collection1)[] | null;
  relationToManyHasMany?:
    | (
        | {
            relationTo: 'collection-1';
            value: string | Collection1;
          }
        | {
            relationTo: 'collection-2';
            value: string | Collection2;
          }
      )[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "collection-1".
 */
export interface Collection1 {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "collection-2".
 */
export interface Collection2 {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "videos".
 */
export interface Video {
  id: number;
  title?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "podcasts".
 */
export interface Podcast {
  id: number;
  title?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "mixed-media".
 */
export interface MixedMedia {
  id: string;
  relatedMedia?:
    | (
        | {
            relationTo: 'videos';
            value: number | Video;
          }
        | {
            relationTo: 'podcasts';
            value: number | Podcast;
          }
      )[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "versioned-relationship-field".
 */
export interface VersionedRelationshipField {
  id: string;
  title: string;
  relationshipField?:
    | {
        relationTo: 'collection-1';
        value: string | Collection1;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
  _status?: ('draft' | 'published') | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-kv".
 */
export interface PayloadKv {
  id: string;
  key: string;
  data:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  sessions?:
    | {
        id: string;
        createdAt?: string | null;
        expiresAt: string;
      }[]
    | null;
  password?: string | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'fields-relationship';
        value: string | FieldsRelationship;
      } | null)
    | ({
        relationTo: 'relation-filter-false';
        value: string | RelationFilterFalse;
      } | null)
    | ({
        relationTo: 'relation-filter-true';
        value: string | RelationFilterTrue;
      } | null)
    | ({
        relationTo: 'relation-one';
        value: string | RelationOne;
      } | null)
    | ({
        relationTo: 'relation-two';
        value: string | RelationTwo;
      } | null)
    | ({
        relationTo: 'relation-restricted';
        value: string | RelationRestricted;
      } | null)
    | ({
        relationTo: 'relation-with-title';
        value: string | RelationWithTitle;
      } | null)
    | ({
        relationTo: 'relation-updated-externally';
        value: string | RelationUpdatedExternally;
      } | null)
    | ({
        relationTo: 'collection-1';
        value: string | Collection1;
      } | null)
    | ({
        relationTo: 'collection-2';
        value: string | Collection2;
      } | null)
    | ({
        relationTo: 'videos';
        value: number | Video;
      } | null)
    | ({
        relationTo: 'podcasts';
        value: number | Podcast;
      } | null)
    | ({
        relationTo: 'mixed-media';
        value: string | MixedMedia;
      } | null)
    | ({
        relationTo: 'versioned-relationship-field';
        value: string | VersionedRelationshipField;
      } | null)
    | ({
        relationTo: 'users';
        value: string | User;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "fields-relationship_select".
 */
export interface FieldsRelationshipSelect<T extends boolean = true> {
  relationToSelf?: T;
  relationship?: T;
  relationshipHasMany?: T;
  relationshipMultiple?: T;
  relationshipHasManyMultiple?: T;
  relationshipRestricted?: T;
  relationshipWithTitle?: T;
  relationshipFilteredByID?: T;
  relationshipFilteredByField?: T;
  filteredByFieldInCollapsible?: T;
  array?:
    | T
    | {
        filteredByFieldInArray?: T;
        id?: T;
      };
  relationshipFilteredAsync?: T;
  relationshipManyFiltered?: T;
  filter?: T;
  relationshipReadOnly?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-filter-false_select".
 */
export interface RelationFilterFalseSelect<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-filter-true_select".
 */
export interface RelationFilterTrueSelect<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-one_select".
 */
export interface RelationOneSelect<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-two_select".
 */
export interface RelationTwoSelect<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-restricted_select".
 */
export interface RelationRestrictedSelect<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-with-title_select".
 */
export interface RelationWithTitleSelect<T extends boolean = true> {
  name?: T;
  meta?:
    | T
    | {
        title?: T;
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation-updated-externally_select".
 */
export interface RelationUpdatedExternallySelect<T extends boolean = true> {
  relationPrePopulate?: T;
  relationHasMany?: T;
  relationToManyHasMany?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "collection-1_select".
 */
export interface Collection1Select<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "collection-2_select".
 */
export interface Collection2Select<T extends boolean = true> {
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "videos_select".
 */
export interface VideosSelect<T extends boolean = true> {
  id?: T;
  title?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "podcasts_select".
 */
export interface PodcastsSelect<T extends boolean = true> {
  id?: T;
  title?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "mixed-media_select".
 */
export interface MixedMediaSelect<T extends boolean = true> {
  relatedMedia?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "versioned-relationship-field_select".
 */
export interface VersionedRelationshipFieldSelect<T extends boolean = true> {
  title?: T;
  relationshipField?: T;
  updatedAt?: T;
  createdAt?: T;
  _status?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-kv_select".
 */
export interface PayloadKvSelect<T extends boolean = true> {
  key?: T;
  data?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
  sessions?:
    | T
    | {
        id?: T;
        createdAt?: T;
        expiresAt?: T;
      };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
```

--------------------------------------------------------------------------------

---[FILE: seed.ts]---
Location: payload-main/test/fields-relationship/seed.ts

```typescript
import type { Payload } from 'payload'

import { devUser } from '../credentials.js'
import {
  collection1Slug,
  collection2Slug,
  podcastCollectionSlug,
  relationOneSlug,
  relationRestrictedSlug,
  relationTwoSlug,
  relationWithTitleSlug,
  slug,
  videoCollectionSlug,
} from './slugs.js'

export const seed = async (_payload: Payload) => {
  await _payload.create({
    collection: 'users',
    data: {
      email: devUser.email,
      password: devUser.password,
    },
    depth: 0,
    overrideAccess: true,
  })

  // Create docs to relate to
  const { id: relationOneDocId } = await _payload.create({
    collection: relationOneSlug,
    data: {
      name: relationOneSlug,
    },
    depth: 0,
    overrideAccess: true,
  })

  const relationOneIDs: string[] = []

  for (let i = 0; i < 11; i++) {
    const doc = await _payload.create({
      collection: relationOneSlug,
      data: {
        name: relationOneSlug,
      },
      depth: 0,
      overrideAccess: true,
    })
    relationOneIDs.push(doc.id)
  }

  const relationTwoIDs: string[] = []
  for (let i = 0; i < 11; i++) {
    const doc = await _payload.create({
      collection: relationTwoSlug,
      data: {
        name: relationTwoSlug,
      },
      depth: 0,
      overrideAccess: true,
    })
    relationTwoIDs.push(doc.id)
  }

  // Existing relationships
  const { id: restrictedDocId } = await _payload.create({
    collection: relationRestrictedSlug,
    data: {
      name: 'relation-restricted',
    },
    depth: 0,
    overrideAccess: true,
  })

  const relationsWithTitle: string[] = []

  for (const title of ['relation-title', 'word boundary search']) {
    const { id } = await _payload.create({
      collection: relationWithTitleSlug,
      depth: 0,
      overrideAccess: true,
      data: {
        name: title,
        meta: {
          title,
        },
      },
    })
    relationsWithTitle.push(id)
  }

  await _payload.create({
    collection: slug,
    depth: 0,
    overrideAccess: true,
    data: {
      relationship: relationOneDocId,
      relationshipRestricted: restrictedDocId,
      relationshipWithTitle: relationsWithTitle[0],
    },
  })

  for (let i = 0; i < 11; i++) {
    await _payload.create({
      collection: slug,
      depth: 0,
      overrideAccess: true,
      data: {
        relationship: relationOneDocId,
        relationshipHasManyMultiple: relationOneIDs.map((id) => ({
          relationTo: relationOneSlug,
          value: id,
        })),
        relationshipRestricted: restrictedDocId,
      },
    })
  }

  for (let i = 0; i < 15; i++) {
    const relationOneID = relationOneIDs[Math.floor(Math.random() * 10)]
    const relationTwoID = relationTwoIDs[Math.floor(Math.random() * 10)]

    await _payload.create({
      collection: slug,
      depth: 0,
      overrideAccess: true,
      data: {
        relationship: relationOneDocId,
        relationshipHasMany: [relationOneID],
        relationshipHasManyMultiple: [{ relationTo: relationTwoSlug, value: relationTwoID }],
        relationshipReadOnly: relationOneID,
        relationshipRestricted: restrictedDocId,
      },
    })
  }

  for (let i = 0; i < 15; i++) {
    await _payload.create({
      collection: collection1Slug,
      depth: 0,
      overrideAccess: true,
      data: {
        name: `relationship-test ${i}`,
      },
    })

    await _payload.create({
      collection: collection2Slug,
      depth: 0,
      overrideAccess: true,
      data: {
        name: `relationship-test ${i}`,
      },
    })
  }

  for (let i = 0; i < 2; i++) {
    await _payload.create({
      collection: videoCollectionSlug,
      data: {
        id: i,
        title: `Video ${i}`,
      },
    })

    await _payload.create({
      collection: podcastCollectionSlug,
      data: {
        id: i,
        title: `Podcast ${i}`,
      },
    })
  }
}
```

--------------------------------------------------------------------------------

---[FILE: slugs.ts]---
Location: payload-main/test/fields-relationship/slugs.ts

```typescript
export const slug = 'fields-relationship'

export const relationOneSlug = 'relation-one'
export const relationTrueFilterOptionSlug = 'relation-filter-true'
export const relationFalseFilterOptionSlug = 'relation-filter-false'
export const relationTwoSlug = 'relation-two'
export const relationRestrictedSlug = 'relation-restricted'
export const relationWithTitleSlug = 'relation-with-title'
export const relationUpdatedExternallySlug = 'relation-updated-externally'
export const collection1Slug = 'collection-1'
export const collection2Slug = 'collection-2'
export const videoCollectionSlug = 'videos'
export const podcastCollectionSlug = 'podcasts'
export const mixedMediaCollectionSlug = 'mixed-media'
export const versionedRelationshipFieldSlug = 'versioned-relationship-field'

export const collectionSlugs = [
  relationOneSlug,
  relationTrueFilterOptionSlug,
  relationFalseFilterOptionSlug,
  relationTwoSlug,
  relationRestrictedSlug,
  relationWithTitleSlug,
  relationUpdatedExternallySlug,
  collection1Slug,
  collection2Slug,
  videoCollectionSlug,
  podcastCollectionSlug,
  mixedMediaCollectionSlug,
  versionedRelationshipFieldSlug,
]
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/fields-relationship/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.json]---
Location: payload-main/test/fields-relationship/tsconfig.json

```json
{
  "extends": "../tsconfig.json"
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Collection1/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { collection1Slug } from '../../slugs.js'

export const Collection1: CollectionConfig = {
  fields: [
    {
      name: 'name',
      type: 'text',
    },
  ],
  slug: collection1Slug,
  admin: {
    useAsTitle: 'name',
  },
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Collection2/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { collection2Slug } from '../../slugs.js'

export const Collection2: CollectionConfig = {
  fields: [
    {
      name: 'name',
      type: 'text',
    },
  ],
  slug: collection2Slug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/FilterFalse/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationFalseFilterOptionSlug } from '../../slugs.js'

export const RelationshipFilterFalse: CollectionConfig = {
  admin: {
    useAsTitle: 'name',
  },
  fields: baseRelationshipFields,
  slug: relationFalseFilterOptionSlug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/FilterTrue/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationTrueFilterOptionSlug } from '../../slugs.js'

export const RelationshipFilterTrue: CollectionConfig = {
  admin: {
    useAsTitle: 'name',
  },
  fields: baseRelationshipFields,
  slug: relationTrueFilterOptionSlug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/MixedMedia/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import {
  mixedMediaCollectionSlug,
  podcastCollectionSlug,
  videoCollectionSlug,
} from '../../slugs.js'

export const MixedMedia: CollectionConfig = {
  slug: mixedMediaCollectionSlug,
  fields: [
    {
      type: 'relationship',
      name: 'relatedMedia',
      relationTo: [videoCollectionSlug, podcastCollectionSlug],
      hasMany: true,
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Podcast/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { podcastCollectionSlug } from '../../slugs.js'

export const Podcast: CollectionConfig = {
  slug: podcastCollectionSlug,
  admin: {
    useAsTitle: 'title',
  },
  fields: [
    {
      name: 'id',
      type: 'number',
      required: true,
    },
    {
      name: 'title',
      type: 'text',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Relation1/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationOneSlug } from '../../slugs.js'

export const Relation1: CollectionConfig = {
  fields: baseRelationshipFields,
  slug: relationOneSlug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Relation2/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationTwoSlug } from '../../slugs.js'

export const Relation2: CollectionConfig = {
  fields: baseRelationshipFields,
  slug: relationTwoSlug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Relationship/index.ts

```typescript
import type { CollectionConfig, FilterOptionsProps } from 'payload'

import type { FieldsRelationship } from '../../payload-types.js'

import {
  relationFalseFilterOptionSlug,
  relationOneSlug,
  relationRestrictedSlug,
  relationTrueFilterOptionSlug,
  relationTwoSlug,
  relationWithTitleSlug,
  slug,
} from '../../slugs.js'

export const Relationship: CollectionConfig = {
  admin: {
    defaultColumns: [
      'id',
      'relationship',
      'relationshipRestricted',
      'relationshipHasManyMultiple',
      'relationshipWithTitle',
    ],
  },
  fields: [
    {
      name: 'relationToSelf',
      relationTo: slug,
      type: 'relationship',
    },
    {
      name: 'relationship',
      relationTo: relationOneSlug,
      type: 'relationship',
    },
    {
      name: 'relationshipHasMany',
      hasMany: true,
      relationTo: relationOneSlug,
      type: 'relationship',
    },
    {
      name: 'relationshipMultiple',
      relationTo: [relationOneSlug, relationTwoSlug],
      type: 'relationship',
    },
    {
      name: 'relationshipHasManyMultiple',
      hasMany: true,
      relationTo: [relationOneSlug, relationTwoSlug],
      type: 'relationship',
    },
    {
      name: 'relationshipRestricted',
      relationTo: relationRestrictedSlug,
      type: 'relationship',
    },
    {
      name: 'relationshipWithTitle',
      relationTo: relationWithTitleSlug,
      type: 'relationship',
    },
    {
      name: 'relationshipFilteredByID',
      label: 'Relationship Filtered By ID',
      filterOptions: (args: FilterOptionsProps<FieldsRelationship>) => {
        return {
          id: {
            equals: args.data.relationship,
          },
        }
      },
      relationTo: relationOneSlug,
      type: 'relationship',
      admin: {
        description:
          'This will filter the relationship options based on id, which is the same as the relationship field in this document',
      },
    },
    {
      name: 'relationshipFilteredByField',
      filterOptions: () => {
        return {
          filter: {
            equals: 'Include me',
          },
        }
      },
      admin: {
        description:
          'This will filter the relationship options if the filter field in this document is set to "Include me"',
      },
      relationTo: slug,
      type: 'relationship',
    },
    {
      type: 'collapsible',
      label: 'Collapsible',
      fields: [
        {
          name: 'filteredByFieldInCollapsible',
          filterOptions: () => {
            return {
              filter: {
                equals: 'Include me',
              },
            }
          },
          admin: {
            description:
              'This will filter the relationship options if the filter field in this document is set to "Include me"',
          },
          relationTo: slug,
          type: 'relationship',
        },
      ],
    },
    {
      name: 'array',
      type: 'array',
      label: 'Array',
      fields: [
        {
          name: 'filteredByFieldInArray',
          filterOptions: () => {
            return {
              filter: {
                equals: 'Include me',
              },
            }
          },
          admin: {
            description:
              'This will filter the relationship options if the filter field in this document is set to "Include me"',
          },
          relationTo: slug,
          type: 'relationship',
        },
      ],
    },
    {
      name: 'relationshipFilteredAsync',
      filterOptions: (args: FilterOptionsProps<FieldsRelationship>) => {
        return {
          id: {
            equals: args.data.relationship,
          },
        }
      },
      relationTo: relationOneSlug,
      type: 'relationship',
    },
    {
      name: 'relationshipManyFiltered',
      filterOptions: ({ relationTo, siblingData }) => {
        if (relationTo === relationOneSlug) {
          return { name: { equals: 'include' } }
        }

        if (relationTo === relationTrueFilterOptionSlug) {
          return true
        }

        if (relationTo === relationFalseFilterOptionSlug) {
          return false
        }

        if (siblingData.filter) {
          return { name: { contains: siblingData.filter } }
        }

        return { and: [] }
      },
      hasMany: true,
      relationTo: [
        relationWithTitleSlug,
        relationFalseFilterOptionSlug,
        relationTrueFilterOptionSlug,
        relationOneSlug,
      ],
      type: 'relationship',
    },
    {
      name: 'filter',
      type: 'text',
    },
    {
      name: 'relationshipReadOnly',
      admin: {
        readOnly: true,
      },
      relationTo: relationOneSlug,
      type: 'relationship',
    },
  ],
  slug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/RelationshipFiltered/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { collection1Slug } from '../../slugs.js'

export const Collection1: CollectionConfig = {
  fields: [
    {
      name: 'name',
      type: 'text',
    },
  ],
  slug: collection1Slug,
  admin: {
    useAsTitle: 'name',
  },
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/RelationWithTitle/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationWithTitleSlug } from '../../slugs.js'

export const RelationWithTitle: CollectionConfig = {
  admin: {
    useAsTitle: 'name',
  },
  fields: [
    ...baseRelationshipFields,
    {
      name: 'meta',
      fields: [
        {
          name: 'title',
          label: 'Meta Title',
          type: 'text',
        },
      ],
      type: 'group',
    },
  ],
  slug: relationWithTitleSlug,
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/fields-relationship/collections/Restricted/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import { baseRelationshipFields } from '../../baseFields.js'
import { relationRestrictedSlug } from '../../slugs.js'

export const Restricted: CollectionConfig = {
  access: {
    create: () => false,
    read: () => false,
  },
  admin: {
    useAsTitle: 'name',
  },
  fields: baseRelationshipFields,
  slug: relationRestrictedSlug,
}
```

--------------------------------------------------------------------------------

````
