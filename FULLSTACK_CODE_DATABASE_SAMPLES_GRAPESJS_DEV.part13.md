---
source_txt: fullstack_samples/grapesjs-dev
converted_utc: 2025-12-18T13:04:40Z
part: 13
parts_total: 97
---

# FULLSTACK CODE DATABASE SAMPLES grapesjs-dev

## Verbatim Content (Part 13 of 97)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - grapesjs-dev
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/grapesjs-dev
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: Custom-CSS-parser.md]---
Location: grapesjs-dev/docs/guides/Custom-CSS-parser.md

```text
---
title: Use Custom CSS Parser
---

# Use Custom CSS Parser

If you just use GrapesJS for building templates from scratch, so you start from an empty canvas and for editing you strictly rely on the generated JSON (final HTML/CSS only for end-users) then, probably, you might skip this guide. On the other hand, if you import templates from already defined HTML/CSS or let the user embed custom codes (eg. using the [grapesjs-custom-code](https://github.com/GrapesJS/components-custom-code) plugin), then you have to know that you might face strange behaviors.

::: warning
This guide requires GrapesJS v0.14.33 or higher
:::

[[toc]]

## Import HTML/CSS

Importing already defined HTML/CSS is a really good feature as it lets you start editing immediately any kind of template and obviously, GrapesJS itself promotes this kind of approach

```html
<div id="gjs">
  <div class="txt-red">Hello world!</div>
  <style>
    .txt-red {
      color: red;
    }
  </style>
</div>

<script type="text/javascript">
  const editor = grapesjs.init({
    container: '#gjs',
    fromElement: true,
  });
</script>
```

To work fast and easier GrapesJS needs to compile a simple string (HTML/CSS) into structured nodes (nested JS objects). Fortunately, most of the hard work (parsing) is already done by the browser itself which translates that string into its own objects ([DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)/[CSSOM](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model)) and so we just rely on those, by traversing them and creating our nodes (unfortunately browser's objects are not enough). The fact we're able to parse our strings just by using the browser itself it's very cool, we can enable the import feature without requiring any third-party library, so... where is the problem? Well, while the generated DOM is performing quite well, as we're able to extract what we need, unfortunately, it's not the same for the CSSOM, so let's see in the next paragraph what is wrong with it.

## CSSOM results are inconsistent

Unfortunately, we have discovered that the CSSOM generated by browsers are highly inconsistent from what we ask to parse. To demonstrate it, we gonna create a simple example by using the built-in parser and we'll check its result.
So, for our case we just take in account a simple rule, we'll parse it and print the CSSOM result on screen.

```html
<h1>To parse</h1>
<pre id="css-to-parse">
  .simple-class {
    background-image:url("https://image1.png"), url("https://image2.jpg");
    background-attachment: fixed, scroll;
    background-position:left top, center center;
    background-repeat:repeat-y, no-repeat;
    background-size: contain, cover;
    box-shadow: 0 0 5px #9d7aa5, 0 0 10px #e6c3ee;
    border: 2px solid #FF0000;
  }
</pre>

<h1>Result</h1>
<pre id="result"></pre>

<script>
  // We use ES5 just to make it more cross-browser, without the need of being compiled

  function parse(str) {
    var result = [];
    // Create the element which will contain the style to parse
    var el = document.createElement('style');
    el.innerHTML = str;
    // We have to append the style to get its CSSOM
    document.head.appendChild(el);
    var sheet = el.sheet;
    // Now we can remove it
    document.head.removeChild(el);

    return sheet;
  }

  function CSSOMToString(root) {
    // For the sake of brevity we just print what we need
    var styleStr = '';
    var rule = root.cssRules[0];
    var style = rule.style;
    // The only way we have to iterate over CSSStyleDeclaration
    for (var i = 0, len = style.length; i < len; i++) {
      var property = style[i];
      var value = style.getPropertyValue(property);
      styleStr += '\t' + property + ': ' + value + ';\n';
    }
    var result = document.getElementById('result');
    result.innerHTML = rule.selectorText + ' {\n' + styleStr + '}';
  }

  var css = document.getElementById('css-to-parse').innerText;
  CSSOMToString(parse(css));
</script>
```

### Results

Here some results (using latest versions + IE11)

<img :src="$withBase('/cssom-result.jpg')">

As you see, this is what we get for asking only 7 properties, who adds more or less, someone converts colors to rgba functions and someone else changes the order of our values (eg. `box-shadow`). Webkit-based browsers attach also properties they self don't understand

<img :src="$withBase('/cssom-devtools.png')">

So it's clear that we can't rely on CSSOM objects, that's why we added the possibility to set custom CSS parser via `editor.setCustomParserCss` method or `config.Parser.parserCss` option to use on initialization. Let's see in detail how it's expected to work

## CSSOM results can be nonintuitive

As per current [csswg specification](https://drafts.csswg.org/css-variables-1/#variables-in-shorthands) variables in shorthand properties can serialize to the empty string.
This means that while `background-color: var(--my-var)` will serialize fine `background: var(--my-var)` will not.

## Set CSS parser

The custom parser you have to use it's just a function receiving 2 arguments: `css`, as the CSS string to parse, and `editor`, the instance of the current editor. As the result, you should return an array containing valid rule objects, the syntax of those objects are explained below. This is how you can set the custom parser

```js
const parserCss = (css, editor) => {
  const result = [];
  // ... parse the CSS string
  result.push({
    selectors: '.someclass, div .otherclass',
    style: { color: 'red' },
  });
  // ...
  return result; // Result should be ALWAYS an array
};

// On initialization
// This is the recommended way, as you gonna use the parser from the beginning
const editor = grapesjs.init({
  //...
  parser: {
    parserCss,
  },
});

// Or later, via editor API
editor.setCustomParserCss(parserCss);
```

## Rule Objects

The syntax of rule objects is pretty straightforward, each object might contain following keys

| Key         | Description                                                                                       | Example                         |
| ----------- | ------------------------------------------------------------------------------------------------- | ------------------------------- |
| `selectors` | Selectors of the rule. <br> **REQUIRED** return an empty string in case the rule has no selectors | `.class1, div > #someid`        |
| `style`     | Style declarations as an object                                                                   | `{ color: 'red' }`              |
| `atRule`    | At-rule name                                                                                      | `media`                         |
| `params`    | Parameters of the at-rule                                                                         | `screen and (min-width: 480px)` |

To make it more clear let's see a few examples

```js
// Input
`
@font-face {
  font-family: "Font Name";
  src: url("https://font-url.eot");
}
`
// Output
[
  {
    selectors: '',
    atRule: 'font-face',
    style: {
      'font-family': '"Font Name"',
      src: 'url("https://font-url.eot")',
    },
  }
]

// Input
`
@keyframes keyframe-name {
  from { opacity: 0; }
  to { opacity: 1; }
}
`
// Output
[
  {
    params: 'keyframe-name',
    selectors: 'from',
    atRule: 'keyframes',
    style: {
      opacity: '0',
    },
  }, {
    params: 'keyframe-name',
    selectors: 'to',
    atRule: 'keyframes',
    style: {
      opacity: '1',
    },
  }
]

// Input
`
@media screen and (min-width: 480px) {
    body {
        background-color: lightgreen;
    }

    .class-test, .class-test2:hover {
      color: blue !important;
    }
}
`
// Output
[
  {
    params: 'screen and (min-width: 480px)',
    selectors: 'body',
    atRule: 'media',
    style: {
      'background-color': 'lightgreen',
    },
  }, {
    params: 'screen and (min-width: 480px)',
    selectors: '.class-test, .class-test2:hover',
    atRule: 'media',
    style: {
      color: 'blue !important',
    },
  }
]

// Input
`
:root {
  --some-color: red;
  --some-width: 55px;
}
`
// Output
[
  {
    selectors: ':root',
    style: {
      '--some-color': 'red',
      '--some-width': '55px',
    },
  },
]
```

## Plugins

Below the list of current available CSS parsers as plugins, if you need to create your own we highly suggest to explore their sources

- [grapesjs-parser-postcss](https://github.com/GrapesJS/parser-postcss) - Using [PostCSS](https://github.com/postcss/postcss) parser
```

--------------------------------------------------------------------------------

---[FILE: Replace-Rich-Text-Editor.md]---
Location: grapesjs-dev/docs/guides/Replace-Rich-Text-Editor.md

```text
---
title: Replace the built-in Rich Text Editor
---

# Replace the built-in Rich Text Editor

As you might have noticed the default Rich Text Editor (RTE) is really tiny and so doesn't seem like a complete solution as a text editor. Instead of showing how to add new commands inside the default one we'll show how to completely replace it with another one.

In the following guide we'll integrate the CKEditor and to accomplish this task we just need to provide few functions to the GrapesJS API method `setCustomRte` as an interface.

::: warning
This guide is referring to GrapesJS v0.21.2 or higher
:::

[[toc]]

## Interface

### Enable

The first step is to indicate how to enable the third-party library and so for we gonna start with the `enable()` function. This method should take care of the first initialization of our custom RTE but also for the next time is called on the same element, this is why there is the `rte` argument.

```js
// IMPORTANT: place the code in a new plugin
const customRTE = (editor) => {
  const focus = (el, rte) => {
    // implemented later
  }

  editor.setCustomRte({
    /**
     * Enabling the custom RTE
     * @param  {HTMLElement} el This is the HTML node which was selected to be edited
     * @param  {Object} rte It's the instance you'd return from the first call of enable().
     *                      At the first call it'd be undefined. This is useful when you need
     *                      to check if the RTE is already enabled on the component
     * @return {Object} The return should be the RTE initialized instance
     */
    enable(el, rte) {
      // If already exists just focus
      if (rte) {
        focus(el, rte);
        return rte;
      }

      // CKEditor initialization
      rte = CKEDITOR.inline(el, {
        // Your configurations...
        toolbar: [...],
        // IMPORTANT
        // Generally, inline editors are attached exactly at the same position of
        // the selected element but in this case it'd work until you start to scroll
        // the canvas. For this reason you have to move the RTE's toolbar inside the
        // one from GrapesJS. For this purpose we used a plugin which simplify
        // this process and move all next CKEditor's toolbars inside our indicated
        // element
        sharedSpaces: {
          top: editor.RichTextEditor.getToolbarEl(),
        }
      });

      focus(el, rte);
      return rte;
    },
  });
}

const editor = grapesjs.init({
  ...
  plugins: [customRTE],
});
```

### Disable

Once we know how to enable the RTE let's implement the method which disable it, so let's create the `disable()` function.

```js
editor.setCustomRte({
  // ...
  /**
   * The signature of the function is the same of the `enable`
   */
  disable(el, rte) {
    el.contentEditable = false;
    rte?.focusManager?.blur(true);
  },
});
```

### Content

Each third-party library could handle the state of the content differently and what is actually rendered as a DOM in the preview might not rapresent the final HTML output. So, by default, GrapesJS takes the `innerHTML` as the final output directly from the DOM element but is highly recommended to specify the method responsible to return the final state as HTML string (each third-party library might handle it differently).

```js
editor.setCustomRte({
  // ...
  getContent(el, rte) {
    const htmlString = rte.getData();
    return htmlString;
  },
});
```

### Focus

The `focus()` method is just a helper used inside `enable()` and not required by the interface

```js
const focus = (el, rte) => {
  // Do nothing if already focused
  if (rte?.focusManager?.hasFocus) {
    return;
  }
  el.contentEditable = true;
  rte?.focus();
};

editor.setCustomRte({
  // ...
  enable(el, rte) {
    // ...
    focus(el, rte);
    // ...
  },
});
```

## Toolbar position

Sometimes the default top-left position of the toolbar is not always what you need. For example, when you scroll the canvas and the toolbar reaches the top, you'd like to move it down. For this purpose, you can add a listener which applies your logic in this way:

```js
editor.on('rteToolbarPosUpdate', (pos) => {
  // eg. update `pos.top` and `pos.left` based on additional data passed inside `pos`
});
```

## The built-in vs third-party

One thing you have to keep in mind when using a custom RTE is that all the content and its behavior are handled by the library itself, the GrapesJS's component will just store the content as it is.
For example, when you create a link using the built-in RTE then you'll be able to select it and edit its `href` via Component Settings. With a custom RTE, it will be its own task to show the proper modal for the link editing.
Obviously, each third-party library has its own APIs and can present some limitations and drawbacks, so, a minimal knowledge of the library is a plus.

### Enable content parser

As an experimental feature, now it's possible to tell the editor to parse the returned HTML content from the custom RTE and store the result as components and not as a simple HTML string. This allows GrapesJS to handle the custom RTE more closely to the native implementation and enable features like [textable components](https://github.com/GrapesJS/grapesjs/issues/2771#issuecomment-1040486056).

```js
editor.setCustomRte({
  // ...
  // Enable content parser
  parseContent: true,
});
```

## Plugins

For the CKEditor, you can find a complete plugin here [grapesjs-plugin-ckeditor](https://github.com/GrapesJS/ckeditor).
```

--------------------------------------------------------------------------------

---[FILE: Symbols.md]---
Location: grapesjs-dev/docs/guides/Symbols.md

```text
---
title: Symbols
---

# Symbols

::: warning
This feature is released as a beta from GrapesJS v0.21.11

To get a better understanding of the content in this guide we recommend reading [Components] first
:::

Symbols are a special type of [Component] that allows you to easily reuse common elements across your project. They are particularly useful for components that appear multiple times in your project and need to remain consistent. By using Symbols, you can easily update these components in one place and have the changes reflected everywhere they are used.

[[toc]]

## Concept

A Symbol created from a component retains the same shape and uses the same [Components API], but it includes a reference to other related Symbols. When you create a new Symbol from a Component, it creates a Main Symbol, and the original component becomes an Instance Symbol.

When you reuse the Symbol elsewhere, it creates new Instance Symbols. Any updates made to the Main Symbol are automatically replicated in all Instance Symbols, ensuring consistency throughout your project.

Below is a simple representation of the connection between Main and Instance Symbols.

<img :src="$withBase('/symbols-model.svg')">

::: warning Note
This feature operates at a low level, meaning there is no built-in UI for creating and managing symbols. Developers need to implement their own UI to interact with this feature. Below you'll find an example of implementation.
:::

## Programmatic usage

Let's see how to work with and manage Symbols in your project.

### Create symbol

Create a new Symbol from any component in your project:

```js
const anyComponent = editor.getSelected();
const symbolMain = editor.Components.addSymbol(anyComponent);
```

This will transform `anyComponent` to an Instance and the returned `symbolMain` will be the Main Symbol. GrapesJS keeps track of Main Symbols separately in your project JSON, and they will be automatically reconnected when you reload the project.

The `addSymbol` method also handles the creation of Instances. If you call it again by passing `symbolMain` or `anyComponent`, it will create a new Instance of `symbolMain`.

```js
const secondInstance = editor.Components.addSymbol(symbolMain);
```

Now, `symbolMain` references two instances of its shape.

To get all the available Symbols in your project, use `getSymbols`:

```js
const symbols = editor.Components.getSymbols();
const symbolMain = symbols[0];
```

### Symbol details

Once you have Symbols in your project, you might need to know when a Component is a Symbol and get details about it. Use the `getSymbolInfo` method for this:

```js
// Details from the Main Symbol
const symbolMainInfo = editor.Components.getSymbolInfo(symbolMain);

symbolMainInfo.isSymbol; // true; It's a Symbol
symbolMainInfo.isRoot; // true; It's the root of the Symbol
symbolMainInfo.isMain; // true; It's the Main Symbol
symbolMainInfo.isInstance; // false; It's not the Instance Symbol
symbolMainInfo.main; // symbolMainInfo; Reference to the Main Symbol
symbolMainInfo.instances; // [anyComponent, secondInstance]; Reference to Instance Symbols
symbolMainInfo.relatives; // [anyComponent, secondInstance]; Relative Symbols

// Details from the Instance Symbol
const secondInstanceInfo = editor.Components.getSymbolInfo(secondInstance);

symbolMainInfo.isSymbol; // true; It's a Symbol
symbolMainInfo.isRoot; // true; It's the root of the Symbol
symbolMainInfo.isMain; // false; It's not the Main Symbol
symbolMainInfo.isInstance; // true; It's the Instance Symbol
symbolMainInfo.main; // symbolMainInfo; Reference to the Main Symbol
symbolMainInfo.instances; // [anyComponent, secondInstance]; Reference to Instance Symbols
symbolMainInfo.relatives; // [anyComponent, symbolMain]; Relative Symbols
```

### Overrides

When you update a Symbol's properties, changes are propagated to all related Symbols. To avoid propagating specific properties, you can specify at the component level which properties to skip:

```js
anyComponent.set('my-property', true);
secondInstance.get('my-property'); // true; change propagated

anyComponent.setSymbolOverride(['my-property']);
// Get current override value: anyComponent.getSymbolOverride();

anyComponent.set('my-property', false);
secondInstance.get('my-property'); // true; change didn't propagate
```

### Detach symbol

Once you have Symbol instances you might need to disconnect one to create a new custom shape with other components inside, in that case you can use `detachSymbol`.

```js
editor.Components.detachSymbol(anyComponent);

const info = editor.Components.getSymbolInfo(anyComponent);
info.isSymbol; // false; Not a Symbol anymore

const infoMain = editor.Components.getSymbolInfo(symbolMain);
infoMain.instances; // [secondInstance]; Removed the reference
```

### Remove symbol

To remove a Main Symbol and detach all related instances:

```js
const symbolMain = editor.Components.getSymbols()[0];
symbolMain.remove();
```

## Events

The editor triggers several symbol-related events that you can leverage for your integration:

- `symbol:main:add` Added new root main symbol.

```js
editor.on('symbol:main:add', ({ component }) => { ... });
```

- `symbol:main:update` Root main symbol updated.

```js
editor.on('symbol:main:update', ({ component }) => { ... });
```

- `symbol:main:remove` Root main symbol removed.

```js
editor.on('symbol:main:remove', ({ component }) => { ... });
```

- `symbol:main` Catch-all event related to root main symbol updates.

```js
editor.on('symbol:main', ({ event, component }) => { ... });
```

- `symbol:instance:add` Added new root instance symbol.

```js
editor.on('symbol:instance:add', ({ component }) => { ... });
```

- `symbol:instance:remove` Root instance symbol removed.

```js
editor.on('symbol:instance:remove', ({ component }) => { ... });
```

- `symbol:instance` Catch-all event related to root instance symbol updates.

```js
editor.on('symbol:instance', ({ event, component }) => { ... });
```

- `symbol` Catch-all event for any symbol update (main or instance).

```js
editor.on('symbol', () => { ... });
```

## Example

Below is a basic UI implementation leveraging the Symbols API:

<demo-viewer value="ta19s6go" height="500" darkcode show/>

<!-- Demo template, here for reference
<style>
.app-wrapper {
  height: 100vh;
  display: flex;
  flex-direction: column;
}
.vue-app {
  padding: 10px;
  display: flex;
  gap: 10px;
}
.symbols-wrp {
  display: flex;
  gap: 10px;
  width: 100%;
  padding: 10px;
  flex-direction: column;
  border-radius: 3px;
}
.symbols {
  display: flex;
  gap: 10px;
  width: 100%;
}
.symbol {
  cursor: pointer;
  flex-basis: 100px;
  text-align: left;
  margin: 0;
}
</style>

<div class="app-wrapper">
  <div class="vue-app">
    <button @click="createSymbol">Create Symbol</button>
    <div class="symbols-wrp gjs-one-bg gjs-two-color">
      <div v-if="symbols.length">Click on symbol to append</div>
      <div class="symbols">
        <div
          v-for="symbol in symbols"
          class="gjs-block symbol"
          @click="createInstance(symbol)"
          :key="symbol.getId()"
        >
          Name: {{ symbol.getName() }}
          Instances: {{ getInstancesLength(symbol) }}
        </div>
      </div>
    </div>
  </div>
  <div id="gjs"></div>
</div>

<script>
const editor = grapesjs.init({
  container: '#gjs',
  height: '100%',
  storageManager: false,
  components: `<div style="display: flex">
    <article class="card" style="max-width: 300px; padding: 20px">
      <img src="https://placehold.co/600x400/000000/FFF" style="max-width: 100%"/>
      <h1>Title</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>
    </article>
  </div>`,
  plugins: ['gjs-blocks-basic'],
  selectorManager: { componentFirst: true },
});

const { Components } = editor;

const app = new Vue({
  el: '.vue-app',
  data: { symbols: [] },
  mounted() {
		editor.on('symbol', this.updateMainSymbolsList);
  },
  destroyed() {
    editor.off('symbol', this.updateMainSymbolsList);
  },
  methods: {
    updateMainSymbolsList() {
      this.symbols = Components.getSymbols();
    },
    createSymbol() {
      const selected = editor.getSelected();
      if (!selected) return alert('Select a component first!');

      const info = Components.getSymbolInfo(selected);
      if (info.isSymbol) return alert('Selected component is already a symbol!');

      Components.addSymbol(selected);
    },
    getInstancesLength(symbolMain) {
      return Components.getSymbolInfo(symbolMain).instances.length;
    },
    createInstance(symbolMain) {
      const instance = Components.addSymbol(symbolMain);
      editor.getWrapper().append(instance, { at: 0 });
    }
  }
});
</script>
-->

[Component]: /modules/Components.html
[Components]: /modules/Components.html
[Components API]: /api/component.html
```

--------------------------------------------------------------------------------

---[FILE: Telemetry.md]---
Location: grapesjs-dev/docs/guides/Telemetry.md

```text
---
title: GrapesJS Telemetry
---

# GrapesJS Telemetry

We collect and use data to improve GrapesJS. This page explains what data we collect and how we use it.

## What data we collect

We collect the following data:

- **domain**: The domain of the website where GrapesJS is used.
- **version**: The version of GrapesJS used.
- **timestamp**: The time when the editor is loaded.

## How we use data

We use data to:

- **Improve GrapesJS**: We use data to improve GrapesJS. For example, we use data to identify bugs and fix them.
- **Analyze usage**: We use data to analyze how GrapesJS is used. For example, we use data to understand which features are used most often.
- **Provide support**: We use data to provide support to users. For example, we use data to understand how users interact with GrapesJS.

## How to opt-out

You can opt-out of data collection by setting the `telemetry` option to `false` when initializing GrapesJS:

```js
const editor = grapesjs.init({
  // ...
  telemetry: false,
});
```
```

--------------------------------------------------------------------------------

````
