---
source_txt: user_created_projects/vscode-main
converted_utc: 2025-12-18T18:22:26Z
part: 179
parts_total: 552
---

# FULLSTACK CODE DATABASE USER CREATED vscode-main

## Verbatim Content (Part 179 of 552)

````text
================================================================================
FULLSTACK USER CREATED CODE DATABASE (VERBATIM) - vscode-main
================================================================================
Generated: December 18, 2025
Source: user_created_projects/vscode-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: src/vs/base/common/marked/marked.js]---
Location: vscode-main/src/vs/base/common/marked/marked.js

```javascript
/**
 * marked v14.0.0 - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

/**
 * Gets the original marked default options.
 */
function _getDefaults() {
    return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null,
    };
}
let _defaults = _getDefaults();
function changeDefaults(newDefaults) {
    _defaults = newDefaults;
}

/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$1(html, encode) {
    if (encode) {
        if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
        }
    }
    else {
        if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
    }
    return html;
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
    let source = typeof regex === 'string' ? regex : regex.source;
    opt = opt || '';
    const obj = {
        replace: (name, val) => {
            let valSource = typeof val === 'string' ? val : val.source;
            valSource = valSource.replace(caret, '$1');
            source = source.replace(name, valSource);
            return obj;
        },
        getRegex: () => {
            return new RegExp(source, opt);
        },
    };
    return obj;
}
function cleanUrl(href) {
    try {
        href = encodeURI(href).replace(/%25/g, '%');
    }
    catch {
        return null;
    }
    return href;
}
const noopTest = { exec: () => null };
function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false;
        let curr = offset;
        while (--curr >= 0 && str[curr] === '\\')
            escaped = !escaped;
        if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
        }
        else {
            // add space before unescaped |
            return ' |';
        }
    }), cells = row.split(/ \|/);
    let i = 0;
    // First/last cell in a row cannot be empty if it has no leading/trailing pipe
    if (!cells[0].trim()) {
        cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
    }
    if (count) {
        if (cells.length > count) {
            cells.splice(count);
        }
        else {
            while (cells.length < count)
                cells.push('');
        }
    }
    for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }
    return cells;
}
/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param str
 * @param c
 * @param invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
        return '';
    }
    // Length of suffix matching the invert condition.
    let suffLen = 0;
    // Step left until we fail to match the invert condition.
    while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
            suffLen++;
        }
        else if (currChar !== c && invert) {
            suffLen++;
        }
        else {
            break;
        }
    }
    return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
        return -1;
    }
    let level = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
            i++;
        }
        else if (str[i] === b[0]) {
            level++;
        }
        else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
                return i;
            }
        }
    }
    return -1;
}

function outputLink(cap, link, raw, lexer) {
    const href = link.href;
    const title = link.title ? escape$1(link.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, '$1');
    if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
            type: 'link',
            raw,
            href,
            title,
            text,
            tokens: lexer.inlineTokens(text),
        };
        lexer.state.inLink = false;
        return token;
    }
    return {
        type: 'image',
        raw,
        href,
        title,
        text: escape$1(text),
    };
}
function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
        return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text
        .split('\n')
        .map(node => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
            return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
        }
        return node;
    })
        .join('\n');
}
/**
 * Tokenizer
 */
class _Tokenizer {
    options;
    rules; // set by the lexer
    lexer; // set by the lexer
    constructor(options) {
        this.options = options || _defaults;
    }
    space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
            return {
                type: 'space',
                raw: cap[0],
            };
        }
    }
    code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
            const text = cap[0].replace(/^ {1,4}/gm, '');
            return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic
                    ? rtrim(text, '\n')
                    : text,
            };
        }
    }
    fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
            const raw = cap[0];
            const text = indentCodeCompensation(raw, cap[3] || '');
            return {
                type: 'code',
                raw,
                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],
                text,
            };
        }
    }
    heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
            let text = cap[2].trim();
            // remove trailing #s
            if (/#$/.test(text)) {
                const trimmed = rtrim(text, '#');
                if (this.options.pedantic) {
                    text = trimmed.trim();
                }
                else if (!trimmed || / $/.test(trimmed)) {
                    // CommonMark requires space before trailing #s
                    text = trimmed.trim();
                }
            }
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text,
                tokens: this.lexer.inline(text),
            };
        }
    }
    hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
            return {
                type: 'hr',
                raw: rtrim(cap[0], '\n'),
            };
        }
    }
    blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
            let lines = rtrim(cap[0], '\n').split('\n');
            let raw = '';
            let text = '';
            const tokens = [];
            while (lines.length > 0) {
                let inBlockquote = false;
                const currentLines = [];
                let i;
                for (i = 0; i < lines.length; i++) {
                    // get lines up to a continuation
                    if (/^ {0,3}>/.test(lines[i])) {
                        currentLines.push(lines[i]);
                        inBlockquote = true;
                    }
                    else if (!inBlockquote) {
                        currentLines.push(lines[i]);
                    }
                    else {
                        break;
                    }
                }
                lines = lines.slice(i);
                const currentRaw = currentLines.join('\n');
                const currentText = currentRaw
                    // precede setext continuation with 4 spaces so it isn't a setext
                    .replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, '\n    $1')
                    .replace(/^ {0,3}>[ \t]?/gm, '');
                raw = raw ? `${raw}\n${currentRaw}` : currentRaw;
                text = text ? `${text}\n${currentText}` : currentText;
                // parse blockquote lines as top level tokens
                // merge paragraphs if this is a continuation
                const top = this.lexer.state.top;
                this.lexer.state.top = true;
                this.lexer.blockTokens(currentText, tokens, true);
                this.lexer.state.top = top;
                // if there is no continuation then we are done
                if (lines.length === 0) {
                    break;
                }
                const lastToken = tokens[tokens.length - 1];
                if (lastToken?.type === 'code') {
                    // blockquote continuation cannot be preceded by a code block
                    break;
                }
                else if (lastToken?.type === 'blockquote') {
                    // include continuation in nested blockquote
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.blockquote(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;
                    break;
                }
                else if (lastToken?.type === 'list') {
                    // include continuation in nested list
                    const oldToken = lastToken;
                    const newText = oldToken.raw + '\n' + lines.join('\n');
                    const newToken = this.list(newText);
                    tokens[tokens.length - 1] = newToken;
                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;
                    lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\n');
                    continue;
                }
            }
            return {
                type: 'blockquote',
                raw,
                tokens,
                text,
            };
        }
    }
    list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
            let bull = cap[1].trim();
            const isordered = bull.length > 1;
            const list = {
                type: 'list',
                raw: '',
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: [],
            };
            bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
            if (this.options.pedantic) {
                bull = isordered ? bull : '[*+-]';
            }
            // Get next list item
            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
            let endsWithBlankLine = false;
            // Check if current bullet point can start a new List Item
            while (src) {
                let endEarly = false;
                let raw = '';
                let itemContents = '';
                if (!(cap = itemRegex.exec(src))) {
                    break;
                }
                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                    break;
                }
                raw = cap[0];
                src = src.substring(raw.length);
                let line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
                let nextLine = src.split('\n', 1)[0];
                let blankLine = !line.trim();
                let indent = 0;
                if (this.options.pedantic) {
                    indent = 2;
                    itemContents = line.trimStart();
                }
                else if (blankLine) {
                    indent = cap[1].length + 1;
                }
                else {
                    indent = cap[2].search(/[^ ]/); // Find first non-space char
                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                    itemContents = line.slice(indent);
                    indent += cap[1].length;
                }
                if (blankLine && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
                    raw += nextLine + '\n';
                    src = src.substring(nextLine.length + 1);
                    endEarly = true;
                }
                if (!endEarly) {
                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
                    // Check if following lines should be included in List Item
                    while (src) {
                        const rawLine = src.split('\n', 1)[0];
                        nextLine = rawLine;
                        // Re-align to follow commonmark nesting rules
                        if (this.options.pedantic) {
                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                        }
                        // End list item if found code fences
                        if (fencesBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new heading
                        if (headingBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new bullet
                        if (nextBulletRegex.test(nextLine)) {
                            break;
                        }
                        // Horizontal rule found
                        if (hrRegex.test(src)) {
                            break;
                        }
                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                            itemContents += '\n' + nextLine.slice(indent);
                        }
                        else {
                            // not enough indentation
                            if (blankLine) {
                                break;
                            }
                            // paragraph continuation unless last line was a different block level element
                            if (line.search(/[^ ]/) >= 4) { // indented code block
                                break;
                            }
                            if (fencesBeginRegex.test(line)) {
                                break;
                            }
                            if (headingBeginRegex.test(line)) {
                                break;
                            }
                            if (hrRegex.test(line)) {
                                break;
                            }
                            itemContents += '\n' + nextLine;
                        }
                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                            blankLine = true;
                        }
                        raw += rawLine + '\n';
                        src = src.substring(rawLine.length + 1);
                        line = nextLine.slice(indent);
                    }
                }
                if (!list.loose) {
                    // If the previous item ended with a blank line, the list is loose
                    if (endsWithBlankLine) {
                        list.loose = true;
                    }
                    else if (/\n *\n *$/.test(raw)) {
                        endsWithBlankLine = true;
                    }
                }
                let istask = null;
                let ischecked;
                // Check for task list items
                if (this.options.gfm) {
                    istask = /^\[[ xX]\] /.exec(itemContents);
                    if (istask) {
                        ischecked = istask[0] !== '[ ] ';
                        itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
                    }
                }
                list.items.push({
                    type: 'list_item',
                    raw,
                    task: !!istask,
                    checked: ischecked,
                    loose: false,
                    text: itemContents,
                    tokens: [],
                });
                list.raw += raw;
            }
            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
            list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();
            list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();
            list.raw = list.raw.trimEnd();
            // Item child tokens handled here at end because we needed to have the final item to trim it first
            for (let i = 0; i < list.items.length; i++) {
                this.lexer.state.top = false;
                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                if (!list.loose) {
                    // Check if list should be loose
                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
                    list.loose = hasMultipleLineBreaks;
                }
            }
            // Set all items to loose if list is loose
            if (list.loose) {
                for (let i = 0; i < list.items.length; i++) {
                    list.items[i].loose = true;
                }
            }
            return list;
        }
    }
    html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
            const token = {
                type: 'html',
                block: true,
                raw: cap[0],
                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0],
            };
            return token;
        }
    }
    def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
            const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';
            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];
            return {
                type: 'def',
                tag,
                raw: cap[0],
                href,
                title,
            };
        }
    }
    table(src) {
        const cap = this.rules.block.table.exec(src);
        if (!cap) {
            return;
        }
        if (!/[:|]/.test(cap[2])) {
            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
            return;
        }
        const headers = splitCells(cap[1]);
        const aligns = cap[2].replace(/^\||\| *$/g, '').split('|');
        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : [];
        const item = {
            type: 'table',
            raw: cap[0],
            header: [],
            align: [],
            rows: [],
        };
        if (headers.length !== aligns.length) {
            // header and align columns must be equal, rows can be different.
            return;
        }
        for (const align of aligns) {
            if (/^ *-+: *$/.test(align)) {
                item.align.push('right');
            }
            else if (/^ *:-+: *$/.test(align)) {
                item.align.push('center');
            }
            else if (/^ *:-+ *$/.test(align)) {
                item.align.push('left');
            }
            else {
                item.align.push(null);
            }
        }
        for (let i = 0; i < headers.length; i++) {
            item.header.push({
                text: headers[i],
                tokens: this.lexer.inline(headers[i]),
                header: true,
                align: item.align[i],
            });
        }
        for (const row of rows) {
            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
                return {
                    text: cell,
                    tokens: this.lexer.inline(cell),
                    header: false,
                    align: item.align[i],
                };
            }));
        }
        return item;
    }
    lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
                tokens: this.lexer.inline(cap[1]),
            };
        }
    }
    paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
            const text = cap[1].charAt(cap[1].length - 1) === '\n'
                ? cap[1].slice(0, -1)
                : cap[1];
            return {
                type: 'paragraph',
                raw: cap[0],
                text,
                tokens: this.lexer.inline(text),
            };
        }
    }
    text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                tokens: this.lexer.inline(cap[0]),
            };
        }
    }
    escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
            return {
                type: 'escape',
                raw: cap[0],
                text: escape$1(cap[1]),
            };
        }
    }
    tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                this.lexer.state.inLink = true;
            }
            else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = true;
            }
            else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = false;
            }
            return {
                type: 'html',
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: cap[0],
            };
        }
    }
    link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
            const trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                // commonmark requires matching angle brackets
                if (!(/>$/.test(trimmedUrl))) {
                    return;
                }
                // ending angle bracket cannot be escaped
                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                    return;
                }
            }
            else {
                // find closing parenthesis
                const lastParenIndex = findClosingBracket(cap[2], '()');
                if (lastParenIndex > -1) {
                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                    const linkLen = start + cap[1].length + lastParenIndex;
                    cap[2] = cap[2].substring(0, lastParenIndex);
                    cap[0] = cap[0].substring(0, linkLen).trim();
                    cap[3] = '';
                }
            }
            let href = cap[2];
            let title = '';
            if (this.options.pedantic) {
                // split pedantic href and title
                const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                if (link) {
                    href = link[1];
                    title = link[3];
                }
            }
            else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim();
            if (/^</.test(href)) {
                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
                    // pedantic allows starting angle bracket without ending angle bracket
                    href = href.slice(1);
                }
                else {
                    href = href.slice(1, -1);
                }
            }
            return outputLink(cap, {
                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,
                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,
            }, cap[0], this.lexer);
        }
    }
    reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
            const linkString = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            const link = links[linkString.toLowerCase()];
            if (!link) {
                const text = cap[0].charAt(0);
                return {
                    type: 'text',
                    raw: text,
                    text,
                };
            }
            return outputLink(cap, link, cap[0], this.lexer);
        }
    }
    emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrongLDelim.exec(src);
        if (!match)
            return;
        // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
            return;
        const nextChar = match[1] || match[2] || '';
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
            const lLength = [...match[0]].length - 1;
            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            endReg.lastIndex = 0;
            // Clip maskedSrc to same section of string as src (move to lexer?)
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim)
                    continue; // skip single * in __abc*abc__
                rLength = [...rDelim].length;
                if (match[3] || match[4]) { // found another Left Delim
                    delimTotal += rLength;
                    continue;
                }
                else if (match[5] || match[6]) { // either Left or Right Delim
                    if (lLength % 3 && !((lLength + rLength) % 3)) {
                        midDelimTotal += rLength;
                        continue; // CommonMark Emphasis Rules 9-10
                    }
                }
                delimTotal -= rLength;
                if (delimTotal > 0)
                    continue; // Haven't found enough closing delimiters
                // Remove extra characters. *a*** -> *a*
                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                // char length can be >1 for unicode characters;
                const lastCharLength = [...match[0]][0].length;
                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                // Create `em` if smallest delimiter has odd char count. *a***
                if (Math.min(lLength, rLength) % 2) {
                    const text = raw.slice(1, -1);
                    return {
                        type: 'em',
                        raw,
                        text,
                        tokens: this.lexer.inlineTokens(text),
                    };
                }
                // Create 'strong' if smallest delimiter has even char count. **a***
                const text = raw.slice(2, -2);
                return {
                    type: 'strong',
                    raw,
                    text,
                    tokens: this.lexer.inlineTokens(text),
                };
            }
        }
    }
    codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
            let text = cap[2].replace(/\n/g, ' ');
            const hasNonSpaceChars = /[^ ]/.test(text);
            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
            }
            text = escape$1(text, true);
            return {
                type: 'codespan',
                raw: cap[0],
                text,
            };
        }
    }
    br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
            return {
                type: 'br',
                raw: cap[0],
            };
        }
    }
    del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
            return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2]),
            };
        }
    }
    autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
            let text, href;
            if (cap[2] === '@') {
                text = escape$1(cap[1]);
                href = 'mailto:' + text;
            }
            else {
                text = escape$1(cap[1]);
                href = text;
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text,
                    },
                ],
            };
        }
    }
    url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
            let text, href;
            if (cap[2] === '@') {
                text = escape$1(cap[0]);
                href = 'mailto:' + text;
            }
            else {
                // do extended autolink path validation
                let prevCapZero;
                do {
                    prevCapZero = cap[0];
                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';
                } while (prevCapZero !== cap[0]);
                text = escape$1(cap[0]);
                if (cap[1] === 'www.') {
                    href = 'http://' + cap[0];
                }
                else {
                    href = cap[0];
                }
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text,
                    },
                ],
            };
        }
    }
    inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
            let text;
            if (this.lexer.state.inRawBlock) {
                text = cap[0];
            }
            else {
                text = escape$1(cap[0]);
            }
            return {
                type: 'text',
                raw: cap[0],
                text,
            };
        }
    }
}

/**
 * Block-Level Grammar
 */
const newline = /^(?: *(?:\n|$))+/;
const blockCode = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/;
const fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
const hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
const heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
const bullet = /(?:[*+-]|\d{1,9}[.)])/;
const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/)
    .replace(/bull/g, bullet) // lists can interrupt
    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt
    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt
    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt
    .replace(/html/g, / {0,3}<[^\n>]+>\n/) // block html can interrupt
    .getRegex();
const _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
const blockText = /^[^\n]+/;
const _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
const def = edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
    .replace('label', _blockLabel)
    .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
    .getRegex();
const list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
    .replace(/bull/g, bullet)
    .getRegex();
const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'
    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'
    + '|tr|track|ul';
const _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
const html = edit('^ {0,3}(?:' // optional indentation
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')', 'i')
    .replace('comment', _comment)
    .replace('tag', _tag)
    .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
    .getRegex();
const paragraph = edit(_paragraph)
    .replace('hr', hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
    .replace('|table', '')
    .replace('blockquote', ' {0,3}>')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
    .getRegex();
const blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
    .replace('paragraph', paragraph)
    .getRegex();
/**
 * Normal Block Grammar
 */
const blockNormal = {
    blockquote,
    code: blockCode,
    def,
    fences,
    heading,
    hr,
    html,
    lheading,
    list,
    newline,
    paragraph,
    table: noopTest,
    text: blockText,
};
/**
 * GFM Block Grammar
 */
const gfmTable = edit('^ *([^\\n ].*)\\n' // Header
    + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)') // Cells
    .replace('hr', hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('blockquote', ' {0,3}>')
    .replace('code', ' {4}[^\\n]')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks
    .getRegex();
const blockGfm = {
    ...blockNormal,
    table: gfmTable,
    paragraph: edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs
        .replace('table', gfmTable) // interrupt paragraphs with table
        .replace('blockquote', ' {0,3}>')
        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks
        .getRegex(),
};
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */
const blockPedantic = {
    ...blockNormal,
    html: edit('^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', _comment)
        .replace(/tag/g, '(?!(?:'
        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
        + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest, // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(_paragraph)
        .replace('hr', hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', lheading)
        .replace('|table', '')
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .replace('|tag', '')
        .getRegex(),
};
/**
 * Inline-Level Grammar
 */
const escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
const inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
const br = /^( {2,}|\\)\n(?!\s*$)/;
const inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
// list of unicode punctuation marks, plus any missing characters from CommonMark spec
const _punctuation = '\\p{P}\\p{S}';
const punctuation = edit(/^((?![*_])[\spunctuation])/, 'u')
    .replace(/punctuation/g, _punctuation).getRegex();
// sequences em should skip over [title](link), `code`, <html>
const blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
const emStrongLDelim = edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, 'u')
    .replace(/punct/g, _punctuation)
    .getRegex();
const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)' // Skip orphan inside strong
    + '|[^*]+(?=[^*])' // Consume to delim
    + '|(?!\\*)[punct](\\*+)(?=[\\s]|$)' // (1) #*** can only be a Right Delimiter
    + '|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter
    + '|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])' // (3) #***a, ***a can only be Left Delimiter
    + '|[\\s](\\*+)(?!\\*)(?=[punct])' // (4) ***# can only be Left Delimiter
    + '|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter
    + '|[^punct\\s](\\*+)(?=[^punct\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter
    .replace(/punct/g, _punctuation)
    .getRegex();
// (6) Not allowed for _
const emStrongRDelimUnd = edit('^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)' // Skip orphan inside strong
    + '|[^_]+(?=[^_])' // Consume to delim
    + '|(?!_)[punct](_+)(?=[\\s]|$)' // (1) #___ can only be a Right Delimiter
    + '|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter
    + '|(?!_)[punct\\s](_+)(?=[^punct\\s])' // (3) #___a, ___a can only be Left Delimiter
    + '|[\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter
    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter
    .replace(/punct/g, _punctuation)
    .getRegex();
const anyPunctuation = edit(/\\([punct])/, 'gu')
    .replace(/punct/g, _punctuation)
    .getRegex();
const autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
    .getRegex();
const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();
const tag = edit('^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>') // CDATA section
    .replace('comment', _inlineComment)
    .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
    .getRegex();
const _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
const link = edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
    .replace('label', _inlineLabel)
    .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
    .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
    .getRegex();
const reflink = edit(/^!?\[(label)\]\[(ref)\]/)
    .replace('label', _inlineLabel)
    .replace('ref', _blockLabel)
    .getRegex();
const nolink = edit(/^!?\[(ref)\](?:\[\])?/)
    .replace('ref', _blockLabel)
    .getRegex();
const reflinkSearch = edit('reflink|nolink(?!\\()', 'g')
    .replace('reflink', reflink)
    .replace('nolink', nolink)
    .getRegex();
/**
 * Normal Inline Grammar
 */
const inlineNormal = {
    _backpedal: noopTest, // only used for GFM url
    anyPunctuation,
    autolink,
    blockSkip,
    br,
    code: inlineCode,
    del: noopTest,
    emStrongLDelim,
    emStrongRDelimAst,
    emStrongRDelimUnd,
    escape,
    link,
    nolink,
    punctuation,
    reflink,
    reflinkSearch,
    tag,
    text: inlineText,
    url: noopTest,
};
/**
 * Pedantic Inline Grammar
 */
const inlinePedantic = {
    ...inlineNormal,
    link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', _inlineLabel)
        .getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', _inlineLabel)
        .getRegex(),
};
/**
 * GFM Inline Grammar
 */
const inlineGfm = {
    ...inlineNormal,
    escape: edit(escape).replace('])', '~|])').getRegex(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
        .getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
};
/**
 * GFM + Line Breaks Inline Grammar
 */
const inlineBreaks = {
    ...inlineGfm,
    br: edit(br).replace('{2,}', '*').getRegex(),
    text: edit(inlineGfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex(),
};
/**
 * exports
 */
const block = {
    normal: blockNormal,
    gfm: blockGfm,
    pedantic: blockPedantic,
};
const inline = {
    normal: inlineNormal,
    gfm: inlineGfm,
    breaks: inlineBreaks,
    pedantic: inlinePedantic,
};

/**
 * Block Lexer
 */
class _Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options) {
        // TokenList cannot be created in one go
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
            inLink: false,
            inRawBlock: false,
            top: true,
        };
        const rules = {
            block: block.normal,
            inline: inline.normal,
        };
        if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
        }
        else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
                rules.inline = inline.breaks;
            }
            else {
                rules.inline = inline.gfm;
            }
        }
        this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
        return {
            block,
            inline,
        };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
        src = src
            .replace(/\r\n|\r/g, '\n');
        this.blockTokens(src, this.tokens);
        for (let i = 0; i < this.inlineQueue.length; i++) {
            const next = this.inlineQueue[i];
            this.inlineTokens(next.src, next.tokens);
        }
        this.inlineQueue = [];
        return this.tokens;
    }
    blockTokens(src, tokens = [], lastParagraphClipped = false) {
        if (this.options.pedantic) {
            src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
        }
        else {
            src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
                return leading + '    '.repeat(tabs.length);
            });
        }
        let token;
        let lastToken;
        let cutSrc;
        while (src) {
            if (this.options.extensions
                && this.options.extensions.block
                && this.options.extensions.block.some((extTokenizer) => {
                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                        src = src.substring(token.raw.length);
                        tokens.push(token);
                        return true;
                    }
                    return false;
                })) {
                continue;
            }
            // newline
            if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length);
                if (token.raw.length === 1 && tokens.length > 0) {
                    // if there's a single \n as a spacer, it's terminating the last line,
                    // so move it there so that we don't get unnecessary paragraph tags
                    tokens[tokens.length - 1].raw += '\n';
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // code
            if (token = this.tokenizer.code(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                // An indented code block cannot interrupt a paragraph.
                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // fences
            if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // heading
            if (token = this.tokenizer.heading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // hr
            if (token = this.tokenizer.hr(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // blockquote
            if (token = this.tokenizer.blockquote(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // list
            if (token = this.tokenizer.list(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // html
            if (token = this.tokenizer.html(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // def
            if (token = this.tokenizer.def(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.raw;
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else if (!this.tokens.links[token.tag]) {
                    this.tokens.links[token.tag] = {
                        href: token.href,
                        title: token.title,
                    };
                }
                continue;
            }
            // table (gfm)
            if (token = this.tokenizer.table(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // lheading
            if (token = this.tokenizer.lheading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // top-level paragraph
            // prevent paragraph consuming extensions by clipping 'src' to extension start
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startBlock) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startBlock.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                lastToken = tokens[tokens.length - 1];
                if (lastParagraphClipped && lastToken?.type === 'paragraph') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                lastParagraphClipped = (cutSrc.length !== src.length);
                src = src.substring(token.raw.length);
                continue;
            }
            // text
            if (token = this.tokenizer.text(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        this.state.top = true;
        return tokens;
    }
    inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        // String with links masked to avoid interference with em and strong
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        // Mask out reflinks
        if (this.tokens.links) {
            const links = Object.keys(this.tokens.links);
            if (links.length > 0) {
                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                    }
                }
            }
        }
        // Mask out other blocks
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        // Mask out escaped characters
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
            if (!keepPrevChar) {
                prevChar = '';
            }
            keepPrevChar = false;
            // extensions
            if (this.options.extensions
                && this.options.extensions.inline
                && this.options.extensions.inline.some((extTokenizer) => {
                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                        src = src.substring(token.raw.length);
                        tokens.push(token);
                        return true;
                    }
                    return false;
                })) {
                continue;
            }
            // escape
            if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // tag
            if (token = this.tokenizer.tag(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // link
            if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // reflink, nolink
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // em & strong
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // code
            if (token = this.tokenizer.codespan(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // br
            if (token = this.tokenizer.br(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // del (gfm)
            if (token = this.tokenizer.del(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // autolink
            if (token = this.tokenizer.autolink(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // url (gfm)
            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // text
            // prevent inlineText consuming extensions by clipping 'src' to extension start
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startInline) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startInline.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (token = this.tokenizer.inlineText(cutSrc)) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                    prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        return tokens;
    }
}

/**
 * Renderer
 */
class _Renderer {
    options;
    parser; // set by the parser
    constructor(options) {
        this.options = options || _defaults;
    }
    space(token) {
        return '';
    }
    code({ text, lang, escaped }) {
        const langString = (lang || '').match(/^\S*/)?.[0];
        const code = text.replace(/\n$/, '') + '\n';
        if (!langString) {
            return '<pre><code>'
                + (escaped ? code : escape$1(code, true))
                + '</code></pre>\n';
        }
        return '<pre><code class="language-'
            + escape$1(langString)
            + '">'
            + (escaped ? code : escape$1(code, true))
            + '</code></pre>\n';
    }
    blockquote({ tokens }) {
        const body = this.parser.parse(tokens);
        return `<blockquote>\n${body}</blockquote>\n`;
    }
    html({ text }) {
        return text;
    }
    heading({ tokens, depth }) {
        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\n`;
    }
    hr(token) {
        return '<hr>\n';
    }
    list(token) {
        const ordered = token.ordered;
        const start = token.start;
        let body = '';
        for (let j = 0; j < token.items.length; j++) {
            const item = token.items[j];
            body += this.listitem(item);
        }
        const type = ordered ? 'ol' : 'ul';
        const startAttr = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startAttr + '>\n' + body + '</' + type + '>\n';
    }
    listitem(item) {
        let itemBody = '';
        if (item.task) {
            const checkbox = this.checkbox({ checked: !!item.checked });
            if (item.loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                    }
                }
                else {
                    item.tokens.unshift({
                        type: 'text',
                        raw: checkbox + ' ',
                        text: checkbox + ' ',
                    });
                }
            }
            else {
                itemBody += checkbox + ' ';
            }
        }
        itemBody += this.parser.parse(item.tokens, !!item.loose);
        return `<li>${itemBody}</li>\n`;
    }
    checkbox({ checked }) {
        return '<input '
            + (checked ? 'checked="" ' : '')
            + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens }) {
        return `<p>${this.parser.parseInline(tokens)}</p>\n`;
    }
    table(token) {
        let header = '';
        // header
        let cell = '';
        for (let j = 0; j < token.header.length; j++) {
            cell += this.tablecell(token.header[j]);
        }
        header += this.tablerow({ text: cell });
        let body = '';
        for (let j = 0; j < token.rows.length; j++) {
            const row = token.rows[j];
            cell = '';
            for (let k = 0; k < row.length; k++) {
                cell += this.tablecell(row[k]);
            }
            body += this.tablerow({ text: cell });
        }
        if (body)
            body = `<tbody>${body}</tbody>`;
        return '<table>\n'
            + '<thead>\n'
            + header
            + '</thead>\n'
            + body
            + '</table>\n';
    }
    tablerow({ text }) {
        return `<tr>\n${text}</tr>\n`;
    }
    tablecell(token) {
        const content = this.parser.parseInline(token.tokens);
        const type = token.header ? 'th' : 'td';
        const tag = token.align
            ? `<${type} align="${token.align}">`
            : `<${type}>`;
        return tag + content + `</${type}>\n`;
    }
    /**
     * span level renderer
     */
    strong({ tokens }) {
        return `<strong>${this.parser.parseInline(tokens)}</strong>`;
    }
    em({ tokens }) {
        return `<em>${this.parser.parseInline(tokens)}</em>`;
    }
    codespan({ text }) {
        return `<code>${text}</code>`;
    }
    br(token) {
        return '<br>';
    }
    del({ tokens }) {
        return `<del>${this.parser.parseInline(tokens)}</del>`;
    }
    link({ href, title, tokens }) {
        const text = this.parser.parseInline(tokens);
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
            out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
    }
    image({ href, title, text }) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
            out += ` title="${title}"`;
        }
        out += '>';
        return out;
    }
    text(token) {
        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;
    }
}

/**
 * TextRenderer
 * returns only the textual part of the token
 */
class _TextRenderer {
    // no need for block level renderers
    strong({ text }) {
        return text;
    }
    em({ text }) {
        return text;
    }
    codespan({ text }) {
        return text;
    }
    del({ text }) {
        return text;
    }
    html({ text }) {
        return text;
    }
    text({ text }) {
        return text;
    }
    link({ text }) {
        return '' + text;
    }
    image({ text }) {
        return '' + text;
    }
    br() {
        return '';
    }
}

/**
 * Parsing & Compiling
 */
class _Parser {
    options;
    renderer;
    textRenderer;
    constructor(options) {
        this.options = options || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.renderer.parser = this;
        this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
                const genericToken = anyToken;
                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch (token.type) {
                case 'space': {
                    out += this.renderer.space(token);
                    continue;
                }
                case 'hr': {
                    out += this.renderer.hr(token);
                    continue;
                }
                case 'heading': {
                    out += this.renderer.heading(token);
                    continue;
                }
                case 'code': {
                    out += this.renderer.code(token);
                    continue;
                }
                case 'table': {
                    out += this.renderer.table(token);
                    continue;
                }
                case 'blockquote': {
                    out += this.renderer.blockquote(token);
                    continue;
                }
                case 'list': {
                    out += this.renderer.list(token);
                    continue;
                }
                case 'html': {
                    out += this.renderer.html(token);
                    continue;
                }
                case 'paragraph': {
                    out += this.renderer.paragraph(token);
                    continue;
                }
                case 'text': {
                    let textToken = token;
                    let body = this.renderer.text(textToken);
                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                        textToken = tokens[++i];
                        body += '\n' + this.renderer.text(textToken);
                    }
                    if (top) {
                        out += this.renderer.paragraph({
                            type: 'paragraph',
                            raw: body,
                            text: body,
                            tokens: [{ type: 'text', raw: body, text: body }],
                        });
                    }
                    else {
                        out += body;
                    }
                    continue;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {
                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            const token = anyToken;
            switch (token.type) {
                case 'escape': {
                    out += renderer.text(token);
                    break;
                }
                case 'html': {
                    out += renderer.html(token);
                    break;
                }
                case 'link': {
                    out += renderer.link(token);
                    break;
                }
                case 'image': {
                    out += renderer.image(token);
                    break;
                }
                case 'strong': {
                    out += renderer.strong(token);
                    break;
                }
                case 'em': {
                    out += renderer.em(token);
                    break;
                }
                case 'codespan': {
                    out += renderer.codespan(token);
                    break;
                }
                case 'br': {
                    out += renderer.br(token);
                    break;
                }
                case 'del': {
                    out += renderer.del(token);
                    break;
                }
                case 'text': {
                    out += renderer.text(token);
                    break;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
}

class _Hooks {
    options;
    constructor(options) {
        this.options = options || _defaults;
    }
    static passThroughHooks = new Set([
        'preprocess',
        'postprocess',
        'processAllTokens',
    ]);
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
        return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html) {
        return html;
    }
    /**
     * Process all tokens before walk tokens
     */
    processAllTokens(tokens) {
        return tokens;
    }
}

class Marked {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.parseMarkdown(_Lexer.lex, _Parser.parse);
    parseInline = this.parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
        this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
            values = values.concat(callback.call(this, token));
            switch (token.type) {
                case 'table': {
                    const tableToken = token;
                    for (const cell of tableToken.header) {
                        values = values.concat(this.walkTokens(cell.tokens, callback));
                    }
                    for (const row of tableToken.rows) {
                        for (const cell of row) {
                            values = values.concat(this.walkTokens(cell.tokens, callback));
                        }
                    }
                    break;
                }
                case 'list': {
                    const listToken = token;
                    values = values.concat(this.walkTokens(listToken.items, callback));
                    break;
                }
                default: {
                    const genericToken = token;
                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                            const tokens = genericToken[childTokens].flat(Infinity);
                            values = values.concat(this.walkTokens(tokens, callback));
                        });
                    }
                    else if (genericToken.tokens) {
                        values = values.concat(this.walkTokens(genericToken.tokens, callback));
                    }
                }
            }
        }
        return values;
    }
    use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
            // copy options to new object
            const opts = { ...pack };
            // set async to true if it was set to true before
            opts.async = this.defaults.async || opts.async || false;
            // ==-- Parse "addon" extensions --== //
            if (pack.extensions) {
                pack.extensions.forEach((ext) => {
                    if (!ext.name) {
                        throw new Error('extension name required');
                    }
                    if ('renderer' in ext) { // Renderer extensions
                        const prevRenderer = extensions.renderers[ext.name];
                        if (prevRenderer) {
                            // Replace extension with func to run new extension but fall back if false
                            extensions.renderers[ext.name] = function (...args) {
                                let ret = ext.renderer.apply(this, args);
                                if (ret === false) {
                                    ret = prevRenderer.apply(this, args);
                                }
                                return ret;
                            };
                        }
                        else {
                            extensions.renderers[ext.name] = ext.renderer;
                        }
                    }
                    if ('tokenizer' in ext) { // Tokenizer Extensions
                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                            throw new Error("extension level must be 'block' or 'inline'");
                        }
                        const extLevel = extensions[ext.level];
                        if (extLevel) {
                            extLevel.unshift(ext.tokenizer);
                        }
                        else {
                            extensions[ext.level] = [ext.tokenizer];
                        }
                        if (ext.start) { // Function to check for start of token
                            if (ext.level === 'block') {
                                if (extensions.startBlock) {
                                    extensions.startBlock.push(ext.start);
                                }
                                else {
                                    extensions.startBlock = [ext.start];
                                }
                            }
                            else if (ext.level === 'inline') {
                                if (extensions.startInline) {
                                    extensions.startInline.push(ext.start);
                                }
                                else {
                                    extensions.startInline = [ext.start];
                                }
                            }
                        }
                    }
                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                        extensions.childTokens[ext.name] = ext.childTokens;
                    }
                });
                opts.extensions = extensions;
            }
            // ==-- Parse "overwrite" extensions --== //
            if (pack.renderer) {
                const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                for (const prop in pack.renderer) {
                    if (!(prop in renderer)) {
                        throw new Error(`renderer '${prop}' does not exist`);
                    }
                    if (['options', 'parser'].includes(prop)) {
                        // ignore options property
                        continue;
                    }
                    const rendererProp = prop;
                    const rendererFunc = pack.renderer[rendererProp];
                    const prevRenderer = renderer[rendererProp];
                    // Replace renderer with func to run extension, but fall back if false
                    renderer[rendererProp] = (...args) => {
                        let ret = rendererFunc.apply(renderer, args);
                        if (ret === false) {
                            ret = prevRenderer.apply(renderer, args);
                        }
                        return ret || '';
                    };
                }
                opts.renderer = renderer;
            }
            if (pack.tokenizer) {
                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                for (const prop in pack.tokenizer) {
                    if (!(prop in tokenizer)) {
                        throw new Error(`tokenizer '${prop}' does not exist`);
                    }
                    if (['options', 'rules', 'lexer'].includes(prop)) {
                        // ignore options, rules, and lexer properties
                        continue;
                    }
                    const tokenizerProp = prop;
                    const tokenizerFunc = pack.tokenizer[tokenizerProp];
                    const prevTokenizer = tokenizer[tokenizerProp];
                    // Replace tokenizer with func to run extension, but fall back if false
                    // @ts-expect-error cannot type tokenizer function dynamically
                    tokenizer[tokenizerProp] = (...args) => {
                        let ret = tokenizerFunc.apply(tokenizer, args);
                        if (ret === false) {
                            ret = prevTokenizer.apply(tokenizer, args);
                        }
                        return ret;
                    };
                }
                opts.tokenizer = tokenizer;
            }
            // ==-- Parse Hooks extensions --== //
            if (pack.hooks) {
                const hooks = this.defaults.hooks || new _Hooks();
                for (const prop in pack.hooks) {
                    if (!(prop in hooks)) {
                        throw new Error(`hook '${prop}' does not exist`);
                    }
                    if (prop === 'options') {
                        // ignore options property
                        continue;
                    }
                    const hooksProp = prop;
                    const hooksFunc = pack.hooks[hooksProp];
                    const prevHook = hooks[hooksProp];
                    if (_Hooks.passThroughHooks.has(prop)) {
                        // @ts-expect-error cannot type hook function dynamically
                        hooks[hooksProp] = (arg) => {
                            if (this.defaults.async) {
                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                    return prevHook.call(hooks, ret);
                                });
                            }
                            const ret = hooksFunc.call(hooks, arg);
                            return prevHook.call(hooks, ret);
                        };
                    }
                    else {
                        // @ts-expect-error cannot type hook function dynamically
                        hooks[hooksProp] = (...args) => {
                            let ret = hooksFunc.apply(hooks, args);
                            if (ret === false) {
                                ret = prevHook.apply(hooks, args);
                            }
                            return ret;
                        };
                    }
                }
                opts.hooks = hooks;
            }
            // ==-- Parse WalkTokens extensions --== //
            if (pack.walkTokens) {
                const walkTokens = this.defaults.walkTokens;
                const packWalktokens = pack.walkTokens;
                opts.walkTokens = function (token) {
                    let values = [];
                    values.push(packWalktokens.call(this, token));
                    if (walkTokens) {
                        values = values.concat(walkTokens.call(this, token));
                    }
                    return values;
                };
            }
            this.defaults = { ...this.defaults, ...opts };
        });
        return this;
    }
    setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
    }
    lexer(src, options) {
        return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
        return _Parser.parse(tokens, options ?? this.defaults);
    }
    parseMarkdown(lexer, parser) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const parse = (src, options) => {
            const origOpt = { ...options };
            const opt = { ...this.defaults, ...origOpt };
            const throwError = this.onError(!!opt.silent, !!opt.async);
            // throw error if an extension set async to true but parse was called with async: false
            if (this.defaults.async === true && origOpt.async === false) {
                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));
            }
            // throw error in case of non string input
            if (typeof src === 'undefined' || src === null) {
                return throwError(new Error('marked(): input parameter is undefined or null'));
            }
            if (typeof src !== 'string') {
                return throwError(new Error('marked(): input parameter is of type '
                    + Object.prototype.toString.call(src) + ', string expected'));
            }
            if (opt.hooks) {
                opt.hooks.options = opt;
            }
            if (opt.async) {
                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                    .then(src => lexer(src, opt))
                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)
                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                    .then(tokens => parser(tokens, opt))
                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                    .catch(throwError);
            }
            try {
                if (opt.hooks) {
                    src = opt.hooks.preprocess(src);
                }
                let tokens = lexer(src, opt);
                if (opt.hooks) {
                    tokens = opt.hooks.processAllTokens(tokens);
                }
                if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                }
                let html = parser(tokens, opt);
                if (opt.hooks) {
                    html = opt.hooks.postprocess(html);
                }
                return html;
            }
            catch (e) {
                return throwError(e);
            }
        };
        return parse;
    }
    onError(silent, async) {
        return (e) => {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';
            if (silent) {
                const msg = '<p>An error occurred:</p><pre>'
                    + escape$1(e.message + '', true)
                    + '</pre>';
                if (async) {
                    return Promise.resolve(msg);
                }
                return msg;
            }
            if (async) {
                return Promise.reject(e);
            }
            throw e;
        };
    }
}

const markedInstance = new Marked();
function marked(src, opt) {
    return markedInstance.parse(src, opt);
}
/**
 * Sets the default options.
 *
 * @param options Hash of options
 */
marked.options =
    marked.setOptions = function (options) {
        markedInstance.setOptions(options);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
    };
/**
 * Gets the original marked default options.
 */
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
/**
 * Use Extension
 */
marked.use = function (...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
};
/**
 * Run callback for every token
 */
marked.walkTokens = function (tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
};
/**
 * Compiles markdown to HTML without enclosing `p` tag.
 *
 * @param src String of markdown source to be compiled
 * @param options Hash of options
 * @return String of compiled HTML
 */
marked.parseInline = markedInstance.parseInline;
/**
 * Expose
 */
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const walkTokens = marked.walkTokens;
const parseInline = marked.parseInline;
const parse = marked;
const parser = _Parser.parse;
const lexer = _Lexer.lex;

export { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/marked/marked.license.txt]---
Location: vscode-main/src/vs/base/common/marked/marked.license.txt

```text
Copyright (c) 2011-2014, Christopher Jeffrey (https://github.com/chjj/)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/naturalLanguage/korean.ts]---
Location: vscode-main/src/vs/base/common/naturalLanguage/korean.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// allow-any-unicode-comment-file

/**
 * Gets alternative Korean characters for the character code. This will return the ascii
 * character code(s) that a Hangul character may have been input with using a qwerty layout.
 *
 * This only aims to cover modern (not archaic) Hangul syllables.
 *
 * @param code The character code to get alternate characters for
 */
export function getKoreanAltChars(code: number): ArrayLike<number> | undefined {
	const result = disassembleKorean(code);
	if (result && result.length > 0) {
		return new Uint32Array(result);
	}
	return undefined;
}

let codeBufferLength = 0;
const codeBuffer = new Uint32Array(10);
function disassembleKorean(code: number): Uint32Array | undefined {
	codeBufferLength = 0;

	// Initial consonants (초성)
	getCodesFromArray(code, modernConsonants, HangulRangeStartCode.InitialConsonant);
	if (codeBufferLength > 0) {
		return codeBuffer.subarray(0, codeBufferLength);
	}

	// Vowels (중성)
	getCodesFromArray(code, modernVowels, HangulRangeStartCode.Vowel);
	if (codeBufferLength > 0) {
		return codeBuffer.subarray(0, codeBufferLength);
	}

	// Final consonants (종성)
	getCodesFromArray(code, modernFinalConsonants, HangulRangeStartCode.FinalConsonant);
	if (codeBufferLength > 0) {
		return codeBuffer.subarray(0, codeBufferLength);
	}

	// Hangul Compatibility Jamo
	getCodesFromArray(code, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
	if (codeBufferLength) {
		return codeBuffer.subarray(0, codeBufferLength);
	}

	// Hangul Syllables
	if (code >= 0xAC00 && code <= 0xD7A3) {
		const hangulIndex = code - 0xAC00;
		const vowelAndFinalConsonantProduct = hangulIndex % 588;

		// 0-based starting at 0x1100
		const initialConsonantIndex = Math.floor(hangulIndex / 588);
		// 0-based starting at 0x1161
		const vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);
		// 0-based starting at 0x11A8
		// Subtract 1 as the standard algorithm uses the 0 index to represent no
		// final consonant
		const finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;

		if (initialConsonantIndex < modernConsonants.length) {
			getCodesFromArray(initialConsonantIndex, modernConsonants, 0);
		} else if (HangulRangeStartCode.InitialConsonant + initialConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
			getCodesFromArray(HangulRangeStartCode.InitialConsonant + initialConsonantIndex, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
		}

		if (vowelIndex < modernVowels.length) {
			getCodesFromArray(vowelIndex, modernVowels, 0);
		} else if (HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
			getCodesFromArray(HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
		}

		if (finalConsonantIndex >= 0) {
			if (finalConsonantIndex < modernFinalConsonants.length) {
				getCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);
			} else if (HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
				getCodesFromArray(HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
			}
		}

		if (codeBufferLength > 0) {
			return codeBuffer.subarray(0, codeBufferLength);
		}
	}
	return undefined;
}

function getCodesFromArray(code: number, array: ArrayLike<number>, arrayStartIndex: number): void {
	// Verify the code is within the array's range
	if (code >= arrayStartIndex && code < arrayStartIndex + array.length) {
		addCodesToBuffer(array[code - arrayStartIndex]);
	}
}

function addCodesToBuffer(codes: number): void {
	// NUL is ignored, this is used for archaic characters to avoid using a Map
	// for the data
	if (codes === AsciiCode.NUL) {
		return;
	}
	// Number stored in format: OptionalThirdCode << 16 | OptionalSecondCode << 8 | Code
	codeBuffer[codeBufferLength++] = codes & 0xFF;
	if (codes >> 8) {
		codeBuffer[codeBufferLength++] = (codes >> 8) & 0xFF;
	}
	if (codes >> 16) {
		codeBuffer[codeBufferLength++] = (codes >> 16) & 0xFF;
	}
}

const enum HangulRangeStartCode {
	InitialConsonant = 0x1100,
	Vowel = 0x1161,
	FinalConsonant = 0x11A8,
	CompatibilityJamo = 0x3131,
}

const enum AsciiCode {
	NUL = 0,
	A = 65,
	B = 66,
	C = 67,
	D = 68,
	E = 69,
	F = 70,
	G = 71,
	H = 72,
	I = 73,
	J = 74,
	K = 75,
	L = 76,
	M = 77,
	N = 78,
	O = 79,
	P = 80,
	Q = 81,
	R = 82,
	S = 83,
	T = 84,
	U = 85,
	V = 86,
	W = 87,
	X = 88,
	Y = 89,
	Z = 90,
	a = 97,
	b = 98,
	c = 99,
	d = 100,
	e = 101,
	f = 102,
	g = 103,
	h = 104,
	i = 105,
	j = 106,
	k = 107,
	l = 108,
	m = 109,
	n = 110,
	o = 111,
	p = 112,
	q = 113,
	r = 114,
	s = 115,
	t = 116,
	u = 117,
	v = 118,
	w = 119,
	x = 120,
	y = 121,
	z = 122,
}

/**
 * Numbers that represent multiple ascii codes. These are precomputed at compile time to reduce
 * bundle and runtime overhead.
 */
const enum AsciiCodeCombo {
	fa = AsciiCode.a << 8 | AsciiCode.f,
	fg = AsciiCode.g << 8 | AsciiCode.f,
	fq = AsciiCode.q << 8 | AsciiCode.f,
	fr = AsciiCode.r << 8 | AsciiCode.f,
	ft = AsciiCode.t << 8 | AsciiCode.f,
	fv = AsciiCode.v << 8 | AsciiCode.f,
	fx = AsciiCode.x << 8 | AsciiCode.f,
	hk = AsciiCode.k << 8 | AsciiCode.h,
	hl = AsciiCode.l << 8 | AsciiCode.h,
	ho = AsciiCode.o << 8 | AsciiCode.h,
	ml = AsciiCode.l << 8 | AsciiCode.m,
	nj = AsciiCode.j << 8 | AsciiCode.n,
	nl = AsciiCode.l << 8 | AsciiCode.n,
	np = AsciiCode.p << 8 | AsciiCode.n,
	qt = AsciiCode.t << 8 | AsciiCode.q,
	rt = AsciiCode.t << 8 | AsciiCode.r,
	sg = AsciiCode.g << 8 | AsciiCode.s,
	sw = AsciiCode.w << 8 | AsciiCode.s,
}

/**
 * Hangul Jamo - Modern consonants #1
 *
 * Range U+1100..U+1112
 *
 * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
 * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
 * | U+110x | ᄀ | ᄁ | ᄂ | ᄃ | ᄄ | ᄅ | ᄆ | ᄇ | ᄈ | ᄉ | ᄊ | ᄋ | ᄌ | ᄍ | ᄎ | ᄏ |
 * | U+111x | ᄐ | ᄑ | ᄒ |
 */
const modernConsonants = new Uint8Array([
	AsciiCode.r, // ㄱ
	AsciiCode.R, // ㄲ
	AsciiCode.s, // ㄴ
	AsciiCode.e, // ㄷ
	AsciiCode.E, // ㄸ
	AsciiCode.f, // ㄹ
	AsciiCode.a, // ㅁ
	AsciiCode.q, // ㅂ
	AsciiCode.Q, // ㅃ
	AsciiCode.t, // ㅅ
	AsciiCode.T, // ㅆ
	AsciiCode.d, // ㅇ
	AsciiCode.w, // ㅈ
	AsciiCode.W, // ㅉ
	AsciiCode.c, // ㅊ
	AsciiCode.z, // ㅋ
	AsciiCode.x, // ㅌ
	AsciiCode.v, // ㅍ
	AsciiCode.g, // ㅎ
]);

/**
 * Hangul Jamo - Modern Vowels
 *
 * Range U+1161..U+1175
 *
 * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
 * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
 * | U+116x |   | ᅡ | ᅢ | ᅣ | ᅤ | ᅥ | ᅦ | ᅧ | ᅨ | ᅩ | ᅪ | ᅫ | ᅬ | ᅭ | ᅮ | ᅯ |
 * | U+117x | ᅰ | ᅱ | ᅲ | ᅳ | ᅴ | ᅵ |
 */
const modernVowels = new Uint16Array([
	AsciiCode.k,       //  -> ㅏ
	AsciiCode.o,       //  -> ㅐ
	AsciiCode.i,       //  -> ㅑ
	AsciiCode.O,       //  -> ㅒ
	AsciiCode.j,       //  -> ㅓ
	AsciiCode.p,       //  -> ㅔ
	AsciiCode.u,       //  -> ㅕ
	AsciiCode.P,       //  -> ㅖ
	AsciiCode.h,       //  -> ㅗ
	AsciiCodeCombo.hk, //  -> ㅘ
	AsciiCodeCombo.ho, //  -> ㅙ
	AsciiCodeCombo.hl, //  -> ㅚ
	AsciiCode.y,       //  -> ㅛ
	AsciiCode.n,       //  -> ㅜ
	AsciiCodeCombo.nj, //  -> ㅝ
	AsciiCodeCombo.np, //  -> ㅞ
	AsciiCodeCombo.nl, //  -> ㅟ
	AsciiCode.b,       //  -> ㅠ
	AsciiCode.m,       //  -> ㅡ
	AsciiCodeCombo.ml, //  -> ㅢ
	AsciiCode.l,       //  -> ㅣ
]);

/**
 * Hangul Jamo - Modern Consonants #2
 *
 * Range U+11A8..U+11C2
 *
 * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
 * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
 * | U+11Ax |   |   |   |   |   |   |   |   | ᆨ | ᆩ | ᆪ | ᆫ | ᆬ | ᆭ | ᆮ | ᆯ |
 * | U+11Bx | ᆰ | ᆱ | ᆲ | ᆳ | ᆴ | ᆵ | ᆶ | ᆷ | ᆸ | ᆹ | ᆺ | ᆻ | ᆼ | ᆽ | ᆾ | ᆿ |
 * | U+11Cx | ᇀ | ᇁ | ᇂ |
 */
const modernFinalConsonants = new Uint16Array([
	AsciiCode.r,       // ㄱ
	AsciiCode.R,       // ㄲ
	AsciiCodeCombo.rt, // ㄳ
	AsciiCode.s,       // ㄴ
	AsciiCodeCombo.sw, // ㄵ
	AsciiCodeCombo.sg, // ㄶ
	AsciiCode.e,       // ㄷ
	AsciiCode.f,       // ㄹ
	AsciiCodeCombo.fr, // ㄺ
	AsciiCodeCombo.fa, // ㄻ
	AsciiCodeCombo.fq, // ㄼ
	AsciiCodeCombo.ft, // ㄽ
	AsciiCodeCombo.fx, // ㄾ
	AsciiCodeCombo.fv, // ㄿ
	AsciiCodeCombo.fg, // ㅀ
	AsciiCode.a,       // ㅁ
	AsciiCode.q,       // ㅂ
	AsciiCodeCombo.qt, // ㅄ
	AsciiCode.t,       // ㅅ
	AsciiCode.T,       // ㅆ
	AsciiCode.d,       // ㅇ
	AsciiCode.w,       // ㅈ
	AsciiCode.c,       // ㅊ
	AsciiCode.z,       // ㅋ
	AsciiCode.x,       // ㅌ
	AsciiCode.v,       // ㅍ
	AsciiCode.g,       // ㅎ
]);

/**
 * Hangul Compatibility Jamo
 *
 * Range U+3131..U+318F
 *
 * This includes range includes archaic jamo which we don't consider, these are
 * given the NUL character code in order to be ignored.
 *
 * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
 * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
 * | U+313x |   | ㄱ | ㄲ | ㄳ | ㄴ | ㄵ | ㄶ | ㄷ | ㄸ | ㄹ | ㄺ | ㄻ | ㄼ | ㄽ | ㄾ | ㄿ |
 * | U+314x | ㅀ | ㅁ | ㅂ | ㅃ | ㅄ | ㅅ | ㅆ | ㅇ | ㅈ | ㅉ | ㅊ | ㅋ | ㅌ | ㅍ | ㅎ | ㅏ |
 * | U+315x | ㅐ | ㅑ | ㅒ | ㅓ | ㅔ | ㅕ | ㅖ | ㅗ | ㅘ | ㅙ | ㅚ | ㅛ | ㅜ | ㅝ | ㅞ | ㅟ |
 * | U+316x | ㅠ | ㅡ | ㅢ | ㅣ | HF | ㅥ | ㅦ | ㅧ | ㅨ | ㅩ | ㅪ | ㅫ | ㅬ | ㅭ | ㅮ | ㅯ |
 * | U+317x | ㅰ | ㅱ | ㅲ | ㅳ | ㅴ | ㅵ | ㅶ | ㅷ | ㅸ | ㅹ | ㅺ | ㅻ | ㅼ | ㅽ | ㅾ | ㅿ |
 * | U+318x | ㆀ | ㆁ | ㆂ | ㆃ | ㆄ | ㆅ | ㆆ | ㆇ | ㆈ | ㆉ | ㆊ | ㆋ | ㆌ | ㆍ | ㆎ |
 */
const compatibilityJamo = new Uint16Array([
	AsciiCode.r,        // ㄱ
	AsciiCode.R,        // ㄲ
	AsciiCodeCombo.rt,  // ㄳ
	AsciiCode.s,        // ㄴ
	AsciiCodeCombo.sw,  // ㄵ
	AsciiCodeCombo.sg,  // ㄶ
	AsciiCode.e,        // ㄷ
	AsciiCode.E,        // ㄸ
	AsciiCode.f,        // ㄹ
	AsciiCodeCombo.fr,  // ㄺ
	AsciiCodeCombo.fa,  // ㄻ
	AsciiCodeCombo.fq,  // ㄼ
	AsciiCodeCombo.ft,  // ㄽ
	AsciiCodeCombo.fx,  // ㄾ
	AsciiCodeCombo.fv,  // ㄿ
	AsciiCodeCombo.fg,  // ㅀ
	AsciiCode.a,        // ㅁ
	AsciiCode.q,        // ㅂ
	AsciiCode.Q,        // ㅃ
	AsciiCodeCombo.qt,  // ㅄ
	AsciiCode.t,        // ㅅ
	AsciiCode.T,        // ㅆ
	AsciiCode.d,        // ㅇ
	AsciiCode.w,        // ㅈ
	AsciiCode.W,        // ㅉ
	AsciiCode.c,        // ㅊ
	AsciiCode.z,        // ㅋ
	AsciiCode.x,        // ㅌ
	AsciiCode.v,        // ㅍ
	AsciiCode.g,        // ㅎ
	AsciiCode.k,        // ㅏ
	AsciiCode.o,        // ㅐ
	AsciiCode.i,        // ㅑ
	AsciiCode.O,        // ㅒ
	AsciiCode.j,        // ㅓ
	AsciiCode.p,        // ㅔ
	AsciiCode.u,        // ㅕ
	AsciiCode.P,        // ㅖ
	AsciiCode.h,        // ㅗ
	AsciiCodeCombo.hk,  // ㅘ
	AsciiCodeCombo.ho,  // ㅙ
	AsciiCodeCombo.hl,  // ㅚ
	AsciiCode.y,        // ㅛ
	AsciiCode.n,        // ㅜ
	AsciiCodeCombo.nj,  // ㅝ
	AsciiCodeCombo.np,  // ㅞ
	AsciiCodeCombo.nl,  // ㅟ
	AsciiCode.b,        // ㅠ
	AsciiCode.m,        // ㅡ
	AsciiCodeCombo.ml,  // ㅢ
	AsciiCode.l,        // ㅣ
	// HF: Hangul Filler (everything after this is archaic)
	// ㅥ
	// ㅦ
	// ㅧ
	// ㅨ
	// ㅩ
	// ㅪ
	// ㅫ
	// ㅬ
	// ㅮ
	// ㅯ
	// ㅰ
	// ㅱ
	// ㅲ
	// ㅳ
	// ㅴ
	// ㅵ
	// ㅶ
	// ㅷ
	// ㅸ
	// ㅹ
	// ㅺ
	// ㅻ
	// ㅼ
	// ㅽ
	// ㅾ
	// ㅿ
	// ㆀ
	// ㆁ
	// ㆂ
	// ㆃ
	// ㆄ
	// ㆅ
	// ㆆ
	// ㆇ
	// ㆈ
	// ㆉ
	// ㆊ
	// ㆋ
	// ㆌ
	// ㆍ
	// ㆎ
]);
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/base.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/base.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { DisposableStore, onUnexpectedError } from './commonFacade/deps.js';

/**
 * Represents an observable value.
 *
 * @template T The type of the values the observable can hold.
 */
// This interface exists so that, for example for string observables,
// typescript renders the type as `IObservable<string>` instead of `IObservable<string, unknown>`.
export interface IObservable<T> extends IObservableWithChange<T, unknown> { }

/**
 * Represents an observable value.
 *
 * @template T The type of the values the observable can hold.
 * @template TChange The type used to describe value changes
 * (usually `void` and only used in advanced scenarios).
 * While observers can miss temporary values of an observable,
 * they will receive all change values (as long as they are subscribed)!
 */
export interface IObservableWithChange<T, TChange = unknown> {
	/**
	 * Returns the current value.
	 *
	 * Calls {@link IObserver.handleChange} if the observable notices that the value changed.
	 * Must not be called from {@link IObserver.handleChange}!
	 */
	get(): T;

	/**
	 * Forces the observable to check for changes and report them.
	 *
	 * Has the same effect as calling {@link IObservable.get}, but does not force the observable
	 * to actually construct the value, e.g. if change deltas are used.
	 * Calls {@link IObserver.handleChange} if the observable notices that the value changed.
	 * Must not be called from {@link IObserver.handleChange}!
	 */
	reportChanges(): void;

	/**
	 * Adds the observer to the set of subscribed observers.
	 * This method is idempotent.
	 */
	addObserver(observer: IObserver): void;

	/**
	 * Removes the observer from the set of subscribed observers.
	 * This method is idempotent.
	 */
	removeObserver(observer: IObserver): void;

	// #region These members have a standard implementation and are only part of the interface for convenience.

	/**
	 * Reads the current value and subscribes the reader to this observable.
	 *
	 * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}
	 * (see {@link ConvenientObservable.read} for the implementation).
	 */
	read(reader: IReader | undefined): T;

	/**
	 * Makes sure this value is computed eagerly.
	 */
	recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;

	/**
	 * Makes sure this value is cached.
	 */
	keepObserved(store: DisposableStore): IObservable<T>;

	/**
	 * Creates a derived observable that depends on this observable.
	 * Use the reader to read other observables
	 * (see {@link ConvenientObservable.map} for the implementation).
	 */
	map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;
	map<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;

	flatten<TNew>(this: IObservable<IObservable<TNew>>): IObservable<TNew>;

	/**
	 * ONLY FOR DEBUGGING!
	 * Logs computations of this derived.
	*/
	log(): IObservableWithChange<T, TChange>;

	/**
	 * A human-readable name for debugging purposes.
	 */
	readonly debugName: string;

	/**
	 * This property captures the type of the change object. Do not use it at runtime!
	 */
	readonly TChange: TChange;

	// #endregion
}

/**
 * Represents an observer that can be subscribed to an observable.
 *
 * If an observer is subscribed to an observable and that observable didn't signal
 * a change through one of the observer methods, the observer can assume that the
 * observable didn't change.
 * If an observable reported a possible change, {@link IObservable.reportChanges} forces
 * the observable to report an actual change if there was one.
 */
export interface IObserver {
	/**
	 * Signals that the given observable might have changed and a transaction potentially modifying that observable started.
	 * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.
	 *
	 * Implementations must not get/read the value of other observables, as they might not have received this event yet!
	 * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.
	 */
	beginUpdate<T>(observable: IObservable<T>): void;

	/**
	 * Signals that the transaction that potentially modified the given observable ended.
	 * This is a good place to react to (potential) changes.
	 */
	endUpdate<T>(observable: IObservable<T>): void;

	/**
	 * Signals that the given observable might have changed.
	 * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.
	 *
	 * Implementations must not get/read the value of other observables, as they might not have received this event yet!
	 * The change should be processed lazily or in {@link IObserver.endUpdate}.
	 */
	handlePossibleChange<T>(observable: IObservable<T>): void;

	/**
	 * Signals that the given {@link observable} changed.
	 *
	 * Implementations must not get/read the value of other observables, as they might not have received this event yet!
	 * The change should be processed lazily or in {@link IObserver.endUpdate}.
	 *
	 * @param change Indicates how or why the value changed.
	 */
	handleChange<T, TChange>(observable: IObservableWithChange<T, TChange>, change: TChange): void;
}

export interface IReader {
	/**
	 * Reads the value of an observable and subscribes to it.
	 */
	readObservable<T>(observable: IObservableWithChange<T, any>): T;
}

export interface ISettable<T, TChange = void> {
	/**
	 * Sets the value of the observable.
	 * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).
	 *
	 * @param transaction When given, value changes are handled on demand or when the transaction ends.
	 * @param change Describes how or why the value changed.
	 */
	set(value: T, transaction: ITransaction | undefined, change: TChange): void;
}

export interface ITransaction {
	/**
	 * Calls {@link Observer.beginUpdate} immediately
	 * and {@link Observer.endUpdate} when the transaction ends.
	 */
	updateObserver(observer: IObserver, observable: IObservableWithChange<any, any>): void;
}

/**
 * This function is used to indicate that the caller recovered from an error that indicates a bug.
*/
export function handleBugIndicatingErrorRecovery(message: string) {
	const err = new Error('BugIndicatingErrorRecovery: ' + message);
	onUnexpectedError(err);
	console.error('recovered from an error that indicates a bug', err);
}

/**
 * A settable observable.
 */
export interface ISettableObservable<T, TChange = void> extends IObservableWithChange<T, TChange>, ISettable<T, TChange> {
}

export interface IReaderWithStore extends IReader {
	/**
	 * Items in this store get disposed just before the observable recomputes/reruns or when it becomes unobserved.
	*/
	get store(): DisposableStore;

	/**
	 * Items in this store get disposed just after the observable recomputes/reruns or when it becomes unobserved.
	 * This is important if the current run needs the undisposed result from the last run.
	 *
	 * Warning: Items in this store might still get disposed before dependents (that read the now disposed value in the past) are recomputed with the new (undisposed) value!
	 * A clean solution for this is ref counting.
	*/
	get delayedStore(): DisposableStore;
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/changeTracker.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/changeTracker.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { BugIndicatingError } from './commonFacade/deps.js';
import { IObservableWithChange, IReader } from './base.js';

export interface IChangeTracker<TChangeSummary> {
	createChangeSummary(previousChangeSummary: TChangeSummary | undefined): TChangeSummary;
	handleChange(ctx: IChangeContext, change: TChangeSummary): boolean;
	beforeUpdate?(reader: IReader, change: TChangeSummary): void;
}

export interface IChangeContext {
	readonly changedObservable: IObservableWithChange<any, any>;
	readonly change: unknown;

	/**
	 * Returns if the given observable caused the change.
	 */
	didChange<T, TChange>(observable: IObservableWithChange<T, TChange>): this is { change: TChange };
}

/**
 * Subscribes to and records changes and the last value of the given observables.
 * Don't use the key "changes", as it is reserved for the changes array!
*/
export function recordChanges<TObs extends Record<any, IObservableWithChange<any, any>>>(obs: TObs):
	IChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }
		& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {
	return {
		createChangeSummary: (_previousChangeSummary) => {
			// eslint-disable-next-line local/code-no-any-casts
			return {
				changes: [],
			} as any;
		},
		handleChange(ctx, changeSummary) {
			for (const key in obs) {
				if (ctx.didChange(obs[key])) {
					// eslint-disable-next-line local/code-no-any-casts
					(changeSummary.changes as any).push({ key, change: ctx.change });
				}
			}
			return true;
		},
		beforeUpdate(reader, changeSummary) {
			for (const key in obs) {
				if (key === 'changes') {
					throw new BugIndicatingError('property name "changes" is reserved for change tracking');
				}
				changeSummary[key] = obs[key].read(reader);
			}
		}
	};
}

/**
 * Subscribes to and records changes and the last value of the given observables.
 * Don't use the key "changes", as it is reserved for the changes array!
*/
export function recordChangesLazy<TObs extends Record<any, IObservableWithChange<any, any>>>(getObs: () => TObs):
	IChangeTracker<{ [TKey in keyof TObs]: ReturnType<TObs[TKey]['get']> }
		& { changes: readonly ({ [TKey in keyof TObs]: { key: TKey; change: TObs[TKey]['TChange'] } }[keyof TObs])[] }> {
	let obs: TObs | undefined = undefined;
	return {
		createChangeSummary: (_previousChangeSummary) => {
			// eslint-disable-next-line local/code-no-any-casts
			return {
				changes: [],
			} as any;
		},
		handleChange(ctx, changeSummary) {
			if (!obs) {
				obs = getObs();
			}
			for (const key in obs) {
				if (ctx.didChange(obs[key])) {
					// eslint-disable-next-line local/code-no-any-casts
					(changeSummary.changes as any).push({ key, change: ctx.change });
				}
			}
			return true;
		},
		beforeUpdate(reader, changeSummary) {
			if (!obs) {
				obs = getObs();
			}
			for (const key in obs) {
				if (key === 'changes') {
					throw new BugIndicatingError('property name "changes" is reserved for change tracking');
				}
				changeSummary[key] = obs[key].read(reader);
			}
		}
	};
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/debugLocation.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/debugLocation.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

export type DebugLocation = DebugLocationImpl | undefined;

export namespace DebugLocation {
	let enabled = false;

	export function enable(): void {
		enabled = true;
	}

	export function ofCaller(): DebugLocation {
		if (!enabled) {
			return undefined;
		}
		const Err = Error as ErrorConstructor & { stackTraceLimit: number };

		const l = Err.stackTraceLimit;
		Err.stackTraceLimit = 3;
		const stack = new Error().stack!;
		Err.stackTraceLimit = l;

		return DebugLocationImpl.fromStack(stack, 2);
	}
}

class DebugLocationImpl implements ILocation {
	public static fromStack(stack: string, parentIdx: number): DebugLocationImpl | undefined {
		const lines = stack.split('\n');
		const location = parseLine(lines[parentIdx + 1]);
		if (location) {
			return new DebugLocationImpl(
				location.fileName,
				location.line,
				location.column,
				location.id
			);
		} else {
			return undefined;
		}
	}

	constructor(
		public readonly fileName: string,
		public readonly line: number,
		public readonly column: number,
		public readonly id: string,
	) {
	}
}


export interface ILocation {
	fileName: string;
	line: number;
	column: number;
	id: string;
}

function parseLine(stackLine: string): ILocation | undefined {
	const match = stackLine.match(/\((.*):(\d+):(\d+)\)/);
	if (match) {
		return {
			fileName: match[1],
			line: parseInt(match[2]),
			column: parseInt(match[3]),
			id: stackLine,
		};
	}

	const match2 = stackLine.match(/at ([^\(\)]*):(\d+):(\d+)/);

	if (match2) {
		return {
			fileName: match2[1],
			line: parseInt(match2[2]),
			column: parseInt(match2[3]),
			id: stackLine,
		};
	}

	return undefined;
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/debugName.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/debugName.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

export interface IDebugNameData {
	/**
	 * The owner object of an observable.
	 * Used for debugging only, such as computing a name for the observable by iterating over the fields of the owner.
	 */
	readonly owner?: DebugOwner | undefined;

	/**
	 * A string or function that returns a string that represents the name of the observable.
	 * Used for debugging only.
	 */
	readonly debugName?: DebugNameSource | undefined;

	/**
	 * A function that points to the defining function of the object.
	 * Used for debugging only.
	 */
	readonly debugReferenceFn?: Function | undefined;
}

export class DebugNameData {
	constructor(
		public readonly owner: DebugOwner | undefined,
		public readonly debugNameSource: DebugNameSource | undefined,
		public readonly referenceFn: Function | undefined,
	) { }

	public getDebugName(target: object): string | undefined {
		return getDebugName(target, this);
	}
}

/**
 * The owning object of an observable.
 * Is only used for debugging purposes, such as computing a name for the observable by iterating over the fields of the owner.
 */
export type DebugOwner = object | undefined;
export type DebugNameSource = string | (() => string | undefined);

const countPerName = new Map<string, number>();
const cachedDebugName = new WeakMap<object, string>();

export function getDebugName(target: object, data: DebugNameData): string | undefined {
	const cached = cachedDebugName.get(target);
	if (cached) {
		return cached;
	}

	const dbgName = computeDebugName(target, data);
	if (dbgName) {
		let count = countPerName.get(dbgName) ?? 0;
		count++;
		countPerName.set(dbgName, count);
		const result = count === 1 ? dbgName : `${dbgName}#${count}`;
		cachedDebugName.set(target, result);
		return result;
	}
	return undefined;
}

function computeDebugName(self: object, data: DebugNameData): string | undefined {
	const cached = cachedDebugName.get(self);
	if (cached) {
		return cached;
	}

	const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';

	let result: string | undefined;
	const debugNameSource = data.debugNameSource;
	if (debugNameSource !== undefined) {
		if (typeof debugNameSource === 'function') {
			result = debugNameSource();
			if (result !== undefined) {
				return ownerStr + result;
			}
		} else {
			return ownerStr + debugNameSource;
		}
	}

	const referenceFn = data.referenceFn;
	if (referenceFn !== undefined) {
		result = getFunctionName(referenceFn);
		if (result !== undefined) {
			return ownerStr + result;
		}
	}

	if (data.owner !== undefined) {
		const key = findKey(data.owner, self);
		if (key !== undefined) {
			return ownerStr + key;
		}
	}
	return undefined;
}

function findKey(obj: object, value: object): string | undefined {
	for (const key in obj) {
		if ((obj as Record<string, unknown>)[key] === value) {
			return key;
		}
	}
	return undefined;
}

const countPerClassName = new Map<string, number>();
const ownerId = new WeakMap<object, string>();

function formatOwner(owner: object): string {
	const id = ownerId.get(owner);
	if (id) {
		return id;
	}
	const className = getClassName(owner) ?? 'Object';
	let count = countPerClassName.get(className) ?? 0;
	count++;
	countPerClassName.set(className, count);
	const result = count === 1 ? className : `${className}#${count}`;
	ownerId.set(owner, result);
	return result;
}

export function getClassName(obj: object): string | undefined {
	const ctor = obj.constructor;
	if (ctor) {
		if (ctor.name === 'Object') {
			return undefined;
		}
		return ctor.name;
	}
	return undefined;
}

export function getFunctionName(fn: Function): string | undefined {
	const fnSrc = fn.toString();
	// Pattern: /** @description ... */
	const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
	const match = regexp.exec(fnSrc);
	const result = match ? match[1] : undefined;
	return result?.trim();
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/index.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/index.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// This is a facade for the observable implementation. Only import from here!

export { observableValueOpts } from './observables/observableValueOpts.js';
export { autorun, autorunDelta, autorunHandleChanges, autorunOpts, autorunWithStore, autorunWithStoreHandleChanges, autorunIterableDelta, autorunSelfDisposable } from './reactions/autorun.js';
export { type IObservable, type IObservableWithChange, type IObserver, type IReader, type ISettable, type ISettableObservable, type ITransaction } from './base.js';
export { disposableObservableValue } from './observables/observableValue.js';
export { derived, derivedDisposable, derivedHandleChanges, derivedOpts, derivedWithSetter, derivedWithStore } from './observables/derived.js';
export { type IDerivedReader } from './observables/derivedImpl.js';
export { ObservableLazy, ObservableLazyPromise, ObservablePromise, PromiseResult, } from './utils/promise.js';
export { derivedWithCancellationToken, waitForState } from './utils/utilsCancellation.js';
export {
	debouncedObservable, debouncedObservable2, derivedObservableWithCache,
	derivedObservableWithWritableCache, keepObserved, mapObservableArrayCached, observableFromPromise,
	recomputeInitiallyAndOnChange,
	signalFromObservable, wasEventTriggeredRecently,
	isObservable,
} from './utils/utils.js';
export { type DebugOwner } from './debugName.js';
export { type IChangeContext, type IChangeTracker, recordChanges, recordChangesLazy } from './changeTracker.js';
export { constObservable } from './observables/constObservable.js';
export { type IObservableSignal, observableSignal } from './observables/observableSignal.js';
export { observableFromEventOpts } from './observables/observableFromEvent.js';
export { observableSignalFromEvent } from './observables/observableSignalFromEvent.js';
export { asyncTransaction, globalTransaction, subtransaction, transaction, TransactionImpl } from './transaction.js';
export { observableFromValueWithChangeEvent, ValueWithChangeEventFromObservable } from './utils/valueWithChangeEvent.js';
export { runOnChange, runOnChangeWithCancellationToken, runOnChangeWithStore, type RemoveUndefined } from './utils/runOnChange.js';
export { derivedConstOnceDefined, latestChangedValue } from './experimental/utils.js';
export { observableFromEvent } from './observables/observableFromEvent.js';
export { observableValue } from './observables/observableValue.js';

export { ObservableSet } from './set.js';
export { ObservableMap } from './map.js';
export { DebugLocation } from './debugLocation.js';

import { addLogger, setLogObservableFn } from './logging/logging.js';
import { ConsoleObservableLogger, logObservableToConsole } from './logging/consoleObservableLogger.js';
import { DevToolsLogger } from './logging/debugger/devToolsLogger.js';
import { env } from '../process.js';
import { _setDebugGetObservableGraph } from './observables/baseObservable.js';
import { debugGetObservableGraph } from './logging/debugGetDependencyGraph.js';

_setDebugGetObservableGraph(debugGetObservableGraph);
setLogObservableFn(logObservableToConsole);

// Remove "//" in the next line to enable logging
const enableLogging = false
	// || Boolean("true") // done "weirdly" so that a lint warning prevents you from pushing this
	;

if (enableLogging) {
	addLogger(new ConsoleObservableLogger());
}

if (env && env['VSCODE_DEV_DEBUG_OBSERVABLES']) {
	// To debug observables you also need the extension "ms-vscode.debug-value-editor"
	addLogger(DevToolsLogger.getInstance());
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/map.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/map.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IObservable, ITransaction } from '../observable.js';
import { observableValueOpts } from './observables/observableValueOpts.js';


export class ObservableMap<K, V> implements Map<K, V> {
	private readonly _data = new Map<K, V>();

	private readonly _obs = observableValueOpts({ equalsFn: () => false }, this);

	readonly observable: IObservable<Map<K, V>> = this._obs;

	get size(): number {
		return this._data.size;
	}

	has(key: K): boolean {
		return this._data.has(key);
	}

	get(key: K): V | undefined {
		return this._data.get(key);
	}

	set(key: K, value: V, tx?: ITransaction): this {
		const hadKey = this._data.has(key);
		const oldValue = this._data.get(key);
		if (!hadKey || oldValue !== value) {
			this._data.set(key, value);
			this._obs.set(this, tx);
		}
		return this;
	}

	delete(key: K, tx?: ITransaction): boolean {
		const result = this._data.delete(key);
		if (result) {
			this._obs.set(this, tx);
		}
		return result;
	}

	clear(tx?: ITransaction): void {
		if (this._data.size > 0) {
			this._data.clear();
			this._obs.set(this, tx);
		}
	}

	forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: unknown): void {
		this._data.forEach((value, key, _map) => {
			callbackfn.call(thisArg, value, key, this);
		});
	}

	*entries(): IterableIterator<[K, V]> {
		yield* this._data.entries();
	}

	*keys(): IterableIterator<K> {
		yield* this._data.keys();
	}

	*values(): IterableIterator<V> {
		yield* this._data.values();
	}

	[Symbol.iterator](): IterableIterator<[K, V]> {
		return this.entries();
	}

	get [Symbol.toStringTag](): string {
		return 'ObservableMap';
	}
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/set.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/set.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IObservable, ITransaction } from '../observable.js';
import { observableValueOpts } from './observables/observableValueOpts.js';

export class ObservableSet<T> implements Set<T> {

	private readonly _data = new Set<T>();

	private _obs = observableValueOpts({ equalsFn: () => false }, this);

	readonly observable: IObservable<Set<T>> = this._obs;

	get size(): number {
		return this._data.size;
	}

	has(value: T): boolean {
		return this._data.has(value);
	}

	add(value: T, tx?: ITransaction): this {
		const hadValue = this._data.has(value);
		if (!hadValue) {
			this._data.add(value);
			this._obs.set(this, tx);
		}
		return this;
	}

	delete(value: T, tx?: ITransaction): boolean {
		const result = this._data.delete(value);
		if (result) {
			this._obs.set(this, tx);
		}
		return result;
	}

	clear(tx?: ITransaction): void {
		if (this._data.size > 0) {
			this._data.clear();
			this._obs.set(this, tx);
		}
	}

	forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void {
		this._data.forEach((value, value2, _set) => {
			// eslint-disable-next-line local/code-no-any-casts
			callbackfn.call(thisArg, value, value2, this as any);
		});
	}

	*entries(): IterableIterator<[T, T]> {
		for (const value of this._data) {
			yield [value, value];
		}
	}

	*keys(): IterableIterator<T> {
		yield* this._data.keys();
	}

	*values(): IterableIterator<T> {
		yield* this._data.values();
	}

	[Symbol.iterator](): IterableIterator<T> {
		return this.values();
	}

	get [Symbol.toStringTag](): string {
		return 'ObservableSet';
	}
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/transaction.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/transaction.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { handleBugIndicatingErrorRecovery, IObservable, IObserver, ITransaction } from './base.js';
import { getFunctionName } from './debugName.js';
import { getLogger } from './logging/logging.js';

/**
 * Starts a transaction in which many observables can be changed at once.
 * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.
 * Reaction run on demand or when the transaction ends.
 */

export function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {
	const tx = new TransactionImpl(fn, getDebugName);
	try {
		fn(tx);
	} finally {
		tx.finish();
	}
}
let _globalTransaction: ITransaction | undefined = undefined;

export function globalTransaction(fn: (tx: ITransaction) => void) {
	if (_globalTransaction) {
		fn(_globalTransaction);
	} else {
		const tx = new TransactionImpl(fn, undefined);
		_globalTransaction = tx;
		try {
			fn(tx);
		} finally {
			tx.finish(); // During finish, more actions might be added to the transaction.

			// Which is why we only clear the global transaction after finish.
			_globalTransaction = undefined;
		}
	}
}
/** @deprecated */

export async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {
	const tx = new TransactionImpl(fn, getDebugName);
	try {
		await fn(tx);
	} finally {
		tx.finish();
	}
}
/**
 * Allows to chain transactions.
 */

export function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {
	if (!tx) {
		transaction(fn, getDebugName);
	} else {
		fn(tx);
	}
} export class TransactionImpl implements ITransaction {
	private _updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];

	constructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {
		getLogger()?.handleBeginTransaction(this);
	}

	public getDebugName(): string | undefined {
		if (this._getDebugName) {
			return this._getDebugName();
		}
		return getFunctionName(this._fn);
	}

	public updateObserver(observer: IObserver, observable: IObservable<any>): void {
		if (!this._updatingObservers) {
			// This happens when a transaction is used in a callback or async function.
			// If an async transaction is used, make sure the promise awaits all users of the transaction (e.g. no race).
			handleBugIndicatingErrorRecovery('Transaction already finished!');
			// Error recovery
			transaction(tx => {
				tx.updateObserver(observer, observable);
			});
			return;
		}

		// When this gets called while finish is active, they will still get considered
		this._updatingObservers.push({ observer, observable });
		observer.beginUpdate(observable);
	}

	public finish(): void {
		const updatingObservers = this._updatingObservers;
		if (!updatingObservers) {
			handleBugIndicatingErrorRecovery('transaction.finish() has already been called!');
			return;
		}

		for (let i = 0; i < updatingObservers.length; i++) {
			const { observer, observable } = updatingObservers[i];
			observer.endUpdate(observable);
		}
		// Prevent anyone from updating observers from now on.
		this._updatingObservers = null;
		getLogger()?.handleEndTransaction(this);
	}

	public debugGetUpdatingObservers() {
		return this._updatingObservers;
	}
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/commonFacade/cancellation.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/commonFacade/cancellation.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

export { CancellationError } from '../../errors.js';
export { CancellationToken, CancellationTokenSource, cancelOnDispose } from '../../cancellation.js';
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/commonFacade/deps.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/commonFacade/deps.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

export { assertFn } from '../../assert.js';
export { type EqualityComparer, strictEquals } from '../../equals.js';
export { BugIndicatingError, onBugIndicatingError, onUnexpectedError } from '../../errors.js';
export { Event, type IValueWithChangeEvent } from '../../event.js';
export { DisposableStore, type IDisposable, markAsDisposed, toDisposable, trackDisposable } from '../../lifecycle.js';
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/experimental/reducer.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/experimental/reducer.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { EqualityComparer, strictEquals, BugIndicatingError } from '../commonFacade/deps.js';
import { IObservable, IObservableWithChange, ISettableObservable } from '../base.js';
import { subtransaction } from '../transaction.js';
import { IChangeTracker } from '../changeTracker.js';
import { DebugNameData, DebugOwner } from '../debugName.js';
import { DerivedWithSetter, IDerivedReader } from '../observables/derivedImpl.js';
import { DebugLocation } from '../debugLocation.js';

export interface IReducerOptions<T, TChangeSummary = void, TOutChange = void> {
	/**
	 * Is called to create the initial value of the observable when it becomes observed.
	*/
	initial: T | (() => T);

	/**
	 * Is called to dispose the observable value when it is no longer observed.
	*/
	disposeFinal?(value: T): void;
	changeTracker?: IChangeTracker<TChangeSummary>;
	equalityComparer?: EqualityComparer<T>;

	/**
	 * Applies the changes to the value.
	 * Use `reader.reportChange` to report change details or to report a change if the same value is returned.
	*/
	update(reader: IDerivedReader<TOutChange>, previousValue: T, changes: TChangeSummary): T;
}

/**
 * Creates an observable value that is based on values and changes from other observables.
 * Additionally, a reducer can report how that state changed.
*/
export function observableReducer<T, TInChanges, TOutChange = void>(owner: DebugOwner, options: IReducerOptions<T, TInChanges, TOutChange>): SimplifyObservableWithChange<T, TOutChange> {
	// eslint-disable-next-line local/code-no-any-casts
	return observableReducerSettable<T, TInChanges, TOutChange>(owner, options) as any;
}

/**
 * Creates an observable value that is based on values and changes from other observables.
 * Additionally, a reducer can report how that state changed.
*/
export function observableReducerSettable<T, TInChanges, TOutChange = void>(owner: DebugOwner, options: IReducerOptions<T, TInChanges, TOutChange>): ISettableObservable<T, TOutChange> {
	let prevValue: T | undefined = undefined;
	let hasValue = false;

	const d = new DerivedWithSetter(
		new DebugNameData(owner, undefined, options.update),
		(reader: IDerivedReader<TOutChange>, changeSummary) => {
			if (!hasValue) {
				prevValue = options.initial instanceof Function ? options.initial() : options.initial;
				hasValue = true;
			}
			const newValue = options.update(reader, prevValue!, changeSummary);
			prevValue = newValue;
			return newValue;
		},
		options.changeTracker,
		() => {
			if (hasValue) {
				options.disposeFinal?.(prevValue!);
				hasValue = false;
			}
		},
		options.equalityComparer ?? strictEquals,
		(value, tx, change) => {
			if (!hasValue) {
				throw new BugIndicatingError('Can only set when there is a listener! This is to prevent leaks.');
			}
			subtransaction(tx, tx => {
				prevValue = value;
				d.setValue(value, tx, change);
			});
		},
		DebugLocation.ofCaller()
	);

	return d;
}

/**
 * Returns IObservable<T> if TChange is void, otherwise IObservableWithChange<T, TChange>
*/
type SimplifyObservableWithChange<T, TChange> = TChange extends void ? IObservable<T> : IObservableWithChange<T, TChange>;
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/experimental/time.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/experimental/time.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { Disposable } from '../../lifecycle.js';
import { IObservable } from '../base.js';
import { DisposableStore, IDisposable, toDisposable } from '../commonFacade/deps.js';
import { observableValue } from '../observables/observableValue.js';
import { autorun } from '../reactions/autorun.js';

/** Measures the total time an observable had the value "true". */
export class TotalTrueTimeObservable extends Disposable {
	private _totalTime = 0;
	private _startTime: number | undefined = undefined;

	constructor(
		private readonly value: IObservable<boolean>,
	) {
		super();
		this._register(autorun(reader => {
			const isTrue = this.value.read(reader);
			if (isTrue) {
				this._startTime = Date.now();
			} else {
				if (this._startTime !== undefined) {
					const delta = Date.now() - this._startTime;
					this._totalTime += delta;
					this._startTime = undefined;
				}
			}
		}));
	}

	/**
	 * Reports the total time the observable has been true in milliseconds.
	 * E.g. `true` for 100ms, then `false` for 50ms, then `true` for 200ms results in 300ms.
	*/
	public totalTimeMs(): number {
		if (this._startTime !== undefined) {
			return this._totalTime + (Date.now() - this._startTime);
		}
		return this._totalTime;
	}

	/**
	 * Runs the callback when the total time the observable has been true increased by the given delta in milliseconds.
	*/
	public fireWhenTimeIncreasedBy(deltaTimeMs: number, callback: () => void): IDisposable {
		const store = new DisposableStore();
		let accumulatedTime = 0;
		let startTime: number | undefined = undefined;

		store.add(autorun(reader => {
			const isTrue = this.value.read(reader);

			if (isTrue) {
				startTime = Date.now();
				const remainingTime = deltaTimeMs - accumulatedTime;

				if (remainingTime <= 0) {
					callback();
					store.dispose();
					return;
				}

				const handle = setTimeout(() => {
					accumulatedTime += (Date.now() - startTime!);
					startTime = undefined;
					callback();
					store.dispose();
				}, remainingTime);

				reader.store.add(toDisposable(() => {
					clearTimeout(handle);
					if (startTime !== undefined) {
						accumulatedTime += (Date.now() - startTime);
						startTime = undefined;
					}
				}));
			}
		}));

		return store;
	}
}

/**
 * Returns an observable that is true when the input observable was true within the last `timeMs` milliseconds.
 */
export function wasTrueRecently(obs: IObservable<boolean>, timeMs: number, store: DisposableStore): IObservable<boolean> {
	const result = observableValue('wasTrueRecently', false);
	let timeout: ReturnType<typeof setTimeout> | undefined;

	store.add(autorun(reader => {
		const value = obs.read(reader);
		if (value) {
			result.set(true, undefined);
			if (timeout !== undefined) {
				clearTimeout(timeout);
				timeout = undefined;
			}
		} else {
			timeout = setTimeout(() => {
				result.set(false, undefined);
				timeout = undefined;
			}, timeMs);
		}
	}));

	store.add(toDisposable(() => {
		if (timeout !== undefined) {
			clearTimeout(timeout);
		}
	}));

	return result;
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/experimental/utils.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/experimental/utils.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IObservable, IReader } from '../base.js';
import { BugIndicatingError, DisposableStore } from '../commonFacade/deps.js';
import { DebugOwner, getDebugName, DebugNameData } from '../debugName.js';
import { observableFromEvent } from '../observables/observableFromEvent.js';
import { autorunOpts } from '../reactions/autorun.js';
import { derivedObservableWithCache } from '../utils/utils.js';

/**
 * Creates an observable that has the latest changed value of the given observables.
 * Initially (and when not observed), it has the value of the last observable.
 * When observed and any of the observables change, it has the value of the last changed observable.
 * If multiple observables change in the same transaction, the last observable wins.
*/
export function latestChangedValue<T extends IObservable<any>[]>(owner: DebugOwner, observables: T): IObservable<ReturnType<T[number]['get']>> {
	if (observables.length === 0) {
		throw new BugIndicatingError();
	}

	let hasLastChangedValue = false;
	let lastChangedValue: unknown = undefined;

	const result = observableFromEvent<any, void>(owner, cb => {
		const store = new DisposableStore();
		for (const o of observables) {
			store.add(autorunOpts({ debugName: () => getDebugName(result, new DebugNameData(owner, undefined, undefined)) + '.updateLastChangedValue' }, reader => {
				hasLastChangedValue = true;
				lastChangedValue = o.read(reader);
				cb();
			}));
		}
		store.add({
			dispose() {
				hasLastChangedValue = false;
				lastChangedValue = undefined;
			},
		});
		return store;
	}, () => {
		if (hasLastChangedValue) {
			return lastChangedValue;
		} else {
			return observables[observables.length - 1].get();
		}
	});
	return result;
}

/**
 * Works like a derived.
 * However, if the value is not undefined, it is cached and will not be recomputed anymore.
 * In that case, the derived will unsubscribe from its dependencies.
*/
export function derivedConstOnceDefined<T>(owner: DebugOwner, fn: (reader: IReader) => T): IObservable<T | undefined> {
	return derivedObservableWithCache<T | undefined>(owner, (reader, lastValue) => lastValue ?? fn(reader));
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/consoleObservableLogger.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/consoleObservableLogger.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IObservable } from '../base.js';
import { TransactionImpl } from '../transaction.js';
import { IObservableLogger, IChangeInformation, addLogger } from './logging.js';
import { FromEventObservable } from '../observables/observableFromEvent.js';
import { getClassName } from '../debugName.js';
import { Derived } from '../observables/derivedImpl.js';
import { AutorunObserver } from '../reactions/autorunImpl.js';

let consoleObservableLogger: ConsoleObservableLogger | undefined;

export function logObservableToConsole(obs: IObservable<any>): void {
	if (!consoleObservableLogger) {
		consoleObservableLogger = new ConsoleObservableLogger();
		addLogger(consoleObservableLogger);
	}
	consoleObservableLogger.addFilteredObj(obs);
}

export class ConsoleObservableLogger implements IObservableLogger {
	private indentation = 0;

	private _filteredObjects: Set<unknown> | undefined;

	public addFilteredObj(obj: unknown): void {
		if (!this._filteredObjects) {
			this._filteredObjects = new Set();
		}
		this._filteredObjects.add(obj);
	}

	private _isIncluded(obj: unknown): boolean {
		return this._filteredObjects?.has(obj) ?? true;
	}

	private textToConsoleArgs(text: ConsoleText): unknown[] {
		return consoleTextToArgs([
			normalText(repeat('|  ', this.indentation)),
			text,
		]);
	}

	private formatInfo(info: IChangeInformation): ConsoleText[] {
		if (!info.hadValue) {
			return [
				normalText(` `),
				styled(formatValue(info.newValue, 60), {
					color: 'green',
				}),
				normalText(` (initial)`),
			];
		}
		return info.didChange
			? [
				normalText(` `),
				styled(formatValue(info.oldValue, 70), {
					color: 'red',
					strikeThrough: true,
				}),
				normalText(` `),
				styled(formatValue(info.newValue, 60), {
					color: 'green',
				}),
			]
			: [normalText(` (unchanged)`)];
	}

	handleObservableCreated(observable: IObservable<any>): void {
		if (observable instanceof Derived) {
			const derived = observable;
			this.changedObservablesSets.set(derived, new Set());

			const debugTrackUpdating = false;
			if (debugTrackUpdating) {
				const updating: IObservable<any>[] = [];
				// eslint-disable-next-line local/code-no-any-casts
				(derived as any).__debugUpdating = updating;

				const existingBeginUpdate = derived.beginUpdate;
				derived.beginUpdate = (obs) => {
					updating.push(obs);
					return existingBeginUpdate.apply(derived, [obs]);
				};

				const existingEndUpdate = derived.endUpdate;
				derived.endUpdate = (obs) => {
					const idx = updating.indexOf(obs);
					if (idx === -1) {
						console.error('endUpdate called without beginUpdate', derived.debugName, obs.debugName);
					}
					updating.splice(idx, 1);
					return existingEndUpdate.apply(derived, [obs]);
				};
			}
		}
	}

	handleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {
	}

	handleObservableUpdated(observable: IObservable<unknown>, info: IChangeInformation): void {
		if (!this._isIncluded(observable)) { return; }
		if (observable instanceof Derived) {
			this._handleDerivedRecomputed(observable, info);
			return;
		}

		console.log(...this.textToConsoleArgs([
			formatKind('observable value changed'),
			styled(observable.debugName, { color: 'BlueViolet' }),
			...this.formatInfo(info),
		]));
	}

	private readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any>>>();

	formatChanges(changes: Set<IObservable<any>>): ConsoleText | undefined {
		if (changes.size === 0) {
			return undefined;
		}
		return styled(
			' (changed deps: ' +
			[...changes].map((o) => o.debugName).join(', ') +
			')',
			{ color: 'gray' }
		);
	}

	handleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {
		if (!this._isIncluded(derived)) { return; }

		this.changedObservablesSets.get(derived)?.add(observable);
	}

	_handleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {
		if (!this._isIncluded(derived)) { return; }

		const changedObservables = this.changedObservablesSets.get(derived);
		if (!changedObservables) { return; }
		console.log(...this.textToConsoleArgs([
			formatKind('derived recomputed'),
			styled(derived.debugName, { color: 'BlueViolet' }),
			...this.formatInfo(info),
			this.formatChanges(changedObservables),
			{ data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }
		]));
		changedObservables.clear();
	}

	handleDerivedCleared(derived: Derived<unknown>): void {
		if (!this._isIncluded(derived)) { return; }

		console.log(...this.textToConsoleArgs([
			formatKind('derived cleared'),
			styled(derived.debugName, { color: 'BlueViolet' }),
		]));
	}

	handleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void {
		if (!this._isIncluded(observable)) { return; }

		console.log(...this.textToConsoleArgs([
			formatKind('observable from event triggered'),
			styled(observable.debugName, { color: 'BlueViolet' }),
			...this.formatInfo(info),
			{ data: [{ fn: observable._getValue }] }
		]));
	}

	handleAutorunCreated(autorun: AutorunObserver): void {
		if (!this._isIncluded(autorun)) { return; }

		this.changedObservablesSets.set(autorun, new Set());
	}

	handleAutorunDisposed(autorun: AutorunObserver): void {
	}

	handleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {
		if (!this._isIncluded(autorun)) { return; }

		this.changedObservablesSets.get(autorun)!.add(observable);
	}

	handleAutorunStarted(autorun: AutorunObserver): void {
		const changedObservables = this.changedObservablesSets.get(autorun);
		if (!changedObservables) { return; }

		if (this._isIncluded(autorun)) {
			console.log(...this.textToConsoleArgs([
				formatKind('autorun'),
				styled(autorun.debugName, { color: 'BlueViolet' }),
				this.formatChanges(changedObservables),
				{ data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }
			]));
		}
		changedObservables.clear();
		this.indentation++;
	}

	handleAutorunFinished(autorun: AutorunObserver): void {
		this.indentation--;
	}

	handleBeginTransaction(transaction: TransactionImpl): void {
		let transactionName = transaction.getDebugName();
		if (transactionName === undefined) {
			transactionName = '';
		}
		if (this._isIncluded(transaction)) {
			console.log(...this.textToConsoleArgs([
				formatKind('transaction'),
				styled(transactionName, { color: 'BlueViolet' }),
				{ data: [{ fn: transaction._fn }] }
			]));
		}
		this.indentation++;
	}

	handleEndTransaction(): void {
		this.indentation--;
	}
}
type ConsoleText = (ConsoleText | undefined)[] |
{ text: string; style: string; data?: unknown[] } |
{ data: unknown[] };
function consoleTextToArgs(text: ConsoleText): unknown[] {
	const styles = new Array<any>();
	const data: unknown[] = [];
	let firstArg = '';

	function process(t: ConsoleText): void {
		if ('length' in t) {
			for (const item of t) {
				if (item) {
					process(item);
				}
			}
		} else if ('text' in t) {
			firstArg += `%c${t.text}`;
			styles.push(t.style);
			if (t.data) {
				data.push(...t.data);
			}
		} else if ('data' in t) {
			data.push(...t.data);
		}
	}

	process(text);

	const result = [firstArg, ...styles];
	result.push(...data);
	return result;
}
function normalText(text: string): ConsoleText {
	return styled(text, { color: 'black' });
}
function formatKind(kind: string): ConsoleText {
	return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });
}
function styled(
	text: string,
	options: { color: string; strikeThrough?: boolean; bold?: boolean } = {
		color: 'black',
	}
): ConsoleText {
	function objToCss(styleObj: Record<string, string>): string {
		return Object.entries(styleObj).reduce(
			(styleString, [propName, propValue]) => {
				return `${styleString}${propName}:${propValue};`;
			},
			''
		);
	}

	const style: Record<string, string> = {
		color: options.color,
	};
	if (options.strikeThrough) {
		style['text-decoration'] = 'line-through';
	}
	if (options.bold) {
		style['font-weight'] = 'bold';
	}

	return {
		text,
		style: objToCss(style),
	};
}

export function formatValue(value: unknown, availableLen: number): string {
	switch (typeof value) {
		case 'number':
			return '' + value;
		case 'string':
			if (value.length + 2 <= availableLen) {
				return `"${value}"`;
			}
			return `"${value.substr(0, availableLen - 7)}"+...`;

		case 'boolean':
			return value ? 'true' : 'false';
		case 'undefined':
			return 'undefined';
		case 'object':
			if (value === null) {
				return 'null';
			}
			if (Array.isArray(value)) {
				return formatArray(value, availableLen);
			}
			return formatObject(value, availableLen);
		case 'symbol':
			return value.toString();
		case 'function':
			return `[[Function${value.name ? ' ' + value.name : ''}]]`;
		default:
			return '' + value;
	}
}

function formatArray(value: unknown[], availableLen: number): string {
	let result = '[ ';
	let first = true;
	for (const val of value) {
		if (!first) {
			result += ', ';
		}
		if (result.length - 5 > availableLen) {
			result += '...';
			break;
		}
		first = false;
		result += `${formatValue(val, availableLen - result.length)}`;
	}
	result += ' ]';
	return result;
}

function formatObject(value: object, availableLen: number): string {
	if (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) {
		const val = value.toString();
		if (val.length <= availableLen) {
			return val;
		}
		return val.substring(0, availableLen - 3) + '...';
	}

	const className = getClassName(value);

	let result = className ? className + '(' : '{ ';
	let first = true;
	for (const [key, val] of Object.entries(value)) {
		if (!first) {
			result += ', ';
		}
		if (result.length - 5 > availableLen) {
			result += '...';
			break;
		}
		first = false;
		result += `${key}: ${formatValue(val, availableLen - result.length)}`;
	}
	result += className ? ')' : ' }';
	return result;
}

function repeat(str: string, count: number): string {
	let result = '';
	for (let i = 1; i <= count; i++) {
		result += str;
	}
	return result;
}

function padStr(str: string, length: number): string {
	while (str.length < length) {
		str += ' ';
	}
	return str;
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/debugGetDependencyGraph.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/debugGetDependencyGraph.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { IObservable, IObserver } from '../base.js';
import { Derived } from '../observables/derivedImpl.js';
import { FromEventObservable } from '../observables/observableFromEvent.js';
import { ObservableValue } from '../observables/observableValue.js';
import { AutorunObserver } from '../reactions/autorunImpl.js';
import { formatValue } from './consoleObservableLogger.js';

interface IOptions {
	type: 'dependencies' | 'observers';
	debugNamePostProcessor?: (name: string) => string;
}

export function debugGetObservableGraph(obs: IObservable<any> | IObserver, options: IOptions): string {
	const debugNamePostProcessor = options?.debugNamePostProcessor ?? ((str: string) => str);
	const info = Info.from(obs, debugNamePostProcessor);
	if (!info) {
		return '';
	}

	const alreadyListed = new Set<IObservable<any> | IObserver>();

	if (options.type === 'observers') {
		return formatObservableInfoWithObservers(info, 0, alreadyListed, options).trim();
	} else {
		return formatObservableInfoWithDependencies(info, 0, alreadyListed, options).trim();
	}
}

function formatObservableInfoWithDependencies(info: Info, indentLevel: number, alreadyListed: Set<IObservable<any> | IObserver>, options: IOptions): string {
	const indent = '\t\t'.repeat(indentLevel);
	const lines: string[] = [];

	const isAlreadyListed = alreadyListed.has(info.sourceObj);
	if (isAlreadyListed) {
		lines.push(`${indent}* ${info.type} ${info.name} (already listed)`);
		return lines.join('\n');
	}

	alreadyListed.add(info.sourceObj);

	lines.push(`${indent}* ${info.type} ${info.name}:`);
	lines.push(`${indent}  value: ${formatValue(info.value, 50)}`);
	lines.push(`${indent}  state: ${info.state}`);

	if (info.dependencies.length > 0) {
		lines.push(`${indent}  dependencies:`);
		for (const dep of info.dependencies) {
			const info = Info.from(dep, options.debugNamePostProcessor ?? (name => name)) ?? Info.unknown(dep);
			lines.push(formatObservableInfoWithDependencies(info, indentLevel + 1, alreadyListed, options));
		}
	}

	return lines.join('\n');
}

function formatObservableInfoWithObservers(info: Info, indentLevel: number, alreadyListed: Set<IObservable<any> | IObserver>, options: IOptions): string {
	const indent = '\t\t'.repeat(indentLevel);
	const lines: string[] = [];

	const isAlreadyListed = alreadyListed.has(info.sourceObj);
	if (isAlreadyListed) {
		lines.push(`${indent}* ${info.type} ${info.name} (already listed)`);
		return lines.join('\n');
	}

	alreadyListed.add(info.sourceObj);

	lines.push(`${indent}* ${info.type} ${info.name}:`);
	lines.push(`${indent}  value: ${formatValue(info.value, 50)}`);
	lines.push(`${indent}  state: ${info.state}`);

	if (info.observers.length > 0) {
		lines.push(`${indent}  observers:`);
		for (const observer of info.observers) {
			const info = Info.from(observer, options.debugNamePostProcessor ?? (name => name)) ?? Info.unknown(observer);
			lines.push(formatObservableInfoWithObservers(info, indentLevel + 1, alreadyListed, options));
		}
	}

	return lines.join('\n');
}

class Info {
	public static from(obs: IObservable<any> | IObserver, debugNamePostProcessor: (name: string) => string): Info | undefined {
		if (obs instanceof AutorunObserver) {
			const state = obs.debugGetState();
			return new Info(
				obs,
				debugNamePostProcessor(obs.debugName),
				'autorun',
				undefined,
				state.stateStr,
				Array.from(state.dependencies),
				[]
			);
		} else if (obs instanceof Derived) {
			const state = obs.debugGetState();
			return new Info(
				obs,
				debugNamePostProcessor(obs.debugName),
				'derived',
				state.value,
				state.stateStr,
				Array.from(state.dependencies),
				Array.from(obs.debugGetObservers())
			);
		} else if (obs instanceof ObservableValue) {
			const state = obs.debugGetState();
			return new Info(
				obs,
				debugNamePostProcessor(obs.debugName),
				'observableValue',
				state.value,
				'upToDate',
				[],
				Array.from(obs.debugGetObservers())
			);
		} else if (obs instanceof FromEventObservable) {
			const state = obs.debugGetState();
			return new Info(
				obs,
				debugNamePostProcessor(obs.debugName),
				'fromEvent',
				state.value,
				state.hasValue ? 'upToDate' : 'initial',
				[],
				Array.from(obs.debugGetObservers())
			);
		}
		return undefined;
	}

	public static unknown(obs: IObservable<any> | IObserver): Info {
		return new Info(
			obs,
			'(unknown)',
			'unknown',
			undefined,
			'unknown',
			[],
			[]
		);
	}

	constructor(
		public readonly sourceObj: IObservable<any> | IObserver,
		public readonly name: string,
		public readonly type: string,
		public readonly value: any,
		public readonly state: string,
		public readonly dependencies: (IObservable<any> | IObserver)[],
		public readonly observers: (IObservable<any> | IObserver)[],
	) { }
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/logging.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/logging.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { AutorunObserver } from '../reactions/autorunImpl.js';
import { IObservable } from '../base.js';
import { TransactionImpl } from '../transaction.js';
import type { Derived } from '../observables/derivedImpl.js';
import { DebugLocation } from '../debugLocation.js';

let globalObservableLogger: IObservableLogger | undefined;

export function addLogger(logger: IObservableLogger): void {
	if (!globalObservableLogger) {
		globalObservableLogger = logger;
	} else if (globalObservableLogger instanceof ComposedLogger) {
		globalObservableLogger.loggers.push(logger);
	} else {
		globalObservableLogger = new ComposedLogger([globalObservableLogger, logger]);
	}
}

export function getLogger(): IObservableLogger | undefined {
	return globalObservableLogger;
}

let globalObservableLoggerFn: ((obs: IObservable<any>) => void) | undefined = undefined;
export function setLogObservableFn(fn: (obs: IObservable<any>) => void): void {
	globalObservableLoggerFn = fn;
}

export function logObservable(obs: IObservable<any>): void {
	if (globalObservableLoggerFn) {
		globalObservableLoggerFn(obs);
	}
}

export interface IChangeInformation {
	oldValue: unknown;
	newValue: unknown;
	change: unknown;
	didChange: boolean;
	hadValue: boolean;
}

export interface IObservableLogger {
	handleObservableCreated(observable: IObservable<any>, location: DebugLocation): void;
	handleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void;

	handleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void;

	handleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void;
	handleAutorunDisposed(autorun: AutorunObserver): void;
	handleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void;
	handleAutorunStarted(autorun: AutorunObserver): void;
	handleAutorunFinished(autorun: AutorunObserver): void;

	handleDerivedDependencyChanged(derived: Derived<any, any, any>, observable: IObservable<any>, change: unknown): void;
	handleDerivedCleared(observable: Derived<any, any, any>): void;

	handleBeginTransaction(transaction: TransactionImpl): void;
	handleEndTransaction(transaction: TransactionImpl): void;
}

class ComposedLogger implements IObservableLogger {
	constructor(
		public readonly loggers: IObservableLogger[],
	) { }

	handleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {
		for (const logger of this.loggers) {
			logger.handleObservableCreated(observable, location);
		}
	}
	handleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {
		for (const logger of this.loggers) {
			logger.handleOnListenerCountChanged(observable, newCount);
		}
	}
	handleObservableUpdated(observable: IObservable<any>, info: IChangeInformation): void {
		for (const logger of this.loggers) {
			logger.handleObservableUpdated(observable, info);
		}
	}
	handleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {
		for (const logger of this.loggers) {
			logger.handleAutorunCreated(autorun, location);
		}
	}
	handleAutorunDisposed(autorun: AutorunObserver): void {
		for (const logger of this.loggers) {
			logger.handleAutorunDisposed(autorun);
		}
	}
	handleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {
		for (const logger of this.loggers) {
			logger.handleAutorunDependencyChanged(autorun, observable, change);
		}
	}
	handleAutorunStarted(autorun: AutorunObserver): void {
		for (const logger of this.loggers) {
			logger.handleAutorunStarted(autorun);
		}
	}
	handleAutorunFinished(autorun: AutorunObserver): void {
		for (const logger of this.loggers) {
			logger.handleAutorunFinished(autorun);
		}
	}
	handleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {
		for (const logger of this.loggers) {
			logger.handleDerivedDependencyChanged(derived, observable, change);
		}
	}
	handleDerivedCleared(observable: Derived<any>): void {
		for (const logger of this.loggers) {
			logger.handleDerivedCleared(observable);
		}
	}
	handleBeginTransaction(transaction: TransactionImpl): void {
		for (const logger of this.loggers) {
			logger.handleBeginTransaction(transaction);
		}
	}
	handleEndTransaction(transaction: TransactionImpl): void {
		for (const logger of this.loggers) {
			logger.handleEndTransaction(transaction);
		}
	}
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/debugger/debuggerApi.d.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/debugger/debuggerApi.d.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

export type ObsDebuggerApi = {
	channelId: 'observableDevTools',
	host: {
		notifications: {
			handleChange(update: ObsStateUpdate, clearState: boolean): void;
		}
		requests: {},
	};
	client: {
		notifications: {
			setDeclarationIdFilter(declarationIds: ObsDeclarationId[]): void;
			logObservableValue(observableId: ObsInstanceId): void;
			flushUpdates(): void;
			resetUpdates(): void;
		},
		requests: {
			getDeclarations(): IObsDeclarations;
			getSummarizedInstances(): IObsPushState;
			getDerivedInfo(instanceId: ObsInstanceId): IDerivedObservableDetailedInfo;
			getAutorunInfo(instanceId: ObsInstanceId): IAutorunDetailedInfo;
			getObservableValueInfo(instanceId: ObsInstanceId): IObservableValueInfo;

			setValue(instanceId: ObsInstanceId, jsonValue: unknown): void;
			getValue(instanceId: ObsInstanceId): unknown;

			// For autorun and deriveds
			rerun(instanceId: ObsInstanceId): void;

			logValue(instanceId: ObsInstanceId): void;

			getTransactionState(): ITransactionState | undefined;
		}
	};
};

export type ObsDeclarationId = number;

export type ObsInstanceId = number;

export type ObsDeclarationType = 'observable/value' | 'observable/derived' | 'autorun' | 'transaction';

export interface IObsDeclarations {
	decls: Record<ObsDeclarationId, IObsDeclaration>;
}

/** Immutable */
export interface IObsDeclaration {
	id: ObsDeclarationId;
	type: ObsDeclarationType;

	url: string;
	line: number;
	column: number;
}

export interface IObsPushState {
	declStates: Record<ObsDeclarationId, IObsDeclarationSummary | null>;
	instances: Record<ObsInstanceId, ObsInstancePushState | null>;
}

export interface IObsDeclarationSummary {
	activeInstances: number;
	recentInstances: ObsInstanceId[]; // Limited
}

export type ObsInstancePushState = IObservableValueInstancePushState | IDerivedObservableInstancePushState | IAutorunInstancePushState;


interface IBaseObsInstancePushState {
	instanceId: ObsInstanceId;
	declarationId: ObsDeclarationId;
	name: string;
	ownerId: ObsOwnerId | undefined;
}

export interface IObservableInstancePushState extends IBaseObsInstancePushState {
	formattedValue: string | undefined;
}

export interface IObservableValueInstancePushState extends IBaseObsInstancePushState, IObservableInstancePushState {
	type: 'observable/value';
}

export interface IDerivedObservableInstancePushState extends IBaseObsInstancePushState, IObservableInstancePushState {
	type: 'observable/derived';
	recomputationCount: number;
	formattedValue: string | undefined;
}

export interface IAutorunInstancePushState extends IBaseObsInstancePushState {
	type: 'autorun';
	runCount: number;
}

export type ObsOwnerId = number;

export type ObsStateUpdate = Partial<IObsDeclarations> & DeepPartial<IObsPushState>;

type DeepPartial<T> = { [TKey in keyof T]?: DeepPartial<T[TKey]> };

export interface IObservableValueInfo {
	observers: IObsInstanceRef[];
}

export interface IDerivedObservableDetailedInfo {
	dependencies: IObsInstanceRef[];
	observers: IObsInstanceRef[];
}

export interface IAutorunDetailedInfo {
	dependencies: IObsInstanceRef[];
}

export interface IObsInstanceRef {
	instanceId: ObsInstanceId;
	name: string;
}

export interface ITransactionState {
	names: string[];
	affected: ObserverInstanceState[];
}

export type ObserverInstanceState = DerivedObservableState | AutorunState;

export type DerivedObservableState =
	IObsInstanceRef & { type: 'observable/derived', updateCount: number } & (
		{ state: 'noValue' }
		| { state: 'stale', changedDependencies: ObsInstanceId[] }
		| { state: 'possiblyStale', }
		| { state: 'upToDate' }
		| { state: 'updating', changedDependencies: ObsInstanceId[], initialComputation: boolean }
	);

export type AutorunState =
	IObsInstanceRef & { type: 'autorun', updateCount: number } & (
		{ state: 'stale', changedDependencies: ObsInstanceId[], }
		| { state: 'possiblyStale', }
		| { state: 'upToDate' }
		| { state: 'updating', changedDependencies: ObsInstanceId[], }
	);

export type ObservableValueState =
	IObsInstanceRef & { type: 'observable/value' } & (
		{ state: 'upToDate' }
		| { state: 'updating' }
	);
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/debugger/debuggerRpc.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/debugger/debuggerRpc.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { ChannelFactory, IChannelHandler, API, SimpleTypedRpcConnection, MakeSideAsync } from './rpc.js';

export function registerDebugChannel<T extends { channelId: string } & API>(
	channelId: T['channelId'],
	createClient: () => T['client'],
): SimpleTypedRpcConnection<MakeSideAsync<T['host']>> {
	// eslint-disable-next-line local/code-no-any-casts
	const g = globalThis as any as GlobalObj;

	let queuedNotifications: unknown[] = [];
	let curHost: IHost | undefined = undefined;

	const { channel, handler } = createChannelFactoryFromDebugChannel({
		sendNotification: (data) => {
			if (curHost) {
				curHost.sendNotification(data);
			} else {
				queuedNotifications.push(data);
			}
		},
	});

	let curClient: T['client'] | undefined = undefined;

	(g.$$debugValueEditor_debugChannels ?? (g.$$debugValueEditor_debugChannels = {}))[channelId] = (host) => {
		curClient = createClient();
		curHost = host;
		for (const n of queuedNotifications) {
			host.sendNotification(n);
		}
		queuedNotifications = [];
		return handler;
	};

	return SimpleTypedRpcConnection.createClient<T>(channel, () => {
		if (!curClient) { throw new Error('Not supported'); }
		return curClient;
	});
}

interface GlobalObj {
	$$debugValueEditor_debugChannels: Record<string, (host: IHost) => { handleRequest: (data: unknown) => unknown }>;
}

interface IHost {
	sendNotification: (data: unknown) => void;
}

function createChannelFactoryFromDebugChannel(host: IHost): { channel: ChannelFactory; handler: { handleRequest: (data: unknown) => unknown } } {
	let h: IChannelHandler | undefined;
	const channel: ChannelFactory = (handler) => {
		h = handler;
		return {
			sendNotification: data => {
				host.sendNotification(data);
			},
			sendRequest: data => {
				throw new Error('not supported');
			},
		};
	};
	return {
		channel: channel,
		handler: {
			handleRequest: (data: any) => {
				if (data.type === 'notification') {
					return h?.handleNotification(data.data);
				} else {
					return h?.handleRequest(data.data);
				}
			},
		},
	};
}
```

--------------------------------------------------------------------------------

---[FILE: src/vs/base/common/observableInternal/logging/debugger/devToolsLogger.ts]---
Location: vscode-main/src/vs/base/common/observableInternal/logging/debugger/devToolsLogger.ts

```typescript
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { AutorunObserver, AutorunState } from '../../reactions/autorunImpl.js';
import { TransactionImpl } from '../../transaction.js';
import { IChangeInformation, IObservableLogger } from '../logging.js';
import { formatValue } from '../consoleObservableLogger.js';
import { ObsDebuggerApi, IObsDeclaration, ObsInstanceId, ObsStateUpdate, ITransactionState, ObserverInstanceState } from './debuggerApi.js';
import { registerDebugChannel } from './debuggerRpc.js';
import { deepAssign, deepAssignDeleteNulls, Throttler } from './utils.js';
import { isDefined } from '../../../types.js';
import { FromEventObservable } from '../../observables/observableFromEvent.js';
import { BugIndicatingError, onUnexpectedError } from '../../../errors.js';
import { IObservable, IObserver } from '../../base.js';
import { BaseObservable } from '../../observables/baseObservable.js';
import { Derived, DerivedState } from '../../observables/derivedImpl.js';
import { ObservableValue } from '../../observables/observableValue.js';
import { DebugLocation } from '../../debugLocation.js';

interface IInstanceInfo {
	declarationId: number;
	instanceId: number;
}

interface IObservableInfo extends IInstanceInfo {
	listenerCount: number;
	lastValue: string | undefined;
	updateCount: number;
	changedObservables: Set<IObservable<any>>;
}

interface IAutorunInfo extends IInstanceInfo {
	updateCount: number;
	changedObservables: Set<IObservable<any>>;
}

export class DevToolsLogger implements IObservableLogger {
	private static _instance: DevToolsLogger | undefined = undefined;
	public static getInstance(): DevToolsLogger {
		if (DevToolsLogger._instance === undefined) {
			DevToolsLogger._instance = new DevToolsLogger();
		}
		return DevToolsLogger._instance;
	}

	private _declarationId = 0;
	private _instanceId = 0;

	private readonly _declarations = new Map</* declarationId + type */string, IObsDeclaration>();
	private readonly _instanceInfos = new WeakMap<object, IObservableInfo | IAutorunInfo>();
	private readonly _aliveInstances = new Map<ObsInstanceId, IObservable<any> | AutorunObserver>();
	private readonly _activeTransactions = new Set<TransactionImpl>();

	private readonly _channel = registerDebugChannel<ObsDebuggerApi>('observableDevTools', () => {
		return {
			notifications: {
				setDeclarationIdFilter: declarationIds => {

				},
				logObservableValue: (observableId) => {
					console.log('logObservableValue', observableId);
				},
				flushUpdates: () => {
					this._flushUpdates();
				},
				resetUpdates: () => {
					this._pendingChanges = null;
					this._channel.api.notifications.handleChange(this._fullState, true);
				},
			},
			requests: {
				getDeclarations: () => {
					const result: Record<string, IObsDeclaration> = {};
					for (const decl of this._declarations.values()) {
						result[decl.id] = decl;
					}
					return { decls: result };
				},
				getSummarizedInstances: () => {
					return null!;
				},
				getObservableValueInfo: instanceId => {
					const obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;
					return {
						observers: [...obs.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),
					};
				},
				getDerivedInfo: instanceId => {
					const d = this._aliveInstances.get(instanceId) as Derived<any>;
					return {
						dependencies: [...d.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),
						observers: [...d.debugGetObservers()].map(d => this._formatObserver(d)).filter(isDefined),
					};
				},
				getAutorunInfo: instanceId => {
					const obs = this._aliveInstances.get(instanceId) as AutorunObserver;
					return {
						dependencies: [...obs.debugGetState().dependencies].map(d => this._formatObservable(d)).filter(isDefined),
					};
				},
				getTransactionState: () => {
					return this.getTransactionState();
				},
				setValue: (instanceId, jsonValue) => {
					const obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;

					if (obs instanceof Derived) {
						obs.debugSetValue(jsonValue);
					} else if (obs instanceof ObservableValue) {
						obs.debugSetValue(jsonValue);
					} else if (obs instanceof FromEventObservable) {
						obs.debugSetValue(jsonValue);
					} else {
						throw new BugIndicatingError('Observable is not supported');
					}

					const observers = [...obs.debugGetObservers()];
					for (const d of observers) {
						d.beginUpdate(obs);
					}
					for (const d of observers) {
						d.handleChange(obs, undefined);
					}
					for (const d of observers) {
						d.endUpdate(obs);
					}
				},
				getValue: instanceId => {
					const obs = this._aliveInstances.get(instanceId) as BaseObservable<any>;
					if (obs instanceof Derived) {
						return formatValue(obs.debugGetState().value, 200);
					} else if (obs instanceof ObservableValue) {
						return formatValue(obs.debugGetState().value, 200);
					}

					return undefined;
				},
				logValue: (instanceId) => {
					const obs = this._aliveInstances.get(instanceId);
					if (obs && 'get' in obs) {
						console.log('Logged Value:', obs.get());
					} else {
						throw new BugIndicatingError('Observable is not supported');
					}
				},
				rerun: (instanceId) => {
					const obs = this._aliveInstances.get(instanceId);
					if (obs instanceof Derived) {
						obs.debugRecompute();
					} else if (obs instanceof AutorunObserver) {
						obs.debugRerun();
					} else {
						throw new BugIndicatingError('Observable is not supported');
					}
				},
			}
		};
	});

	private getTransactionState(): ITransactionState | undefined {
		const affected: ObserverInstanceState[] = [];
		const txs = [...this._activeTransactions];
		if (txs.length === 0) {
			return undefined;
		}
		const observerQueue = txs.flatMap(t => t.debugGetUpdatingObservers() ?? []).map(o => o.observer);
		const processedObservers = new Set<IObserver>();
		while (observerQueue.length > 0) {
			const observer = observerQueue.shift()!;
			if (processedObservers.has(observer)) {
				continue;
			}
			processedObservers.add(observer);

			const state = this._getInfo(observer, d => {
				if (!processedObservers.has(d)) {
					observerQueue.push(d);
				}
			});

			if (state) {
				affected.push(state);
			}
		}

		return { names: txs.map(t => t.getDebugName() ?? 'tx'), affected };
	}

	private _getObservableInfo(observable: IObservable<any>): IObservableInfo | undefined {
		const info = this._instanceInfos.get(observable);
		if (!info) {
			onUnexpectedError(new BugIndicatingError('No info found'));
			return undefined;
		}
		return info as IObservableInfo;
	}

	private _getAutorunInfo(autorun: AutorunObserver): IAutorunInfo | undefined {
		const info = this._instanceInfos.get(autorun);
		if (!info) {
			onUnexpectedError(new BugIndicatingError('No info found'));
			return undefined;
		}
		return info as IAutorunInfo;
	}

	private _getInfo(observer: IObserver, queue: (observer: IObserver) => void): ObserverInstanceState | undefined {
		if (observer instanceof Derived) {
			const observersToUpdate = [...observer.debugGetObservers()];
			for (const o of observersToUpdate) {
				queue(o);
			}

			const info = this._getObservableInfo(observer);
			if (!info) { return; }

			const observerState = observer.debugGetState();

			const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: observerState.updateCount };
			const changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)?.instanceId).filter(isDefined);
			if (observerState.isComputing) {
				return { ...base, type: 'observable/derived', state: 'updating', changedDependencies, initialComputation: false };
			}
			switch (observerState.state) {
				case DerivedState.initial:
					return { ...base, type: 'observable/derived', state: 'noValue' };
				case DerivedState.upToDate:
					return { ...base, type: 'observable/derived', state: 'upToDate' };
				case DerivedState.stale:
					return { ...base, type: 'observable/derived', state: 'stale', changedDependencies };
				case DerivedState.dependenciesMightHaveChanged:
					return { ...base, type: 'observable/derived', state: 'possiblyStale' };
			}
		} else if (observer instanceof AutorunObserver) {
			const info = this._getAutorunInfo(observer);
			if (!info) { return undefined; }

			const base = { name: observer.debugName, instanceId: info.instanceId, updateCount: info.updateCount };
			const changedDependencies = [...info.changedObservables].map(o => this._instanceInfos.get(o)!.instanceId);
			if (observer.debugGetState().isRunning) {
				return { ...base, type: 'autorun', state: 'updating', changedDependencies };
			}
			switch (observer.debugGetState().state) {
				case AutorunState.upToDate:
					return { ...base, type: 'autorun', state: 'upToDate' };
				case AutorunState.stale:
					return { ...base, type: 'autorun', state: 'stale', changedDependencies };
				case AutorunState.dependenciesMightHaveChanged:
					return { ...base, type: 'autorun', state: 'possiblyStale' };
			}

		}
		return undefined;
	}

	private _formatObservable(obs: IObservable<any>): { name: string; instanceId: ObsInstanceId } | undefined {
		const info = this._getObservableInfo(obs);
		if (!info) { return undefined; }
		return { name: obs.debugName, instanceId: info.instanceId };
	}

	private _formatObserver(obs: IObserver): { name: string; instanceId: ObsInstanceId } | undefined {
		if (obs instanceof Derived) {
			return { name: obs.toString(), instanceId: this._getObservableInfo(obs)?.instanceId! };
		}
		const autorunInfo = this._getAutorunInfo(obs as AutorunObserver);
		if (autorunInfo) {
			return { name: obs.toString(), instanceId: autorunInfo.instanceId };
		}

		return undefined;
	}

	private constructor() {
		DebugLocation.enable();
	}

	private _pendingChanges: ObsStateUpdate | null = null;
	private readonly _changeThrottler = new Throttler();

	private readonly _fullState = {};

	private _handleChange(update: ObsStateUpdate): void {
		deepAssignDeleteNulls(this._fullState, update);

		if (this._pendingChanges === null) {
			this._pendingChanges = update;
		} else {
			deepAssign(this._pendingChanges, update);
		}

		this._changeThrottler.throttle(this._flushUpdates, 10);
	}

	private readonly _flushUpdates = () => {
		if (this._pendingChanges !== null) {
			this._channel.api.notifications.handleChange(this._pendingChanges, false);
			this._pendingChanges = null;
		}
	};

	private _getDeclarationId(type: IObsDeclaration['type'], location: DebugLocation): number {
		if (!location) {
			return -1;
		}

		let decInfo = this._declarations.get(location.id);
		if (decInfo === undefined) {
			decInfo = {
				id: this._declarationId++,
				type,
				url: location.fileName,
				line: location.line,
				column: location.column,
			};
			this._declarations.set(location.id, decInfo);

			this._handleChange({ decls: { [decInfo.id]: decInfo } });
		}
		return decInfo.id;
	}

	handleObservableCreated(observable: IObservable<any>, location: DebugLocation): void {
		const declarationId = this._getDeclarationId('observable/value', location);

		const info: IObservableInfo = {
			declarationId,
			instanceId: this._instanceId++,
			listenerCount: 0,
			lastValue: undefined,
			updateCount: 0,
			changedObservables: new Set(),
		};
		this._instanceInfos.set(observable, info);
	}

	handleOnListenerCountChanged(observable: IObservable<any>, newCount: number): void {
		const info = this._getObservableInfo(observable);
		if (!info) { return; }

		if (info.listenerCount === 0 && newCount > 0) {
			const type: IObsDeclaration['type'] =
				observable instanceof Derived ? 'observable/derived' : 'observable/value';
			this._aliveInstances.set(info.instanceId, observable);
			this._handleChange({
				instances: {
					[info.instanceId]: {
						instanceId: info.instanceId,
						declarationId: info.declarationId,
						formattedValue: info.lastValue,
						type,
						name: observable.debugName,
					}
				}
			});
		} else if (info.listenerCount > 0 && newCount === 0) {
			this._handleChange({
				instances: { [info.instanceId]: null }
			});
			this._aliveInstances.delete(info.instanceId);
		}
		info.listenerCount = newCount;
	}

	handleObservableUpdated(observable: IObservable<any>, changeInfo: IChangeInformation): void {
		if (observable instanceof Derived) {
			this._handleDerivedRecomputed(observable, changeInfo);
			return;
		}

		const info = this._getObservableInfo(observable);
		if (info) {
			if (changeInfo.didChange) {
				info.lastValue = formatValue(changeInfo.newValue, 30);
				if (info.listenerCount > 0) {
					this._handleChange({
						instances: { [info.instanceId]: { formattedValue: info.lastValue } }
					});
				}
			}
		}
	}

	handleAutorunCreated(autorun: AutorunObserver, location: DebugLocation): void {
		const declarationId = this._getDeclarationId('autorun', location);
		const info: IAutorunInfo = {
			declarationId,
			instanceId: this._instanceId++,
			updateCount: 0,
			changedObservables: new Set(),
		};
		this._instanceInfos.set(autorun, info);
		this._aliveInstances.set(info.instanceId, autorun);
		if (info) {
			this._handleChange({
				instances: {
					[info.instanceId]: {
						instanceId: info.instanceId,
						declarationId: info.declarationId,
						runCount: 0,
						type: 'autorun',
						name: autorun.debugName,
					}
				}
			});
		}
	}
	handleAutorunDisposed(autorun: AutorunObserver): void {
		const info = this._getAutorunInfo(autorun);
		if (!info) { return; }

		this._handleChange({
			instances: { [info.instanceId]: null }
		});
		this._instanceInfos.delete(autorun);
		this._aliveInstances.delete(info.instanceId);
	}
	handleAutorunDependencyChanged(autorun: AutorunObserver, observable: IObservable<any>, change: unknown): void {
		const info = this._getAutorunInfo(autorun);
		if (!info) { return; }

		info.changedObservables.add(observable);
	}
	handleAutorunStarted(autorun: AutorunObserver): void {

	}
	handleAutorunFinished(autorun: AutorunObserver): void {
		const info = this._getAutorunInfo(autorun);
		if (!info) { return; }

		info.changedObservables.clear();
		info.updateCount++;
		this._handleChange({
			instances: { [info.instanceId]: { runCount: info.updateCount } }
		});
	}

	handleDerivedDependencyChanged(derived: Derived<any>, observable: IObservable<any>, change: unknown): void {
		const info = this._getObservableInfo(derived);
		if (info) {
			info.changedObservables.add(observable);
		}
	}
	_handleDerivedRecomputed(observable: Derived<any>, changeInfo: IChangeInformation): void {
		const info = this._getObservableInfo(observable);
		if (!info) { return; }

		const formattedValue = formatValue(changeInfo.newValue, 30);
		info.updateCount++;
		info.changedObservables.clear();

		info.lastValue = formattedValue;
		if (info.listenerCount > 0) {
			this._handleChange({
				instances: { [info.instanceId]: { formattedValue: formattedValue, recomputationCount: info.updateCount } }
			});
		}
	}
	handleDerivedCleared(observable: Derived<any>): void {
		const info = this._getObservableInfo(observable);
		if (!info) { return; }

		info.lastValue = undefined;
		info.changedObservables.clear();
		if (info.listenerCount > 0) {
			this._handleChange({
				instances: {
					[info.instanceId]: {
						formattedValue: undefined,
					}
				}
			});
		}
	}
	handleBeginTransaction(transaction: TransactionImpl): void {
		this._activeTransactions.add(transaction);
	}
	handleEndTransaction(transaction: TransactionImpl): void {
		this._activeTransactions.delete(transaction);
	}
}
```

--------------------------------------------------------------------------------

````
