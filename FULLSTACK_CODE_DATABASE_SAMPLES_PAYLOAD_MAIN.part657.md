---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:13Z
part: 657
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 657 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: payload-types.ts]---
Location: payload-main/test/relationships/payload-types.ts

```typescript
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:types` to regenerate this file.
 */

/**
 * Supported timezones in IANA format.
 *
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "supportedTimezones".
 */
export type SupportedTimezones =
  | 'Pacific/Midway'
  | 'Pacific/Niue'
  | 'Pacific/Honolulu'
  | 'Pacific/Rarotonga'
  | 'America/Anchorage'
  | 'Pacific/Gambier'
  | 'America/Los_Angeles'
  | 'America/Tijuana'
  | 'America/Denver'
  | 'America/Phoenix'
  | 'America/Chicago'
  | 'America/Guatemala'
  | 'America/New_York'
  | 'America/Bogota'
  | 'America/Caracas'
  | 'America/Santiago'
  | 'America/Buenos_Aires'
  | 'America/Sao_Paulo'
  | 'Atlantic/South_Georgia'
  | 'Atlantic/Azores'
  | 'Atlantic/Cape_Verde'
  | 'Europe/London'
  | 'Europe/Berlin'
  | 'Africa/Lagos'
  | 'Europe/Athens'
  | 'Africa/Cairo'
  | 'Europe/Moscow'
  | 'Asia/Riyadh'
  | 'Asia/Dubai'
  | 'Asia/Baku'
  | 'Asia/Karachi'
  | 'Asia/Tashkent'
  | 'Asia/Calcutta'
  | 'Asia/Dhaka'
  | 'Asia/Almaty'
  | 'Asia/Jakarta'
  | 'Asia/Bangkok'
  | 'Asia/Shanghai'
  | 'Asia/Singapore'
  | 'Asia/Tokyo'
  | 'Asia/Seoul'
  | 'Australia/Brisbane'
  | 'Australia/Sydney'
  | 'Pacific/Guam'
  | 'Pacific/Noumea'
  | 'Pacific/Auckland'
  | 'Pacific/Fiji';

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  blocks: {};
  collections: {
    posts: Post;
    postsLocalized: PostsLocalized;
    relation: Relation;
    'strict-access': StrictAccess;
    chained: Chained;
    'custom-id': CustomId;
    'custom-id-number': CustomIdNumber;
    screenings: Screening;
    movies: Movie;
    directors: Director;
    movieReviews: MovieReview;
    'polymorphic-relationships': PolymorphicRelationship;
    tree: Tree;
    pages: Page;
    'rels-to-pages': RelsToPage;
    'rels-to-pages-and-custom-text-ids': RelsToPagesAndCustomTextId;
    'object-writes': ObjectWrite;
    'deep-nested': DeepNested;
    relations: Relation1;
    items: Item;
    blocks: Block;
    users: User;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsJoins: {
    items: {
      relation: 'relations';
    };
  };
  collectionsSelect: {
    posts: PostsSelect<false> | PostsSelect<true>;
    postsLocalized: PostsLocalizedSelect<false> | PostsLocalizedSelect<true>;
    relation: RelationSelect<false> | RelationSelect<true>;
    'strict-access': StrictAccessSelect<false> | StrictAccessSelect<true>;
    chained: ChainedSelect<false> | ChainedSelect<true>;
    'custom-id': CustomIdSelect<false> | CustomIdSelect<true>;
    'custom-id-number': CustomIdNumberSelect<false> | CustomIdNumberSelect<true>;
    screenings: ScreeningsSelect<false> | ScreeningsSelect<true>;
    movies: MoviesSelect<false> | MoviesSelect<true>;
    directors: DirectorsSelect<false> | DirectorsSelect<true>;
    movieReviews: MovieReviewsSelect<false> | MovieReviewsSelect<true>;
    'polymorphic-relationships': PolymorphicRelationshipsSelect<false> | PolymorphicRelationshipsSelect<true>;
    tree: TreeSelect<false> | TreeSelect<true>;
    pages: PagesSelect<false> | PagesSelect<true>;
    'rels-to-pages': RelsToPagesSelect<false> | RelsToPagesSelect<true>;
    'rels-to-pages-and-custom-text-ids': RelsToPagesAndCustomTextIdsSelect<false> | RelsToPagesAndCustomTextIdsSelect<true>;
    'object-writes': ObjectWritesSelect<false> | ObjectWritesSelect<true>;
    'deep-nested': DeepNestedSelect<false> | DeepNestedSelect<true>;
    relations: RelationsSelect<false> | RelationsSelect<true>;
    items: ItemsSelect<false> | ItemsSelect<true>;
    blocks: BlocksSelect<false> | BlocksSelect<true>;
    users: UsersSelect<false> | UsersSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: 'en' | 'de';
  user: User & {
    collection: 'users';
  };
  jobs: {
    tasks: unknown;
    workflows: unknown;
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "posts".
 */
export interface Post {
  id: string;
  title?: string | null;
  description?: string | null;
  number?: number | null;
  relationField?: (string | null) | Relation;
  blocks?:
    | {
        relationField?: (string | null) | Relation;
        id?: string | null;
        blockName?: string | null;
        blockType: 'block';
      }[]
    | null;
  defaultAccessRelation?: (string | null) | StrictAccess;
  chainedRelation?: (string | null) | Chained;
  maxDepthRelation?: (string | null) | Relation;
  customIdRelation?: (string | null) | CustomId;
  customIdNumberRelation?: (number | null) | CustomIdNumber;
  filteredRelation?: (string | null) | Relation;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation".
 */
export interface Relation {
  id: string;
  name?: string | null;
  disableRelation: boolean;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "strict-access".
 */
export interface StrictAccess {
  id: string;
  name?: string | null;
  disableRelation: boolean;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "chained".
 */
export interface Chained {
  id: string;
  name?: string | null;
  relation?: (string | null) | Chained;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "custom-id".
 */
export interface CustomId {
  id: string;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "custom-id-number".
 */
export interface CustomIdNumber {
  id: number;
  name?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "postsLocalized".
 */
export interface PostsLocalized {
  id: string;
  title?: string | null;
  relationField?: (string | null) | Relation;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "screenings".
 */
export interface Screening {
  id: string;
  name?: string | null;
  movie?: (string | null) | Movie;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "movies".
 */
export interface Movie {
  id: string;
  name?: string | null;
  select?: ('a' | 'b' | 'c')[] | null;
  director?: (string | null) | Director;
  array?:
    | {
        director?: (string | Director)[] | null;
        polymorphic?: {
          relationTo: 'directors';
          value: string | Director;
        } | null;
        id?: string | null;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
  _status?: ('draft' | 'published') | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "directors".
 */
export interface Director {
  id: string;
  name?: string | null;
  localized?: string | null;
  movies?: (string | Movie)[] | null;
  movie?: (string | null) | Movie;
  directors?: (string | Director)[] | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "movieReviews".
 */
export interface MovieReview {
  id: string;
  movieReviewer: string | User;
  likes?: (string | User)[] | null;
  visibility: 'followers' | 'public';
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  sessions?:
    | {
        id: string;
        createdAt?: string | null;
        expiresAt: string;
      }[]
    | null;
  password?: string | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "polymorphic-relationships".
 */
export interface PolymorphicRelationship {
  id: string;
  polymorphic?: {
    relationTo: 'movies';
    value: string | Movie;
  } | null;
  polymorphicLocalized?: {
    relationTo: 'movies';
    value: string | Movie;
  } | null;
  polymorphicMany?:
    | {
        relationTo: 'movies';
        value: string | Movie;
      }[]
    | null;
  polymorphicManyLocalized?:
    | {
        relationTo: 'movies';
        value: string | Movie;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "tree".
 */
export interface Tree {
  id: string;
  text?: string | null;
  parent?: (string | null) | Tree;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "pages".
 */
export interface Page {
  id: string;
  menu?:
    | {
        label?: string | null;
        id?: string | null;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "rels-to-pages".
 */
export interface RelsToPage {
  id: string;
  page?: (string | null) | Page;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "rels-to-pages-and-custom-text-ids".
 */
export interface RelsToPagesAndCustomTextId {
  id: string;
  rel?:
    | ({
        relationTo: 'pages';
        value: string | Page;
      } | null)
    | ({
        relationTo: 'custom-id';
        value: string | CustomId;
      } | null)
    | ({
        relationTo: 'custom-id-number';
        value: number | CustomIdNumber;
      } | null);
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "object-writes".
 */
export interface ObjectWrite {
  id: string;
  one?: (string | null) | Movie;
  many?: (string | Movie)[] | null;
  onePoly?: {
    relationTo: 'movies';
    value: string | Movie;
  } | null;
  manyPoly?:
    | {
        relationTo: 'movies';
        value: string | Movie;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "deep-nested".
 */
export interface DeepNested {
  id: string;
  content?: {
    blocks?:
      | {
          meta?: {
            movie?: (string | null) | Movie;
          };
          id?: string | null;
          blockName?: string | null;
          blockType: 'testBlock';
        }[]
      | null;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relations".
 */
export interface Relation1 {
  id: string;
  item?: {
    relationTo: 'items';
    value: string | Item;
  } | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "items".
 */
export interface Item {
  id: string;
  status?: ('completed' | 'failed' | 'pending') | null;
  relation?: {
    docs?: (string | Relation1)[];
    hasNextPage?: boolean;
    totalDocs?: number;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "blocks".
 */
export interface Block {
  id: string;
  blocks?:
    | {
        director?: (string | null) | Director;
        id?: string | null;
        blockName?: string | null;
        blockType: 'some';
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'posts';
        value: string | Post;
      } | null)
    | ({
        relationTo: 'postsLocalized';
        value: string | PostsLocalized;
      } | null)
    | ({
        relationTo: 'relation';
        value: string | Relation;
      } | null)
    | ({
        relationTo: 'strict-access';
        value: string | StrictAccess;
      } | null)
    | ({
        relationTo: 'chained';
        value: string | Chained;
      } | null)
    | ({
        relationTo: 'custom-id';
        value: string | CustomId;
      } | null)
    | ({
        relationTo: 'custom-id-number';
        value: number | CustomIdNumber;
      } | null)
    | ({
        relationTo: 'screenings';
        value: string | Screening;
      } | null)
    | ({
        relationTo: 'movies';
        value: string | Movie;
      } | null)
    | ({
        relationTo: 'directors';
        value: string | Director;
      } | null)
    | ({
        relationTo: 'movieReviews';
        value: string | MovieReview;
      } | null)
    | ({
        relationTo: 'polymorphic-relationships';
        value: string | PolymorphicRelationship;
      } | null)
    | ({
        relationTo: 'tree';
        value: string | Tree;
      } | null)
    | ({
        relationTo: 'pages';
        value: string | Page;
      } | null)
    | ({
        relationTo: 'rels-to-pages';
        value: string | RelsToPage;
      } | null)
    | ({
        relationTo: 'rels-to-pages-and-custom-text-ids';
        value: string | RelsToPagesAndCustomTextId;
      } | null)
    | ({
        relationTo: 'object-writes';
        value: string | ObjectWrite;
      } | null)
    | ({
        relationTo: 'deep-nested';
        value: string | DeepNested;
      } | null)
    | ({
        relationTo: 'relations';
        value: string | Relation1;
      } | null)
    | ({
        relationTo: 'items';
        value: string | Item;
      } | null)
    | ({
        relationTo: 'blocks';
        value: string | Block;
      } | null)
    | ({
        relationTo: 'users';
        value: string | User;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "posts_select".
 */
export interface PostsSelect<T extends boolean = true> {
  title?: T;
  description?: T;
  number?: T;
  relationField?: T;
  blocks?:
    | T
    | {
        block?:
          | T
          | {
              relationField?: T;
              id?: T;
              blockName?: T;
            };
      };
  defaultAccessRelation?: T;
  chainedRelation?: T;
  maxDepthRelation?: T;
  customIdRelation?: T;
  customIdNumberRelation?: T;
  filteredRelation?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "postsLocalized_select".
 */
export interface PostsLocalizedSelect<T extends boolean = true> {
  title?: T;
  relationField?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relation_select".
 */
export interface RelationSelect<T extends boolean = true> {
  name?: T;
  disableRelation?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "strict-access_select".
 */
export interface StrictAccessSelect<T extends boolean = true> {
  name?: T;
  disableRelation?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "chained_select".
 */
export interface ChainedSelect<T extends boolean = true> {
  name?: T;
  relation?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "custom-id_select".
 */
export interface CustomIdSelect<T extends boolean = true> {
  id?: T;
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "custom-id-number_select".
 */
export interface CustomIdNumberSelect<T extends boolean = true> {
  id?: T;
  name?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "screenings_select".
 */
export interface ScreeningsSelect<T extends boolean = true> {
  name?: T;
  movie?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "movies_select".
 */
export interface MoviesSelect<T extends boolean = true> {
  name?: T;
  select?: T;
  director?: T;
  array?:
    | T
    | {
        director?: T;
        polymorphic?: T;
        id?: T;
      };
  updatedAt?: T;
  createdAt?: T;
  _status?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "directors_select".
 */
export interface DirectorsSelect<T extends boolean = true> {
  name?: T;
  localized?: T;
  movies?: T;
  movie?: T;
  directors?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "movieReviews_select".
 */
export interface MovieReviewsSelect<T extends boolean = true> {
  movieReviewer?: T;
  likes?: T;
  visibility?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "polymorphic-relationships_select".
 */
export interface PolymorphicRelationshipsSelect<T extends boolean = true> {
  polymorphic?: T;
  polymorphicLocalized?: T;
  polymorphicMany?: T;
  polymorphicManyLocalized?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "tree_select".
 */
export interface TreeSelect<T extends boolean = true> {
  text?: T;
  parent?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "pages_select".
 */
export interface PagesSelect<T extends boolean = true> {
  menu?:
    | T
    | {
        label?: T;
        id?: T;
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "rels-to-pages_select".
 */
export interface RelsToPagesSelect<T extends boolean = true> {
  page?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "rels-to-pages-and-custom-text-ids_select".
 */
export interface RelsToPagesAndCustomTextIdsSelect<T extends boolean = true> {
  rel?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "object-writes_select".
 */
export interface ObjectWritesSelect<T extends boolean = true> {
  one?: T;
  many?: T;
  onePoly?: T;
  manyPoly?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "deep-nested_select".
 */
export interface DeepNestedSelect<T extends boolean = true> {
  content?:
    | T
    | {
        blocks?:
          | T
          | {
              testBlock?:
                | T
                | {
                    meta?:
                      | T
                      | {
                          movie?: T;
                        };
                    id?: T;
                    blockName?: T;
                  };
            };
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "relations_select".
 */
export interface RelationsSelect<T extends boolean = true> {
  item?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "items_select".
 */
export interface ItemsSelect<T extends boolean = true> {
  status?: T;
  relation?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "blocks_select".
 */
export interface BlocksSelect<T extends boolean = true> {
  blocks?:
    | T
    | {
        some?:
          | T
          | {
              director?: T;
              id?: T;
              blockName?: T;
            };
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
  sessions?:
    | T
    | {
        id?: T;
        createdAt?: T;
        expiresAt?: T;
      };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
```

--------------------------------------------------------------------------------

---[FILE: shared.ts]---
Location: payload-main/test/relationships/shared.ts

```typescript
export const usersSlug = 'users'
export const slug = 'posts'
export const slugWithLocalizedRel = 'postsLocalized'
export const relationSlug = 'relation'
export const defaultAccessRelSlug = 'strict-access'
export const chainedRelSlug = 'chained'
export const customIdSlug = 'custom-id'
export const customIdNumberSlug = 'custom-id-number'
export const polymorphicRelationshipsSlug = 'polymorphic-relationships'
export const treeSlug = 'tree'
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/relationships/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.json]---
Location: payload-main/test/relationships/tsconfig.json

```json
{
  "extends": "../tsconfig.json"
}
```

--------------------------------------------------------------------------------

---[FILE: .gitignore]---
Location: payload-main/test/sdk/.gitignore

```text
media
```

--------------------------------------------------------------------------------

---[FILE: config.ts]---
Location: payload-main/test/sdk/config.ts

```typescript
import { fileURLToPath } from 'node:url'
import path from 'path'
const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

import { buildConfigWithDefaults } from '../buildConfigWithDefaults.js'
import { devUser } from '../credentials.js'
import { PostsCollection } from './collections/Posts.js'
import { Users } from './collections/Users.js'

export default buildConfigWithDefaults({
  admin: {
    importMap: {
      baseDir: path.resolve(dirname),
    },
  },
  collections: [
    Users,
    PostsCollection,
    {
      access: { create: () => true, read: () => true, update: () => true },
      slug: 'media',
      upload: { staticDir: path.resolve(dirname, './media') },
      fields: [],
    },
  ],
  globals: [
    {
      slug: 'global',
      fields: [{ type: 'text', name: 'text' }],
      versions: true,
    },
  ],
  localization: {
    defaultLocale: 'en',
    fallback: true,
    locales: ['en', 'es', 'de'],
  },
  onInit: async (payload) => {
    await payload.create({
      collection: 'users',
      data: {
        email: devUser.email,
        password: devUser.password,
      },
    })
  },
  typescript: {
    outputFile: path.resolve(dirname, 'payload-types.ts'),
  },
})
```

--------------------------------------------------------------------------------

---[FILE: eslint.config.js]---
Location: payload-main/test/sdk/eslint.config.js

```javascript
import { rootParserOptions } from '../../eslint.config.js'
import testEslintConfig from '../eslint.config.js'

/** @typedef {import('eslint').Linter.Config} Config */

/** @type {Config[]} */
export const index = [
  ...testEslintConfig,
  {
    languageOptions: {
      parserOptions: {
        tsconfigRootDir: import.meta.dirname,
        ...rootParserOptions,
      },
    },
  },
]

export default index
```

--------------------------------------------------------------------------------

---[FILE: int.spec.ts]---
Location: payload-main/test/sdk/int.spec.ts

```typescript
import type { Payload } from 'payload'

import { randomUUID } from 'crypto'
import path from 'path'
import { fileURLToPath } from 'url'

import type { TypedPayloadSDK } from '../helpers/getSDK.js'
import type { Post } from './payload-types.js'

import { initPayloadInt } from '../helpers/initPayloadInt.js'
import { createStreamableFile } from '../uploads/createStreamableFile.js'

let payload: Payload
let post: Post
let sdk: TypedPayloadSDK

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

const testUserCredentials = {
  email: 'test@payloadcms.com',
  password: '123456',
}

describe('@payloadcms/sdk', () => {
  beforeAll(async () => {
    ;({ payload, sdk } = await initPayloadInt(dirname))

    post = await payload.create({ collection: 'posts', data: { number: 1, number2: 3 } })
    await payload.create({
      collection: 'users',
      data: { ...testUserCredentials },
    })
    await payload.updateGlobal({ slug: 'global', data: { text: 'some-global' } })
  })

  afterAll(async () => {
    if (typeof payload.db.destroy === 'function') {
      await payload.db.destroy()
    }
  })

  it('should execute find', async () => {
    const result = await sdk.find({ collection: 'posts', where: { id: { equals: post.id } } })

    expect(result.docs[0].id).toBe(post.id)

    const ids = []
    for (let i = 0; i < 40; i++) {
      const post = await payload.create({ collection: 'posts', data: {} })
      ids.push(post.id)
    }

    const resultPaginationFalse = await sdk.find({ collection: 'posts', pagination: false })
    expect(resultPaginationFalse.docs).toHaveLength(41)
    expect(resultPaginationFalse.totalDocs).toBe(41)
    await payload.delete({ collection: 'posts', where: { id: { in: ids } } })
  })

  it('should execute findVersions', async () => {
    const result = await sdk.findVersions({
      collection: 'posts',
      where: { parent: { equals: post.id } },
    })

    expect(result.docs[0].parent).toBe(post.id)
  })

  it('should execute findByID', async () => {
    const result = await sdk.findByID({ collection: 'posts', id: post.id })

    expect(result.id).toBe(post.id)
  })

  it('should execute findByID with disableErrors: true', async () => {
    const result = await sdk.findByID({
      disableErrors: true,
      collection: 'posts',
      // eslint-disable-next-line jest/no-conditional-in-test
      id: typeof post.id === 'string' ? randomUUID() : 999,
    })

    expect(result).toBeNull()
  })

  it('should execute findVersionByID', async () => {
    const {
      docs: [version],
    } = await payload.findVersions({ collection: 'posts', where: { parent: { equals: post.id } } })

    const result = await sdk.findVersionByID({ collection: 'posts', id: version.id })

    expect(result.id).toBe(version.id)
  })

  it('should execute create', async () => {
    const result = await sdk.create({ collection: 'posts', data: { text: 'text' } })

    expect(result.text).toBe('text')
  })

  it('should execute create with file', async () => {
    const filePath = path.join(dirname, './image.jpg')
    const { file, handle } = await createStreamableFile(filePath)
    const res = await sdk.create({ collection: 'media', file, data: {} })
    expect(res.id).toBeTruthy()
    await handle.close()
  })

  it('should execute count', async () => {
    const result = await sdk.count({ collection: 'posts', where: { id: { equals: post.id } } })

    expect(result.totalDocs).toBe(1)
  })

  it('should execute update (by ID)', async () => {
    const result = await sdk.update({
      collection: 'posts',
      id: post.id,
      data: { text: 'updated-text' },
    })

    expect(result.text).toBe('updated-text')
  })

  it('should execute update (bulk)', async () => {
    const result = await sdk.update({
      collection: 'posts',
      where: {
        id: {
          equals: post.id,
        },
      },
      data: { text: 'updated-text-bulk' },
    })

    expect(result.docs[0].text).toBe('updated-text-bulk')
  })

  it('should execute delete (by ID)', async () => {
    const post = await payload.create({ collection: 'posts', data: {} })

    const result = await sdk.delete({ id: post.id, collection: 'posts' })

    expect(result.id).toBe(post.id)

    const resultLocal = await payload.findByID({
      collection: 'posts',
      id: post.id,
      disableErrors: true,
    })

    expect(resultLocal).toBeNull()
  })

  it('should execute delete (bulk)', async () => {
    const post = await payload.create({ collection: 'posts', data: {} })

    const result = await sdk.delete({ where: { id: { equals: post.id } }, collection: 'posts' })

    expect(result.docs[0].id).toBe(post.id)

    const resultLocal = await payload.findByID({
      collection: 'posts',
      id: post.id,
      disableErrors: true,
    })

    expect(resultLocal).toBeNull()
  })

  it('should execute restoreVersion', async () => {
    const post = await payload.create({ collection: 'posts', data: { text: 'old' } })

    const {
      docs: [currentVersion],
    } = await payload.findVersions({ collection: 'posts', where: { parent: { equals: post.id } } })

    await payload.update({ collection: 'posts', id: post.id, data: { text: 'new' } })

    const result = await sdk.restoreVersion({
      collection: 'posts',
      id: currentVersion.id,
    })

    expect(result.text).toBe('old')

    const resultDB = await payload.findByID({ collection: 'posts', id: post.id })

    expect(resultDB.text).toBe('old')
  })

  it('should execute findGlobal', async () => {
    const result = await sdk.findGlobal({ slug: 'global' })
    expect(result.text).toBe('some-global')
  })

  it('should execute findGlobalVersions', async () => {
    const result = await sdk.findGlobalVersions({
      slug: 'global',
    })

    expect(result.docs[0].version).toBeTruthy()
  })

  it('should execute findGlobalVersionByID', async () => {
    const {
      docs: [version],
    } = await payload.findGlobalVersions({
      slug: 'global',
    })

    const result = await sdk.findGlobalVersionByID({ id: version.id, slug: 'global' })

    expect(result.id).toBe(version.id)
  })

  it('should execute updateGlobal', async () => {
    const result = await sdk.updateGlobal({ slug: 'global', data: { text: 'some-updated-global' } })
    expect(result.text).toBe('some-updated-global')
  })

  it('should execute restoreGlobalVersion', async () => {
    await payload.updateGlobal({ slug: 'global', data: { text: 'old' } })

    const {
      docs: [currentVersion],
    } = await payload.findGlobalVersions({
      slug: 'global',
    })

    await payload.updateGlobal({ slug: 'global', data: { text: 'new' } })

    const { version: result } = await sdk.restoreGlobalVersion({
      slug: 'global',
      id: currentVersion.id,
    })

    expect(result.text).toBe('old')

    const resultDB = await payload.findGlobal({ slug: 'global' })

    expect(resultDB.text).toBe('old')
  })

  it('should execute login', async () => {
    const res = await sdk.login({
      collection: 'users',
      data: { email: testUserCredentials.email, password: testUserCredentials.password },
    })

    expect(res.user.email).toBe(testUserCredentials.email)
  })

  it('should execute me', async () => {
    const { token } = await sdk.login({
      collection: 'users',
      data: { email: testUserCredentials.email, password: testUserCredentials.password },
    })

    const res = await sdk.me(
      { collection: 'users' },
      { headers: { Authorization: `JWT ${token}` } },
    )

    expect(res.user.email).toBe(testUserCredentials.email)
  })

  it('should execute refreshToken', async () => {
    const { token } = await sdk.login({
      collection: 'users',
      data: { email: testUserCredentials.email, password: testUserCredentials.password },
    })

    const res = await sdk.refreshToken(
      { collection: 'users' },
      { headers: { Authorization: `JWT ${token}` } },
    )

    expect(res.user.email).toBe(testUserCredentials.email)
  })

  it('should execute forgotPassword and resetPassword', async () => {
    const user = await payload.create({
      collection: 'users',
      data: { email: 'new@payloadcms.com', password: 'HOW TO rEmeMber this password' },
    })

    const resForgotPassword = await sdk.forgotPassword({
      collection: 'users',
      data: { email: user.email },
    })

    expect(resForgotPassword.message).toBeTruthy()

    const afterForgotPassword = await payload.findByID({
      showHiddenFields: true,
      collection: 'users',
      id: user.id,
    })

    expect(afterForgotPassword.resetPasswordToken).toBeTruthy()

    const verifyEmailResult = await sdk.resetPassword({
      collection: 'users',
      data: { password: '1234567', token: afterForgotPassword.resetPasswordToken },
    })

    expect(verifyEmailResult.user.email).toBe(user.email)

    const {
      user: { email },
    } = await sdk.login({
      collection: 'users',
      data: { email: user.email, password: '1234567' },
    })

    expect(email).toBe(user.email)
  })
})
```

--------------------------------------------------------------------------------

````
