---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:14Z
part: 645
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 645 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: mouse_drag.ts]---
Location: zulip-main/web/src/mouse_drag.ts

```typescript
import $ from "jquery";

let start_x = 0;
let start_y = 0;

export function initialize(): void {
    $(document).on("mousedown", (e) => {
        start_x = e.pageX;
        start_y = e.pageY;
    });
}

export function is_drag(e: JQuery.ClickEvent): boolean {
    // Used to prevent click handlers from firing when dragging a
    // region, even if not actually selecting something.

    // It is possible to trigger mouse events programmatically
    // via EventTarget.dispatchEvent() or jQuery.trigger or Element.click.
    // Such events have the isTrusted property set to false.
    //
    // The isTrusted read-only property of the Event interface is a boolean
    // value that is true when the event was generated by the user agent
    // (including via user actions and programmatic methods such as
    // HTMLElement.focus()), and false when the event was dispatched via
    // EventTarget.dispatchEvent(). The only exception is the click event,
    // which initializes the isTrusted property to false in user agents.
    // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted
    //
    // We want to ignore programmatically triggered events as much as possible
    // to avoid them being misclassified as drags.
    if (!e.originalEvent?.isTrusted) {
        return false;
    }

    // Total distance the mouse has moved since the mouse went down.
    const drag_distance = Math.abs(e.pageX - start_x) + Math.abs(e.pageY - start_y);

    const sel = window.getSelection();
    const has_selection = sel?.type === "Range" && sel.toString().length > 0;

    // A very low drag_distance cutoff (2) can prevent a click after
    // moving the mouse rapidly from registering.
    //
    // So we only use that low cutoff when the drag resulted in
    // actually selecting something, and use a larger distance for
    // non-selection drags, like resizing textareas.
    return drag_distance > 20 || (drag_distance > 2 && has_selection);
}
```

--------------------------------------------------------------------------------

---[FILE: muted_users.ts]---
Location: zulip-main/web/src/muted_users.ts
Signals: Zod

```typescript
import type * as z from "zod/mini";

import * as channel from "./channel.ts";
import type {StateData, muted_user_schema} from "./state_data.ts";
import * as timerender from "./timerender.ts";
import {get_time_from_date_muted} from "./util.ts";

export type RawMutedUser = z.infer<typeof muted_user_schema>;

type MutedUser = {
    id: number;
    date_muted: number;
    date_muted_str: string;
};

const muted_users = new Map<number, number>();

export function add_muted_user(user_id: number, date_muted?: number): void {
    const time = get_time_from_date_muted(date_muted);
    if (user_id) {
        muted_users.set(user_id, time);
    }
}

export function remove_muted_user(user_id: number): void {
    if (user_id) {
        muted_users.delete(user_id);
    }
}

export function is_user_muted(user_id: number): boolean {
    if (user_id === undefined) {
        return false;
    }

    return muted_users.has(user_id);
}

export function filter_muted_user_ids(user_ids: number[]): number[] {
    // Returns a copy of the user ID list, after removing muted user IDs.
    const base_user_ids = [...user_ids];
    return base_user_ids.filter((user_id) => !is_user_muted(user_id));
}

export function filter_muted_users<T extends {user_id: number}>(persons: T[]): T[] {
    // Returns a copy of the people list, after removing muted users.
    const base_users = [...persons];
    return base_users.filter((person) => !is_user_muted(person.user_id));
}

export function get_muted_users(): MutedUser[] {
    const users = [];
    for (const [id, date_muted] of muted_users) {
        const date_muted_str = timerender.render_now(new Date(date_muted)).time_str;
        users.push({
            id,
            date_muted,
            date_muted_str,
        });
    }
    return users;
}

export function set_muted_users(list: RawMutedUser[]): void {
    muted_users.clear();

    for (const user of list) {
        add_muted_user(user.id, user.timestamp);
    }
}

export function mute_user(user_id: number): void {
    void channel.post({
        url: "/json/users/me/muted_users/" + user_id,
    });
}

export function unmute_user(user_id: number): void {
    void channel.del({
        url: "/json/users/me/muted_users/" + user_id,
    });
}

export function initialize(params: StateData["muted_users"]): void {
    set_muted_users(params.muted_users);
}
```

--------------------------------------------------------------------------------

---[FILE: muted_users_ui.ts]---
Location: zulip-main/web/src/muted_users_ui.ts

```typescript
import * as activity_ui from "./activity_ui.ts";
import * as message_lists from "./message_lists.ts";
import * as muted_users from "./muted_users.ts";
import type {RawMutedUser} from "./muted_users.ts";
import * as overlays from "./overlays.ts";
import * as pm_list from "./pm_list.ts";
import * as popovers from "./popovers.ts";
import * as recent_view_ui from "./recent_view_ui.ts";
import * as settings_muted_users from "./settings_muted_users.ts";

export function rerender_for_muted_user(): void {
    for (const msg_list of message_lists.all_rendered_message_lists()) {
        msg_list.update_muting_and_rerender();
    }

    if (overlays.settings_open() && settings_muted_users.loaded) {
        settings_muted_users.populate_list();
    }

    activity_ui.redraw();
    pm_list.update_private_messages();

    // If a user is (un)muted, we want to update their avatars on the Recent Conversations
    // participants column.
    recent_view_ui.complete_rerender();
    // In theory, we might need to do inbox_ui.update here. But
    // because muting a user marks every message the user has sent as
    // read, it will update the inbox UI, if necessary through that
    // mechanism.
}

export function handle_user_updates(raw_muted_users: RawMutedUser[]): void {
    popovers.hide_all();
    muted_users.set_muted_users(raw_muted_users);
    rerender_for_muted_user();
}
```

--------------------------------------------------------------------------------

---[FILE: narrow_banner.ts]---
Location: zulip-main/web/src/narrow_banner.ts

```typescript
import $ from "jquery";
import _ from "lodash";
import assert from "minimalistic-assert";

import * as compose_validate from "./compose_validate.ts";
import type {Filter} from "./filter.ts";
import {$t, $t_html} from "./i18n.ts";
import * as message_lists from "./message_lists.ts";
import type {NarrowBannerData, SearchData} from "./narrow_error.ts";
import {narrow_error} from "./narrow_error.ts";
import {page_params} from "./page_params.ts";
import * as people from "./people.ts";
import * as spectators from "./spectators.ts";
import {realm} from "./state_data.ts";
import * as stream_data from "./stream_data.ts";
import * as util from "./util.ts";

const SPECTATOR_STREAM_NARROW_BANNER = {
    title: "",
    html: $t_html(
        {
            defaultMessage: "This is not a <z-link>publicly accessible</z-link> conversation.",
        },
        {
            "z-link": (content_html) =>
                `<a target="_blank" rel="noopener noreferrer" href="/help/public-access-option">${content_html.join(
                    "",
                )}</a>`,
        },
    ),
};

const MENTIONS_VIEW_EMPTY_BANNER = {
    title: $t({defaultMessage: "This view will show messages where you are mentioned."}),
    html: $t_html(
        {
            defaultMessage:
                "To call attention to a message, you can mention a user, a group, topic participants, or all subscribers to a channel. Type @ in the compose box, and choose who you'd like to mention from the list of suggestions. <z-link>Learn more</z-link>",
        },
        {
            "z-link": (content_html) =>
                `<a target="_blank" rel="noopener noreferrer" href="/help/mention-a-user-or-group">${content_html.join(
                    "",
                )}</a>`,
        },
    ),
};

const STARRED_MESSAGES_VIEW_EMPTY_BANNER = {
    title: $t({defaultMessage: "You have no starred messages."}),
    html: $t_html(
        {
            defaultMessage:
                "Starring messages is a good way to keep track of important messages, such as tasks you need to go back to, or useful references. To star a message, hover over a message and click the <star-icon></star-icon>. <z-link>Learn more</z-link>",
        },
        {
            "star-icon": () => `<i class="zulip-icon zulip-icon-star" aria-hidden="true"></i>`,
            "z-link": (content_html) =>
                `<a target="_blank" rel="noopener noreferrer" href="/help/star-a-message">${content_html.join(
                    "",
                )}</a>`,
        },
    ),
};

const MUTED_TOPICS_IN_CHANNEL_EMPTY_BANNER = {
    title: $t({
        defaultMessage: "You have muted all the topics in this channel.",
    }),
    html: $t_html(
        {
            defaultMessage:
                "To view a muted topic, click <b>show all topics</b> in the left sidebar, and select one from the list. <z-link>Learn more</z-link>",
        },
        {
            "z-link": (content_html) =>
                `<a target="_blank" rel="noopener noreferrer" href="/help/mute-a-topic">${content_html.join("")}</a>`,
        },
    ),
};

const NO_SEARCH_RESULTS_TITLE = $t({defaultMessage: "No search results."});

function empty_search_query_banner(current_filter: Filter): NarrowBannerData {
    const search_query = current_filter.terms_with_operator("search")[0]!.operand;
    const query_words = search_query.split(" ");

    const search_string_result: SearchData = {
        query_words: [],
        has_stop_word: false,
    };

    // Gather information about each query word
    for (const query_word of query_words) {
        if (realm.stop_words.includes(query_word)) {
            search_string_result.has_stop_word = true;
            search_string_result.query_words.push({
                query_word,
                is_stop_word: true,
            });
        } else {
            search_string_result.query_words.push({
                query_word,
                is_stop_word: false,
            });
        }
    }

    // We only show description of search query
    // when there are excluded stop words.
    if (search_string_result.has_stop_word) {
        return {
            title: NO_SEARCH_RESULTS_TITLE,
            search_data: search_string_result,
        };
    }
    return {title: NO_SEARCH_RESULTS_TITLE};
}

export function pick_empty_narrow_banner(current_filter: Filter): NarrowBannerData {
    const default_banner = {
        title: $t({defaultMessage: "There are no messages here."}),
        // Spectators cannot start a conversation.
        html: page_params.is_spectator
            ? ""
            : $t_html(
                  {
                      defaultMessage: "Why not <z-link>start the conversation</z-link>?",
                  },
                  {
                      "z-link": (content_html) =>
                          `<a href="#" class="empty_feed_compose_stream">${content_html.join(
                              "",
                          )}</a>`,
                  },
              ),
    };

    if (current_filter.is_in_home()) {
        // We're in the combined feed view.
        return {
            title: $t({defaultMessage: "There are no messages in your combined feed."}),
            html: page_params.is_spectator
                ? ""
                : $t_html(
                      {
                          defaultMessage:
                              "Would you like to <z-link>view messages in all public channels</z-link>?",
                      },
                      {
                          "z-link": (content_html) =>
                              `<a href="#narrow/channels/public">${content_html.join("")}</a>`,
                      },
                  ),
        };
    }

    const first_term = current_filter.terms()[0]!;
    const current_terms_types = current_filter.sorted_term_types();
    const num_terms = current_filter.terms().length;

    if (num_terms !== 1) {
        // For invalid-multi-operator narrows, we display an invalid narrow message
        const streams = current_filter.terms_with_operator("channel");
        const topics = current_filter.terms_with_operator("topic");

        // No message can have multiple streams
        if (streams.length > 1) {
            return {
                title: NO_SEARCH_RESULTS_TITLE,
                html: $t_html({
                    defaultMessage:
                        "<p>You are searching for messages that belong to more than one channel, which is not possible.</p>",
                }),
            };
        }
        // No message can have multiple topics
        if (topics.length > 1) {
            return {
                title: NO_SEARCH_RESULTS_TITLE,
                html: $t_html({
                    defaultMessage:
                        "<p>You are searching for messages that belong to more than one topic, which is not possible.</p>",
                }),
            };
        }
        // No message can have multiple senders
        if (current_filter.terms_with_operator("sender").length > 1) {
            return {
                title: NO_SEARCH_RESULTS_TITLE,
                html: $t_html({
                    defaultMessage:
                        "<p>You are searching for messages that are sent by more than one person, which is not possible.</p>",
                }),
            };
        }

        // For empty search queries, we display excluded stop words
        if (current_filter.terms_with_operator("search").length > 0) {
            return empty_search_query_banner(current_filter);
        }

        if (
            page_params.is_spectator &&
            first_term.operator === "channel" &&
            !stream_data.is_web_public_by_stream_id(Number.parseInt(first_term.operand, 10))
        ) {
            // For non web-public streams, show `login_to_access` modal.
            spectators.login_to_access(true);
            return SPECTATOR_STREAM_NARROW_BANNER;
        }

        if (streams.length === 1) {
            const stream_sub = stream_data.get_sub_by_id_string(
                util.the(current_filter.terms_with_operator("channel")).operand,
            );
            if (!stream_sub) {
                return {
                    title: $t({
                        defaultMessage:
                            "This channel doesn't exist, or you are not allowed to view it.",
                    }),
                };
            }
        }

        // A valid stream, but a topic that doesn't exist yet.
        if (num_terms === 2 && streams.length === 1 && topics.length === 1) {
            return default_banner;
        }

        if (
            _.isEqual(current_terms_types, ["sender", "has-reaction"]) &&
            current_filter.terms_with_operator("sender")[0]!.operand === people.my_current_email()
        ) {
            return {
                title: $t({defaultMessage: "None of your messages have emoji reactions yet."}),
                html: $t_html(
                    {
                        defaultMessage: "Learn more about emoji reactions <z-link>here</z-link>.",
                    },
                    {
                        "z-link": (content_html) =>
                            `<a target="_blank" rel="noopener noreferrer" href="/help/emoji-reactions">${content_html.join(
                                "",
                            )}</a>`,
                    },
                ),
            };
        }

        // For other multi-operator narrows, we just use the default banner
        return {
            title: NO_SEARCH_RESULTS_TITLE,
        };
    }

    switch (first_term.operator) {
        case "is":
            switch (first_term.operand) {
                case "starred":
                    return STARRED_MESSAGES_VIEW_EMPTY_BANNER;
                case "mentioned":
                    return MENTIONS_VIEW_EMPTY_BANNER;
                case "dm":
                    // You have no direct messages.
                    return {
                        title: $t({defaultMessage: "You have no direct messages yet!"}),
                        html: $t_html(
                            {
                                defaultMessage: "Why not <z-link>start the conversation</z-link>?",
                            },
                            {
                                // TODO: The href here is a bit weird; we probably want to migrate
                                // this to a button element down the line.
                                "z-link": (content_html) =>
                                    `<a href="#" class="empty_feed_compose_private">${content_html.join(
                                        "",
                                    )}</a>`,
                            },
                        ),
                    };
                case "unread":
                    // You have no unread messages.
                    return {
                        title: $t({defaultMessage: "You have no unread messages!"}),
                    };
                case "resolved":
                    return {
                        title: $t({defaultMessage: "No topics are marked as resolved."}),
                    };
                case "followed":
                    return {
                        title: $t({defaultMessage: "You aren't following any topics."}),
                    };

                case "muted":
                    return {
                        title: $t({
                            defaultMessage: "You have no messages in muted topics and channels.",
                        }),
                    };
            }
            // fallthrough to default case if no match is found
            break;
        case "channel": {
            const stream_sub = stream_data.get_sub_by_id_string(first_term.operand);
            if (!stream_sub?.subscribed) {
                // You are narrowed to a channel that either does not exist,
                // is private, or a channel you're not currently subscribed to.
                if (page_params.is_spectator) {
                    spectators.login_to_access(true);
                    return SPECTATOR_STREAM_NARROW_BANNER;
                }
                if (stream_sub) {
                    if (stream_data.can_toggle_subscription(stream_sub)) {
                        // You have content access to the channel, and therefore
                        // can subscribe to the channel.
                        return default_banner;
                    }
                    if (stream_sub.invite_only) {
                        // You don't have content access to this private channel.
                        return {
                            title: $t({
                                defaultMessage:
                                    "You are not allowed to view messages in this private channel.",
                            }),
                        };
                    }
                }
                return {
                    title: $t({
                        defaultMessage:
                            "This channel doesn't exist, or you are not allowed to view it.",
                    }),
                };
            }
            assert(message_lists.current !== undefined);
            if (message_lists.current.visibly_empty() && !message_lists.current.empty()) {
                // The current message list appears empty, but there are
                // messages in muted topics.
                return MUTED_TOPICS_IN_CHANNEL_EMPTY_BANNER;
            }
            // else fallthrough to default case
            break;
        }
        case "search": {
            // You are narrowed to empty search results.
            return empty_search_query_banner(current_filter);
        }
        case "dm": {
            if (!people.is_valid_bulk_emails_for_compose(first_term.operand.split(","))) {
                if (!first_term.operand.includes(",")) {
                    return {
                        title: $t({defaultMessage: "This user does not exist!"}),
                    };
                }
                return {
                    title: $t({defaultMessage: "One or more of these users do not exist!"}),
                };
            }
            const user_ids = people.emails_strings_to_user_ids_array(first_term.operand);
            assert(user_ids?.[0] !== undefined);
            const user_ids_string = util.sorted_ids(user_ids).join(",");
            const direct_message_error_string =
                compose_validate.check_dm_permissions_and_get_error_string(user_ids_string);
            if (direct_message_error_string) {
                return {
                    title: direct_message_error_string,
                    html: $t_html(
                        {
                            defaultMessage: "<z-link>Learn more.</z-link>",
                        },
                        {
                            "z-link": (content_html) =>
                                `<a target="_blank" rel="noopener noreferrer" href="/help/restrict-direct-messages">${content_html.join("")}</a>`,
                        },
                    ),
                };
            }
            if (!first_term.operand.includes(",")) {
                const recipient_user = people.get_by_user_id(user_ids[0]);
                // You have no direct messages with this person
                if (people.is_my_user_id(recipient_user.user_id)) {
                    return {
                        title: $t({
                            defaultMessage: "You haven't sent yourself any notes yet!",
                        }),
                        html: $t_html({
                            defaultMessage:
                                "Use this space for personal notes, or to test out Zulip features.",
                        }),
                    };
                }
                // If the recipient is deactivated, we cannot start the conversation.
                if (!people.is_person_active(recipient_user.user_id)) {
                    return {
                        title: $t(
                            {
                                defaultMessage: "You have no direct messages with {person}.",
                            },
                            {person: recipient_user.full_name},
                        ),
                    };
                }
                return {
                    title: $t(
                        {
                            defaultMessage: "You have no direct messages with {person} yet.",
                        },
                        {person: recipient_user.full_name},
                    ),
                    html: $t_html(
                        {
                            defaultMessage: "Why not <z-link>start the conversation</z-link>?",
                        },
                        {
                            "z-link": (content_html) =>
                                `<a href="#" class="empty_feed_compose_private">${content_html.join(
                                    "",
                                )}</a>`,
                        },
                    ),
                };
            }
            if (people.get_non_active_user_ids_count(user_ids) !== 0) {
                return {
                    title: $t({defaultMessage: "You have no direct messages with these users."}),
                };
            }
            return {
                title: $t({defaultMessage: "You have no direct messages with these users yet."}),
                html: $t_html(
                    {
                        defaultMessage: "Why not <z-link>start the conversation</z-link>?",
                    },
                    {
                        "z-link": (content_html) =>
                            `<a href="#" class="empty_feed_compose_private">${content_html.join(
                                "",
                            )}</a>`,
                    },
                ),
            };
        }
        case "sender": {
            const sender = people.get_by_email(first_term.operand);
            if (sender) {
                return {
                    title: $t(
                        {
                            defaultMessage:
                                "You haven't received any messages sent by {person} yet.",
                        },
                        {person: sender.full_name},
                    ),
                };
            }
            return {
                title: $t({
                    defaultMessage:
                        "This user doesn't exist, or you are not allowed to view any of their messages.",
                }),
            };
        }
        case "dm-including": {
            const people_in_dms = first_term.operand
                .split(",")
                .map((email) => people.get_by_email(email));
            if (people_in_dms.length === 1 && !people_in_dms[0]) {
                return {
                    title: $t({defaultMessage: "This user does not exist!"}),
                };
            }
            const valid_people_in_dms: people.User[] = [];
            for (const user of people_in_dms.values()) {
                if (user === undefined) {
                    return {
                        // We intentionally give the same non-specific
                        // error message as the single user case,
                        // since we don't display API email addresses
                        // or user IDs typically in UI errors, and we
                        // don't have any other handle as to which
                        // user this was supposed to be.
                        title: $t({defaultMessage: "This user does not exist!"}),
                    };
                }
                valid_people_in_dms.push(user);
            }
            const person_id_string = valid_people_in_dms.map((user) => user.user_id).join(",");
            const direct_message_error_string =
                compose_validate.check_dm_permissions_and_get_error_string(person_id_string);
            if (direct_message_error_string) {
                return {
                    title: direct_message_error_string,
                    html: $t_html(
                        {
                            defaultMessage: "<z-link>Learn more.</z-link>",
                        },
                        {
                            "z-link": (content_html) =>
                                `<a target="_blank" rel="noopener noreferrer" href="/help/restrict-direct-messages">${content_html.join("")}</a>`,
                        },
                    ),
                };
            }
            if (
                valid_people_in_dms.length === 1 &&
                people.is_my_user_id(valid_people_in_dms[0]!.user_id)
            ) {
                return {
                    title: $t({
                        defaultMessage: "You don't have any direct message conversations yet.",
                    }),
                };
            }
            return {
                title: $t(
                    {
                        defaultMessage: "You have no direct messages including {people} yet.",
                    },
                    {people: valid_people_in_dms.map((user) => user.full_name).join(", ")},
                ),
            };
        }
    }
    return default_banner;
}

export function show_empty_narrow_message(current_filter: Filter): void {
    $(".empty_feed_notice_main").empty();
    const rendered_narrow_banner = narrow_error(pick_empty_narrow_banner(current_filter));
    $(".empty_feed_notice_main").html(rendered_narrow_banner);
}

export function hide_empty_narrow_message(): void {
    $(".empty_feed_notice_main").empty();
}
```

--------------------------------------------------------------------------------

---[FILE: narrow_error.ts]---
Location: zulip-main/web/src/narrow_error.ts

```typescript
import render_empty_feed_notice from "../templates/empty_feed_notice.hbs";

type QueryWord = {
    query_word: string;
    is_stop_word: boolean;
};

export type SearchData = {
    query_words: QueryWord[];
    has_stop_word: boolean;
};

export type NarrowBannerData = {
    title: string;
    html?: string;
    search_data?: SearchData;
};

export function narrow_error(narrow_banner_data: NarrowBannerData): string {
    const title = narrow_banner_data.title;
    const notice_html = narrow_banner_data.html;
    const search_data = narrow_banner_data.search_data;

    const empty_feed_notice = render_empty_feed_notice({title, notice_html, search_data});
    return empty_feed_notice;
}
```

--------------------------------------------------------------------------------

---[FILE: narrow_history.ts]---
Location: zulip-main/web/src/narrow_history.ts

```typescript
import _ from "lodash";
import assert from "minimalistic-assert";

import * as browser_history from "./browser_history.ts";
import type {Filter} from "./filter.ts";
import * as hash_util from "./hash_util.ts";
import * as message_lists from "./message_lists.ts";
import * as narrow_state from "./narrow_state.ts";

function is_URL_hash_same_as_filter_hash(filter: Filter): boolean {
    if (filter.is_in_home()) {
        if (window.location.hash === "#feed") {
            return true;
        }

        if (window.location.hash === "") {
            return browser_history.get_home_view_hash() === "#feed";
        }
    }

    const hash_from_filter = hash_util.search_terms_to_hash(filter.terms());
    return window.location.hash === hash_from_filter;
}

// Saves the selected message of the narrow in the browser
// history, so that we are able to restore it if the user
// navigates back to this page.
function _save_narrow_state(): void {
    if (message_lists.current === undefined) {
        return;
    }

    const current_filter = narrow_state.filter();
    assert(current_filter !== undefined);
    // Only save state if the URL hash matches the filter terms.
    if (!is_URL_hash_same_as_filter_hash(current_filter)) {
        return;
    }

    const narrow_pointer = message_lists.current.selected_id();
    if (narrow_pointer === -1) {
        return;
    }
    const $narrow_row = message_lists.current.selected_row();
    if ($narrow_row.length === 0) {
        return;
    }
    const narrow_offset = $narrow_row.get_offset_to_window().top;
    const narrow_data = {
        narrow_pointer,
        narrow_offset,
    };
    browser_history.update_current_history_state_data(narrow_data);
}

// Safari limits you to 100 replaceState calls in 30 seconds.
export const save_narrow_state = _.throttle(_save_narrow_state, 500);

// This causes the save to happen right away.
export function save_narrow_state_and_flush(): void {
    save_narrow_state();
    save_narrow_state.flush();
}
```

--------------------------------------------------------------------------------

````
