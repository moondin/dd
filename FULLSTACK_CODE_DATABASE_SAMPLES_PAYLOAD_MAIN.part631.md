---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:13Z
part: 631
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 631 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: payload-types.ts]---
Location: payload-main/test/plugin-cloud-storage/payload-types.ts

```typescript
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:types` to regenerate this file.
 */

/**
 * Supported timezones in IANA format.
 *
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "supportedTimezones".
 */
export type SupportedTimezones =
  | 'Pacific/Midway'
  | 'Pacific/Niue'
  | 'Pacific/Honolulu'
  | 'Pacific/Rarotonga'
  | 'America/Anchorage'
  | 'Pacific/Gambier'
  | 'America/Los_Angeles'
  | 'America/Tijuana'
  | 'America/Denver'
  | 'America/Phoenix'
  | 'America/Chicago'
  | 'America/Guatemala'
  | 'America/New_York'
  | 'America/Bogota'
  | 'America/Caracas'
  | 'America/Santiago'
  | 'America/Buenos_Aires'
  | 'America/Sao_Paulo'
  | 'Atlantic/South_Georgia'
  | 'Atlantic/Azores'
  | 'Atlantic/Cape_Verde'
  | 'Europe/London'
  | 'Europe/Berlin'
  | 'Africa/Lagos'
  | 'Europe/Athens'
  | 'Africa/Cairo'
  | 'Europe/Moscow'
  | 'Asia/Riyadh'
  | 'Asia/Dubai'
  | 'Asia/Baku'
  | 'Asia/Karachi'
  | 'Asia/Tashkent'
  | 'Asia/Calcutta'
  | 'Asia/Dhaka'
  | 'Asia/Almaty'
  | 'Asia/Jakarta'
  | 'Asia/Bangkok'
  | 'Asia/Shanghai'
  | 'Asia/Singapore'
  | 'Asia/Tokyo'
  | 'Asia/Seoul'
  | 'Australia/Brisbane'
  | 'Australia/Sydney'
  | 'Pacific/Guam'
  | 'Pacific/Noumea'
  | 'Pacific/Auckland'
  | 'Pacific/Fiji';

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  blocks: {};
  collections: {
    media: Media;
    'media-with-prefix': MediaWithPrefix;
    users: User;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsJoins: {};
  collectionsSelect: {
    media: MediaSelect<false> | MediaSelect<true>;
    'media-with-prefix': MediaWithPrefixSelect<false> | MediaWithPrefixSelect<true>;
    users: UsersSelect<false> | UsersSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: null;
  user: User & {
    collection: 'users';
  };
  jobs: {
    tasks: unknown;
    workflows: unknown;
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media".
 */
export interface Media {
  id: string;
  alt?: string | null;
  updatedAt: string;
  createdAt: string;
  url?: string | null;
  thumbnailURL?: string | null;
  filename?: string | null;
  mimeType?: string | null;
  filesize?: number | null;
  width?: number | null;
  height?: number | null;
  focalX?: number | null;
  focalY?: number | null;
  sizes?: {
    square?: {
      url?: string | null;
      width?: number | null;
      height?: number | null;
      mimeType?: string | null;
      filesize?: number | null;
      filename?: string | null;
    };
    sixteenByNineMedium?: {
      url?: string | null;
      width?: number | null;
      height?: number | null;
      mimeType?: string | null;
      filesize?: number | null;
      filename?: string | null;
    };
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media-with-prefix".
 */
export interface MediaWithPrefix {
  id: string;
  prefix?: string | null;
  updatedAt: string;
  createdAt: string;
  url?: string | null;
  thumbnailURL?: string | null;
  filename?: string | null;
  mimeType?: string | null;
  filesize?: number | null;
  width?: number | null;
  height?: number | null;
  focalX?: number | null;
  focalY?: number | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  password?: string | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'media';
        value: string | Media;
      } | null)
    | ({
        relationTo: 'media-with-prefix';
        value: string | MediaWithPrefix;
      } | null)
    | ({
        relationTo: 'users';
        value: string | User;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media_select".
 */
export interface MediaSelect<T extends boolean = true> {
  alt?: T;
  updatedAt?: T;
  createdAt?: T;
  url?: T;
  thumbnailURL?: T;
  filename?: T;
  mimeType?: T;
  filesize?: T;
  width?: T;
  height?: T;
  focalX?: T;
  focalY?: T;
  sizes?:
    | T
    | {
        square?:
          | T
          | {
              url?: T;
              width?: T;
              height?: T;
              mimeType?: T;
              filesize?: T;
              filename?: T;
            };
        sixteenByNineMedium?:
          | T
          | {
              url?: T;
              width?: T;
              height?: T;
              mimeType?: T;
              filesize?: T;
              filename?: T;
            };
      };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media-with-prefix_select".
 */
export interface MediaWithPrefixSelect<T extends boolean = true> {
  prefix?: T;
  updatedAt?: T;
  createdAt?: T;
  url?: T;
  thumbnailURL?: T;
  filename?: T;
  mimeType?: T;
  filesize?: T;
  width?: T;
  height?: T;
  focalX?: T;
  focalY?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
```

--------------------------------------------------------------------------------

---[FILE: shared.ts]---
Location: payload-main/test/plugin-cloud-storage/shared.ts

```typescript
export const mediaSlug = 'media'
export const mediaWithPrefixSlug = 'media-with-prefix'
export const prefix = 'test-prefix'
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/plugin-cloud-storage/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.json]---
Location: payload-main/test/plugin-cloud-storage/tsconfig.json

```json
{
  "extends": "../tsconfig.json"
}
```

--------------------------------------------------------------------------------

---[FILE: utils.ts]---
Location: payload-main/test/plugin-cloud-storage/utils.ts

```typescript
import * as AWS from '@aws-sdk/client-s3'

const getS3Client = () => {
  return new AWS.S3({
    endpoint: process.env.S3_ENDPOINT,
    forcePathStyle: process.env.S3_FORCE_PATH_STYLE === 'true',
    region: process.env.S3_REGION,
    credentials: {
      accessKeyId: process.env.S3_ACCESS_KEY_ID,
      secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,
    },
  })
}

export async function createTestBucket(bucketName?: string) {
  const client = getS3Client()
  const makeBucketRes = await client.send(
    new AWS.CreateBucketCommand({ Bucket: bucketName || process.env.S3_BUCKET }),
  )

  if (makeBucketRes.$metadata.httpStatusCode !== 200) {
    throw new Error(`Failed to create bucket. ${makeBucketRes.$metadata.httpStatusCode}`)
  }
}

export async function clearTestBucket(client: AWS.S3Client, bucketName?: string) {
  const listedObjects = await client.send(
    new AWS.ListObjectsV2Command({
      Bucket: bucketName || process.env.S3_BUCKET,
    }),
  )

  if (!listedObjects?.Contents?.length) return

  const deleteParams = {
    Bucket: bucketName || process.env.S3_BUCKET,
    Delete: { Objects: [] },
  }

  listedObjects.Contents.forEach(({ Key }) => {
    deleteParams.Delete.Objects.push({ Key })
  })

  const deleteResult = await client.send(new AWS.DeleteObjectsCommand(deleteParams))
  if (deleteResult.Errors?.length) {
    throw new Error(JSON.stringify(deleteResult.Errors))
  }
}
```

--------------------------------------------------------------------------------

---[FILE: Media.ts]---
Location: payload-main/test/plugin-cloud-storage/collections/Media.ts

```typescript
import type { CollectionConfig } from 'payload'

export const Media: CollectionConfig = {
  slug: 'media',
  upload: {
    disableLocalStorage: true,
    resizeOptions: {
      position: 'center',
      width: 200,
      height: 200,
    },
    imageSizes: [
      {
        height: 400,
        width: 400,
        crop: 'center',
        name: 'square',
      },
      {
        width: 900,
        height: 450,
        crop: 'center',
        name: 'sixteenByNineMedium',
      },
    ],
  },
  fields: [
    {
      name: 'alt',
      label: 'Alt Text',
      type: 'text',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: MediaWithPrefix.ts]---
Location: payload-main/test/plugin-cloud-storage/collections/MediaWithPrefix.ts

```typescript
import type { CollectionConfig } from 'payload'

export const MediaWithPrefix: CollectionConfig = {
  slug: 'media-with-prefix',
  upload: {
    disableLocalStorage: true,
  },
  fields: [],
}
```

--------------------------------------------------------------------------------

---[FILE: Users.ts]---
Location: payload-main/test/plugin-cloud-storage/collections/Users.ts

```typescript
import type { CollectionConfig } from 'payload'

export const Users: CollectionConfig = {
  slug: 'users',
  auth: true,
  admin: {
    useAsTitle: 'email',
  },
  access: {
    read: () => true,
  },
  fields: [
    // Email added by default
    // Add more fields as needed
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: .gitignore]---
Location: payload-main/test/plugin-ecommerce/.gitignore

```text
app/(payload)/admin/importMap.js
/app/(payload)/admin/importMap.js
```

--------------------------------------------------------------------------------

---[FILE: config.ts]---
Location: payload-main/test/plugin-ecommerce/config.ts

```typescript
import { fileURLToPath } from 'node:url'
import path from 'path'
const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

import { ecommercePlugin, EUR, USD } from '@payloadcms/plugin-ecommerce'
import { stripeAdapter } from '@payloadcms/plugin-ecommerce/payments/stripe'

import type { EcommercePluginConfig } from '../../packages/plugin-ecommerce/src/types.js'

import { buildConfigWithDefaults } from '../buildConfigWithDefaults.js'
import { devUser } from '../credentials.js'
import { Media } from './collections/Media.js'
import { Users } from './collections/Users.js'
import { seed } from './seed/index.js'

export const currenciesConfig: NonNullable<EcommercePluginConfig['currencies']> = {
  supportedCurrencies: [
    USD,
    EUR,
    {
      code: 'JPY',
      decimals: 0,
      label: 'Japanese Yen',
      symbol: 'Â¥',
    },
  ],
  defaultCurrency: 'USD',
}

export default buildConfigWithDefaults({
  collections: [Users, Media],
  admin: {
    importMap: {
      baseDir: path.resolve(dirname),
    },
  },
  maxDepth: 10,
  onInit: async (payload) => {
    await payload.create({
      collection: 'users',
      data: {
        email: devUser.email,
        password: devUser.password,
      },
    })

    await seed(payload)
  },
  jobs: {
    autoRun: undefined,
  },
  plugins: [
    ecommercePlugin({
      access: {
        adminOnlyFieldAccess: ({ req }) => Boolean(req.user),
        adminOrPublishedStatus: ({ req }) => {
          if (req.user) {
            return true
          }

          return {
            _status: {
              equals: 'published',
            },
          }
        },
        customerOnlyFieldAccess: ({ req }) => Boolean(req.user),
        isAdmin: ({ req }) => Boolean(req.user),
        isAuthenticated: ({ req }) => Boolean(req.user),
        isCustomer: ({ req }) => Boolean(req.user),
        isDocumentOwner: ({ req }) => {
          if (req.user) {
            return {
              customer: {
                equals: req.user.id,
              },
            }
          }
          return false
        },
      },
      carts: {
        allowGuestCarts: true,
      },
      customers: {
        slug: 'users',
      },
      products: {
        variants: true,
      },
      payments: {
        paymentMethods: [
          stripeAdapter({
            secretKey: process.env.STRIPE_SECRET_KEY!,
            publishableKey: process.env.STRIPE_PUBLISHABLE_KEY!,
            webhookSecret: process.env.STRIPE_WEBHOOKS_SECRET!,
            webhooks: {
              'payment_intent.succeeded': ({ event, req }) => {
                console.log({ event, data: event.data.object })
                req.payload.logger.info('Payment succeeded')
              },
            },
          }),
        ],
      },
      currencies: currenciesConfig,
    }),
  ],
  typescript: {
    outputFile: path.resolve(dirname, 'payload-types.ts'),
  },
})
```

--------------------------------------------------------------------------------

---[FILE: int.spec.ts]---
Location: payload-main/test/plugin-ecommerce/int.spec.ts

```typescript
import path from 'path'
import { type Payload } from 'payload'
import { fileURLToPath } from 'url'

import type { NextRESTClient } from '../helpers/NextRESTClient.js'

import { initPayloadInt } from '../helpers/initPayloadInt.js'

let payload: Payload
let restClient: NextRESTClient

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

describe('ecommerce', () => {
  beforeAll(async () => {
    ;({ payload, restClient } = await initPayloadInt(dirname))
  })

  afterAll(async () => {
    if (typeof payload.db.destroy === 'function') {
      await payload.db.destroy()
    }
  })

  it('should add a variants collection', async () => {
    const variants = await payload.find({
      collection: 'variants',
      depth: 0,
      limit: 1,
    })

    expect(variants).toBeTruthy()
  })

  describe('guest cart access', () => {
    it('should allow guest users to create carts', async () => {
      // Create a cart without authentication
      const cartResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      expect(cartResponse).toBeTruthy()
      expect(cartResponse.doc.id).toBeTruthy()
      expect(cartResponse.doc.secret).toBeTruthy() // Secret should be returned on creation
    })

    it('should allow access to cart with valid secret', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id
      const cartSecret = createResponse.doc.secret

      // Read the cart with the secret
      const readResponse = await restClient
        .GET(`/carts/${cartId}?secret=${cartSecret}`, { auth: false })
        .then((res) => res.json())

      expect(readResponse).toBeTruthy()
      expect(readResponse.id).toBe(cartId)
      expect(readResponse.secret).toBeUndefined() // Secret should NOT be returned on subsequent reads
    })

    it('should allow updating cart with valid secret', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id
      const cartSecret = createResponse.doc.secret

      // Update the cart with the secret
      const updateResponse = await restClient
        .PATCH(`/carts/${cartId}?secret=${cartSecret}`, {
          auth: false,
          body: JSON.stringify({
            purchasedAt: new Date().toISOString(),
          }),
        })
        .then((res) => res.json())

      expect(updateResponse).toBeTruthy()
      expect(updateResponse.doc.id).toBe(cartId)
      expect(updateResponse.doc.purchasedAt).toBeTruthy()
    })

    it('should allow deleting cart with valid secret', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id
      const cartSecret = createResponse.doc.secret

      // Delete the cart with the secret
      const deleteResponse = await restClient
        .DELETE(`/carts/${cartId}?secret=${cartSecret}`, { auth: false })
        .then((res) => res.json())

      expect(deleteResponse).toBeTruthy()
    })

    it('should deny access without valid secret', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id

      // Try to read the cart without the secret
      const readResponse = await restClient.GET(`/carts/${cartId}`, { auth: false })

      // Should return 403 Forbidden since access is denied
      expect(readResponse.status).toBe(403)
    })

    it('should deny access with incorrect secret', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id

      // Try to read the cart with an incorrect secret
      const readResponse = await restClient.GET(`/carts/${cartId}?secret=incorrect-secret`, {
        auth: false,
      })

      expect(readResponse.status).toBe(404)
    })

    it('should not expose secret field directly', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id
      const cartSecret = createResponse.doc.secret

      // Try to read only the secret field
      const readResponse = await restClient
        .GET(`/carts/${cartId}?select=secret&secret=${cartSecret}`, { auth: false })
        .then((res) => res.json())

      // Secret should not be included even with select query
      expect(readResponse.secret).toBeUndefined()
    })

    it('should deny creating cart with custom secret', async () => {
      // Try to create a cart with a custom secret
      const createResponse = await restClient.POST('/carts', {
        auth: false,
        body: JSON.stringify({
          items: [],
          secret: 'custom-secret',
        }),
      })

      const result = await createResponse.json()

      // The custom secret should be rejected by field access control
      expect(result.doc.secret).not.toBe('custom-secret')
    })

    it('should deny updating secret field', async () => {
      // Create a cart without authentication
      const createResponse = await restClient
        .POST('/carts', {
          auth: false,
          body: JSON.stringify({
            items: [],
          }),
        })
        .then((res) => res.json())

      const cartId = createResponse.doc.id
      const cartSecret = createResponse.doc.secret

      // Try to update the secret
      const updateResponse = await restClient
        .PATCH(`/carts/${cartId}?secret=${cartSecret}`, {
          auth: false,
          body: JSON.stringify({
            secret: 'new-secret',
          }),
        })
        .then((res) => res.json())

      // Secret should not have been updated
      expect(updateResponse.doc.secret).toBeUndefined()

      // Verify cart is still accessible with original secret
      const verifyResponse = await restClient
        .GET(`/carts/${cartId}?secret=${cartSecret}`, { auth: false })
        .then((res) => res.json())

      expect(verifyResponse.id).toBe(cartId)
    })
  })
})
```

--------------------------------------------------------------------------------

---[FILE: next-env.d.ts]---
Location: payload-main/test/plugin-ecommerce/next-env.d.ts

```typescript
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
```

--------------------------------------------------------------------------------

---[FILE: next.config.mjs]---
Location: payload-main/test/plugin-ecommerce/next.config.mjs

```text
import nextConfig from '../../next.config.mjs'

import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(__filename)

export default {
  ...nextConfig,
  env: {
    PAYLOAD_CORE_DEV: 'true',
    ROOT_DIR: path.resolve(dirname),
  },
}
```

--------------------------------------------------------------------------------

---[FILE: payload-types.ts]---
Location: payload-main/test/plugin-ecommerce/payload-types.ts

```typescript
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:types` to regenerate this file.
 */

/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "OrderStatus".
 */
export type OrderStatus = ('processing' | 'completed' | 'cancelled' | 'refunded') | null;
/**
 * Supported timezones in IANA format.
 *
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "supportedTimezones".
 */
export type SupportedTimezones =
  | 'Pacific/Midway'
  | 'Pacific/Niue'
  | 'Pacific/Honolulu'
  | 'Pacific/Rarotonga'
  | 'America/Anchorage'
  | 'Pacific/Gambier'
  | 'America/Los_Angeles'
  | 'America/Tijuana'
  | 'America/Denver'
  | 'America/Phoenix'
  | 'America/Chicago'
  | 'America/Guatemala'
  | 'America/New_York'
  | 'America/Bogota'
  | 'America/Caracas'
  | 'America/Santiago'
  | 'America/Buenos_Aires'
  | 'America/Sao_Paulo'
  | 'Atlantic/South_Georgia'
  | 'Atlantic/Azores'
  | 'Atlantic/Cape_Verde'
  | 'Europe/London'
  | 'Europe/Berlin'
  | 'Africa/Lagos'
  | 'Europe/Athens'
  | 'Africa/Cairo'
  | 'Europe/Moscow'
  | 'Asia/Riyadh'
  | 'Asia/Dubai'
  | 'Asia/Baku'
  | 'Asia/Karachi'
  | 'Asia/Tashkent'
  | 'Asia/Calcutta'
  | 'Asia/Dhaka'
  | 'Asia/Almaty'
  | 'Asia/Jakarta'
  | 'Asia/Bangkok'
  | 'Asia/Shanghai'
  | 'Asia/Singapore'
  | 'Asia/Tokyo'
  | 'Asia/Seoul'
  | 'Australia/Brisbane'
  | 'Australia/Sydney'
  | 'Pacific/Guam'
  | 'Pacific/Noumea'
  | 'Pacific/Auckland'
  | 'Pacific/Fiji';

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  blocks: {};
  collections: {
    users: User;
    media: Media;
    variants: Variant;
    variantTypes: VariantType;
    variantOptions: VariantOption;
    products: Product;
    orders: Order;
    transactions: Transaction;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsJoins: {
    variantTypes: {
      options: 'variantOptions';
    };
    products: {
      variants: 'variants';
    };
  };
  collectionsSelect: {
    users: UsersSelect<false> | UsersSelect<true>;
    media: MediaSelect<false> | MediaSelect<true>;
    variants: VariantsSelect<false> | VariantsSelect<true>;
    variantTypes: VariantTypesSelect<false> | VariantTypesSelect<true>;
    variantOptions: VariantOptionsSelect<false> | VariantOptionsSelect<true>;
    products: ProductsSelect<false> | ProductsSelect<true>;
    orders: OrdersSelect<false> | OrdersSelect<true>;
    transactions: TransactionsSelect<false> | TransactionsSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: null;
  user: User & {
    collection: 'users';
  };
  jobs: {
    tasks: unknown;
    workflows: unknown;
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  password?: string | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media".
 */
export interface Media {
  id: string;
  updatedAt: string;
  createdAt: string;
  url?: string | null;
  thumbnailURL?: string | null;
  filename?: string | null;
  mimeType?: string | null;
  filesize?: number | null;
  width?: number | null;
  height?: number | null;
  focalX?: number | null;
  focalY?: number | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variants".
 */
export interface Variant {
  id: string;
  /**
   * Used for administrative purposes, not shown to customers. This is populated by default.
   */
  title?: string | null;
  /**
   * this should not be editable, or at least, should be able to be pre-filled via default
   */
  product: string | Product;
  options: (string | VariantOption)[];
  inventory: number;
  priceInUSDEnabled?: boolean | null;
  priceInUSD?: number | null;
  priceInJPYEnabled?: boolean | null;
  priceInJPY?: number | null;
  priceInEUREnabled?: boolean | null;
  priceInEUR?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "products".
 */
export interface Product {
  id: string;
  name?: string | null;
  enableVariants?: boolean | null;
  variantTypes?: (string | VariantType)[] | null;
  variants?: {
    docs?: (string | Variant)[];
    hasNextPage?: boolean;
    totalDocs?: number;
  };
  priceInUSDEnabled?: boolean | null;
  priceInUSD?: number | null;
  priceInJPYEnabled?: boolean | null;
  priceInJPY?: number | null;
  priceInEUREnabled?: boolean | null;
  priceInEUR?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variantTypes".
 */
export interface VariantType {
  id: string;
  label: string;
  name: string;
  options?: {
    docs?: (string | VariantOption)[];
    hasNextPage?: boolean;
    totalDocs?: number;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variantOptions".
 */
export interface VariantOption {
  id: string;
  variantType: string | VariantType;
  label: string;
  /**
   * should be defaulted or dynamic based on label
   */
  value: string;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "orders".
 */
export interface Order {
  id: string;
  customer?: (string | null) | User;
  customerEmail?: string | null;
  transactions?: (string | Transaction)[] | null;
  status?: OrderStatus;
  amount?: number | null;
  currency?: ('USD' | 'JPY' | 'EUR') | null;
  cart?:
    | {
        product?: (string | null) | Product;
        variant?: (string | null) | Variant;
        quantity: number;
        amount?: number | null;
        currency?: ('USD' | 'JPY' | 'EUR') | null;
        id?: string | null;
      }[]
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "transactions".
 */
export interface Transaction {
  id: string;
  customer?: (string | null) | User;
  customerEmail?: string | null;
  order?: (string | null) | Order;
  status: 'pending' | 'succeeded' | 'failed' | 'cancelled' | 'expired' | 'refunded';
  paymentMethod?: 'stripe' | null;
  stripe?: {
    customerID?: string | null;
    paymentIntentID?: string | null;
  };
  currency?: ('USD' | 'JPY' | 'EUR') | null;
  amount?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'users';
        value: string | User;
      } | null)
    | ({
        relationTo: 'media';
        value: string | Media;
      } | null)
    | ({
        relationTo: 'variants';
        value: string | Variant;
      } | null)
    | ({
        relationTo: 'variantTypes';
        value: string | VariantType;
      } | null)
    | ({
        relationTo: 'variantOptions';
        value: string | VariantOption;
      } | null)
    | ({
        relationTo: 'products';
        value: string | Product;
      } | null)
    | ({
        relationTo: 'orders';
        value: string | Order;
      } | null)
    | ({
        relationTo: 'transactions';
        value: string | Transaction;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "media_select".
 */
export interface MediaSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  url?: T;
  thumbnailURL?: T;
  filename?: T;
  mimeType?: T;
  filesize?: T;
  width?: T;
  height?: T;
  focalX?: T;
  focalY?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variants_select".
 */
export interface VariantsSelect<T extends boolean = true> {
  title?: T;
  product?: T;
  options?: T;
  inventory?: T;
  priceInUSDEnabled?: T;
  priceInUSD?: T;
  priceInJPYEnabled?: T;
  priceInJPY?: T;
  priceInEUREnabled?: T;
  priceInEUR?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variantTypes_select".
 */
export interface VariantTypesSelect<T extends boolean = true> {
  label?: T;
  name?: T;
  options?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "variantOptions_select".
 */
export interface VariantOptionsSelect<T extends boolean = true> {
  variantType?: T;
  label?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "products_select".
 */
export interface ProductsSelect<T extends boolean = true> {
  name?: T;
  enableVariants?: T;
  variantTypes?: T;
  variants?: T;
  priceInUSDEnabled?: T;
  priceInUSD?: T;
  priceInJPYEnabled?: T;
  priceInJPY?: T;
  priceInEUREnabled?: T;
  priceInEUR?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "orders_select".
 */
export interface OrdersSelect<T extends boolean = true> {
  customer?: T;
  customerEmail?: T;
  transactions?: T;
  status?: T;
  amount?: T;
  currency?: T;
  cart?:
    | T
    | {
        product?: T;
        variant?: T;
        quantity?: T;
        amount?: T;
        currency?: T;
        id?: T;
      };
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "transactions_select".
 */
export interface TransactionsSelect<T extends boolean = true> {
  customer?: T;
  customerEmail?: T;
  order?: T;
  status?: T;
  paymentMethod?: T;
  stripe?:
    | T
    | {
        customerID?: T;
        paymentIntentID?: T;
      };
  currency?: T;
  amount?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/plugin-ecommerce/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

````
