---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:12Z
part: 181
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 181 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: generateTypes.ts]---
Location: payload-main/packages/payload/src/bin/generateTypes.ts

```typescript
import type { AcceptedLanguages } from '@payloadcms/translations'

import { initI18n } from '@payloadcms/translations'
import fs from 'fs/promises'
import { compile } from 'json-schema-to-typescript'

import type { SanitizedConfig } from '../config/types.js'

import { addSelectGenericsToGeneratedTypes } from '../utilities/addSelectGenericsToGeneretedTypes.js'
import { configToJSONSchema } from '../utilities/configToJSONSchema.js'
import { getLogger } from '../utilities/logger.js'

export async function generateTypes(
  config: SanitizedConfig,
  options?: { log: boolean },
): Promise<void> {
  const logger = getLogger('payload', 'sync')
  const outputFile = process.env.PAYLOAD_TS_OUTPUT_PATH || config.typescript.outputFile

  const shouldLog = options?.log ?? true

  if (shouldLog) {
    logger.info('Compiling TS types for Collections and Globals...')
  }

  const languages = Object.keys(config.i18n.supportedLanguages) as AcceptedLanguages[]

  const language = languages.includes('en') ? 'en' : config.i18n.fallbackLanguage

  const i18n = await initI18n({ config: config.i18n, context: 'api', language })

  const jsonSchema = configToJSONSchema(config, config.db.defaultIDType, i18n)

  const declare = `declare module 'payload' {\n  export interface GeneratedTypes extends Config {}\n}`
  const declareWithTSIgnoreError = `declare module 'payload' {\n  // @ts-ignore \n  export interface GeneratedTypes extends Config {}\n}`

  let compiled = await compile(jsonSchema, 'Config', {
    bannerComment:
      '/* tslint:disable */\n/* eslint-disable */\n/**\n* This file was automatically generated by Payload.\n* DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n* and re-run `payload generate:types` to regenerate this file.\n*/',
    style: {
      singleQuote: true,
    },
    // Generates code for $defs that aren't referenced by the schema. Reason:
    // If a field defines an interfaceName, it should be included in the generated types
    // even if it's not used by another type. Reason: the user might want to use it in their own code.
    unreachableDefinitions: true,
    // Allow resolving external file references in $ref pointers
    cwd: process.cwd(),
  })

  compiled = addSelectGenericsToGeneratedTypes({ compiledGeneratedTypes: compiled })

  if (config.typescript.declare !== false) {
    if (config.typescript.declare?.ignoreTSError) {
      compiled += `\n\n${declareWithTSIgnoreError}`
    } else {
      compiled += `\n\n${declare}`
    }
  }

  // Diff the compiled types against the existing types file
  try {
    const existingTypes = await fs.readFile(outputFile, 'utf-8')

    if (compiled === existingTypes) {
      return
    }
  } catch (_) {
    // swallow err
  }

  await fs.writeFile(outputFile, compiled)
  if (shouldLog) {
    logger.info(`Types written to ${outputFile}`)
  }
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/packages/payload/src/bin/index.ts

```typescript
/* eslint-disable no-console */
import { Cron } from 'croner'
import minimist from 'minimist'
import { pathToFileURL } from 'node:url'
import path from 'path'

import { findConfig } from '../config/find.js'
import { getPayload, type Payload } from '../index.js'
import { generateImportMap } from './generateImportMap/index.js'
import { generateTypes } from './generateTypes.js'
import { info } from './info.js'
import { loadEnv } from './loadEnv.js'
import { migrate, availableCommands as migrateCommands } from './migrate.js'

// Note: this does not account for any user bin scripts
const availableScripts = [
  'generate:db-schema',
  'generate:importmap',
  'generate:types',
  'info',
  'jobs:run',
  'jobs:handle-schedules',
  'run',
  ...migrateCommands,
] as const

export const bin = async () => {
  loadEnv()
  process.env.DISABLE_PAYLOAD_HMR = 'true'

  const args = minimist(process.argv.slice(2))
  const script = (typeof args._[0] === 'string' ? args._[0] : '').toLowerCase()

  if (args.cron) {
    new Cron(
      args.cron,
      async () => {
        // If the bin script initializes payload (getPayload), this will only happen once, as getPayload
        // caches the payload instance on the module scope => no need to manually cache and manage getPayload initialization
        // outside the Cron here.
        await runBinScript({ args, script })
      },
      {
        // Do not run consecutive crons if previous crons still ongoing
        protect: true,
      },
    )

    process.stdin.resume() // Keep the process alive

    return
  } else {
    const { payload } = await runBinScript({ args, script })
    if (payload) {
      await payload.destroy() // close database connections after running jobs so process can exit cleanly
    }
    process.exit(0)
  }
}

async function runBinScript({
  args,
  script,
}: {
  args: minimist.ParsedArgs
  script: string
}): Promise<{
  /**
   * Scripts can return a payload instance if it exists. The bin script runner can then safely
   * shut off the instance, depending on if it's running in a cron job or not.
   */
  payload?: Payload
}> {
  if (script === 'info') {
    await info()
    return {}
  }

  if (script === 'run') {
    const scriptPath = args._[1]
    if (!scriptPath) {
      console.error('Please provide a script path to run.')
      process.exit(1)
    }

    const absoluteScriptPath = path.resolve(process.cwd(), scriptPath)

    // Modify process.argv to remove 'run' and the script path
    const originalArgv = process.argv
    process.argv = [process.argv[0]!, process.argv[1]!, ...args._.slice(2)]

    try {
      await import(pathToFileURL(absoluteScriptPath).toString())
    } catch (error) {
      console.error(`Error running script: ${absoluteScriptPath}`)
      console.error(error)
      process.exit(1)
    } finally {
      // Restore original process.argv
      process.argv = originalArgv
    }
    return {}
  }

  const configPath = findConfig()
  const configPromise = await import(pathToFileURL(configPath).toString())
  let config = await configPromise
  if (config.default) {
    config = await config.default
  }

  const userBinScript = Array.isArray(config.bin)
    ? config.bin.find(({ key }: { key: string }) => key === script)
    : false

  if (userBinScript) {
    try {
      const module = await import(pathToFileURL(userBinScript.scriptPath).toString())

      if (!module.script || typeof module.script !== 'function') {
        console.error(
          `Could not find "script" function export for script ${userBinScript.key} in ${userBinScript.scriptPath}`,
        )
      } else {
        await module.script(config).catch((err: unknown) => {
          console.log(`Script ${userBinScript.key} failed, details:`)
          console.error(err)
        })
      }
    } catch (err) {
      console.log(`Could not find associated bin script for the ${userBinScript.key} command`)
      console.error(err)
    }

    return {}
  }

  if (script.startsWith('migrate')) {
    await migrate({ config, parsedArgs: args })
    return {}
  }

  if (script === 'generate:types') {
    await generateTypes(config)
    return {}
  }

  if (script === 'generate:importmap') {
    await generateImportMap(config)
    return {}
  }

  if (script === 'jobs:run') {
    const payload = await getPayload({ config }) // Do not setup crons here - this bin script can set up its own crons
    const limit = args.limit ? parseInt(args.limit, 10) : undefined
    const queue = args.queue ? args.queue : undefined
    const allQueues = !!args['all-queues']
    const handleSchedules = !!args['handle-schedules']

    if (handleSchedules) {
      await payload.jobs.handleSchedules({
        allQueues,
        queue,
      })
    }

    await payload.jobs.run({
      allQueues,
      limit,
      queue,
    })

    return { payload }
  }

  if (script === 'jobs:handle-schedules') {
    const payload = await getPayload({ config }) // Do not setup crons here - this bin script can set up its own crons
    const queue = args.queue ? args.queue : undefined
    const allQueues = !!args['all-queues']

    await payload.jobs.handleSchedules({
      allQueues,
      queue,
    })

    return { payload }
  }

  if (script === 'generate:db-schema') {
    // Barebones instance to access database adapter, without connecting to the DB
    const payload = await getPayload({ config, disableDBConnect: true, disableOnInit: true }) // Do not setup crons here

    if (typeof payload.db.generateSchema !== 'function') {
      payload.logger.error({
        msg: `${payload.db.packageName} does not support database schema generation`,
      })

      await payload.destroy()
      process.exit(1)
    }

    await payload.db.generateSchema({
      log: args.log === 'false' ? false : true,
      prettify: args.prettify === 'false' ? false : true,
    })

    return { payload }
  }

  console.error(script ? `Unknown command: "${script}"` : 'Please provide a command to run')
  console.log(`\nAvailable commands:\n${availableScripts.map((c) => `  - ${c}`).join('\n')}`)

  process.exit(1)
}
```

--------------------------------------------------------------------------------

---[FILE: info.ts]---
Location: payload-main/packages/payload/src/bin/info.ts

```typescript
import { execFileSync } from 'child_process'
import os from 'os'

import { getDependencies } from '../index.js'
import { PAYLOAD_PACKAGE_LIST } from '../versions/payloadPackageList.js'

export const info = async () => {
  const deps = await getDependencies(process.cwd(), [
    ...PAYLOAD_PACKAGE_LIST,
    'next',
    'react',
    'react-dom',
  ])

  const formattedDeps = Array.from(deps.resolved.entries()).map(([name, { version }]) => ({
    name,
    version,
  }))

  console.log(generateOutput(formattedDeps))
}

function generateOutput(packages: Array<{ name: string; version: string }>) {
  const cpuCores = os.cpus().length

  const primaryDeps = packages.filter(({ name }) => name === 'payload' || name === 'next')
  const otherDeps = packages
    .filter(({ name }) => name !== 'payload' && name !== 'next')
    .sort((a, b) => a.name.localeCompare(b.name))

  const formattedDeps = [...primaryDeps, ...otherDeps]
    .map(({ name, version }) => `  ${name}: ${version}`)
    .join('\n')

  return `
Binaries:
  Node: ${process.versions.node}
  npm: ${getBinaryVersion('npm')}
  Yarn: ${getBinaryVersion('yarn')}
  pnpm: ${getBinaryVersion('pnpm')}
Relevant Packages:
${formattedDeps}
Operating System:
  Platform: ${os.platform()}
  Arch: ${os.arch()}
  Version: ${os.version()}
  Available memory (MB): ${Math.ceil(os.totalmem() / 1024 / 1024)}
  Available CPU cores: ${cpuCores > 0 ? cpuCores : 'N/A'}
`
}

function getBinaryVersion(binaryName: string) {
  try {
    return execFileSync(binaryName, ['--version']).toString().trim()
  } catch {
    return 'N/A'
  }
}

// Direct execution
if (import.meta.url === `file://${process.argv[1]}`) {
  void info()
}
```

--------------------------------------------------------------------------------

---[FILE: loadEnv.ts]---
Location: payload-main/packages/payload/src/bin/loadEnv.ts

```typescript
import nextEnvImport from '@next/env'

import { findUpSync } from '../utilities/findUp.js'
const { loadEnvConfig } = nextEnvImport

/**
 * Try to find user's env files and load it. Uses the same algorithm next.js uses to parse env files, meaning this also supports .env.local, .env.development, .env.production, etc.
 */
export function loadEnv(path?: string) {
  if (path?.length) {
    loadEnvConfig(path, true)
    return
  }

  const dev = process.env.NODE_ENV !== 'production'
  const { loadedEnvFiles } = loadEnvConfig(process.cwd(), dev)

  if (!loadedEnvFiles?.length) {
    // use findUp to find the env file. So, run loadEnvConfig for every directory upwards
    findUpSync({
      // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve
      condition: (dir) => {
        const { loadedEnvFiles } = loadEnvConfig(dir, true)
        if (loadedEnvFiles?.length) {
          return true
        }
      },
      dir: process.cwd(),
    })
  }
}
```

--------------------------------------------------------------------------------

---[FILE: migrate.ts]---
Location: payload-main/packages/payload/src/bin/migrate.ts

```typescript
import type { ParsedArgs } from 'minimist'

import type { SanitizedConfig } from '../config/types.js'

import payload from '../index.js'
import { prettySyncLoggerDestination } from '../utilities/logger.js'

/**
 * The default logger's options did not allow for forcing sync logging
 * Using these options, to force both pretty print and sync logging
 */
const prettySyncLogger = {
  loggerDestination: prettySyncLoggerDestination,
  loggerOptions: {},
}

export const availableCommands = [
  'migrate',
  'migrate:create',
  'migrate:down',
  'migrate:refresh',
  'migrate:reset',
  'migrate:status',
  'migrate:fresh',
]

const availableCommandsMsg = `Available commands: ${availableCommands.join(', ')}`

type Args = {
  config: SanitizedConfig
  parsedArgs: ParsedArgs
}

export const migrate = async ({ config, parsedArgs }: Args): Promise<void> => {
  const { _: args, file, forceAcceptWarning: forceAcceptFromProps, help } = parsedArgs

  const formattedArgs = Object.keys(parsedArgs)
    .map((key) => {
      const formattedKey = key.replace(/^[-_]+/, '')
      if (!formattedKey) {
        return null
      }

      return formattedKey
        .split('-')
        .map((word, index) =>
          index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1),
        )
        .join('')
    })
    .filter(Boolean)

  const forceAcceptWarning = forceAcceptFromProps || formattedArgs.includes('forceAcceptWarning')
  const skipEmpty = formattedArgs.includes('skipEmpty')

  if (help) {
    // eslint-disable-next-line no-console
    console.log(`\n\n${availableCommandsMsg}\n`) // Avoid having to init payload to get the logger
    process.exit(0)
  }

  process.env.PAYLOAD_MIGRATING = 'true'

  // Barebones instance to access database adapter
  await payload.init({
    config,
    disableDBConnect: args[0] === 'migrate:create',
    disableOnInit: true,
    ...prettySyncLogger,
  })

  const adapter = payload.db

  if (!adapter) {
    throw new Error('No database adapter found')
  }

  if (!args.length) {
    payload.logger.error({
      msg: `No migration command provided. ${availableCommandsMsg}`,
    })
    process.exit(1)
  }

  switch (args[0]) {
    case 'migrate':
      await adapter.migrate()
      break
    case 'migrate:create':
      try {
        await adapter.createMigration({
          file,
          forceAcceptWarning,
          migrationName: args[1],
          payload,
          skipEmpty,
        })
      } catch (err) {
        const error = err instanceof Error ? err.message : 'Unknown error'
        throw new Error(`Error creating migration: ${error}`)
      }
      break
    case 'migrate:down':
      await adapter.migrateDown()
      break
    case 'migrate:fresh':
      await adapter.migrateFresh({ forceAcceptWarning })
      break
    case 'migrate:refresh':
      await adapter.migrateRefresh()
      break
    case 'migrate:reset':
      await adapter.migrateReset()
      break
    case 'migrate:status':
      await adapter.migrateStatus()
      break

    default:
      payload.logger.error({
        msg: `Unknown migration command: ${args[0]}. ${availableCommandsMsg}`,
      })
      process.exit(1)
  }

  payload.logger.info('Done.')
}
```

--------------------------------------------------------------------------------

---[FILE: generateImportMap.spec.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/generateImportMap.spec.ts

```typescript
import type { PayloadComponent } from '../../index.js'
import { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'
import { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'

describe('addPayloadComponentToImportMap', () => {
  let importMap: Record<string, string>
  let imports: Record<
    string,
    {
      path: string
      specifier: string
    }
  >

  beforeEach(() => {
    importMap = {}
    imports = {}
    jest.restoreAllMocks()
  })

  function componentPathTest({
    baseDir,
    importMapFilePath,
    payloadComponent,
    expectedPath,
    expectedSpecifier,
    expectedImportMapToBaseDirPath,
  }: {
    baseDir: string
    importMapFilePath: string
    payloadComponent: PayloadComponent
    expectedPath: string
    expectedImportMapToBaseDirPath: string
    expectedSpecifier: string
  }) {
    const importMapToBaseDirPath = getImportMapToBaseDirPath({
      baseDir,
      importMapPath: importMapFilePath,
    })

    expect(importMapToBaseDirPath).toBe(expectedImportMapToBaseDirPath)

    const { path, specifier } =
      addPayloadComponentToImportMap({
        importMapToBaseDirPath,
        importMap,
        imports,
        payloadComponent,
      }) ?? {}

    expect(path).toBe(expectedPath)
    expect(specifier).toBe(expectedSpecifier)
  }

  it('relative path with import map partially in base dir', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map partially in base dir 2', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/prod/app/(payload)/importMap.js',
      payloadComponent: {
        path: './MyComponent.js#MyExport',
      },
      expectedImportMapToBaseDirPath: '../../../myTest/',
      expectedPath: '../../../myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map partially in base dir 3', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/prod/app/(payload)/importMap.js',
      payloadComponent: {
        path: '../otherTest/MyComponent.js',
        exportName: 'MyExport',
      },
      expectedImportMapToBaseDirPath: '../../../myTest/',
      expectedPath: '../../../otherTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map within base dir', () => {
    componentPathTest({
      baseDir: '/myPackage/test/myTest',
      importMapFilePath: '/myPackage/test/myTest/prod/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../../',
      expectedPath: '../../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir 2', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '../myOtherTest/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myOtherTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir, baseDir ending with slash', () => {
    componentPathTest({
      baseDir: '/test/myTest/',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path with import map not in base dir, component starting with slash', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '../../test/myTest/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('aliased path', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: '@components/MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../../test/myTest/',
      expectedPath: '@components/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })
  it('aliased path in PayloadComponent object', () => {
    componentPathTest({
      baseDir: '/test/',
      importMapFilePath: '/app/(payload)/importMap.js',
      payloadComponent: {
        path: '@components/MyComponent.js',
      },
      expectedImportMapToBaseDirPath: '../../test/',
      expectedPath: '@components/MyComponent.js',
      expectedSpecifier: 'default',
    })
  })

  it('relative path import starting with slash, going up', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/app/importMap.js',
      payloadComponent: '/../MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../',
      expectedPath: '../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('relative path import starting with dot-slash, going up', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/app/importMap.js',
      payloadComponent: './../MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: '../',
      expectedPath: '../../MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('importMap and baseDir in same directory', () => {
    componentPathTest({
      baseDir: '/test/myTest',
      importMapFilePath: '/test/myTest/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: './',
      expectedPath: './MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })

  it('baseDir within importMap dir', () => {
    componentPathTest({
      baseDir: '/test/myTest/components',
      importMapFilePath: '/test/myTest/importMap.js',
      payloadComponent: './MyComponent.js#MyExport',
      expectedImportMapToBaseDirPath: './components/',
      expectedPath: './components/MyComponent.js',
      expectedSpecifier: 'MyExport',
    })
  })
})
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/index.ts

```typescript
/* eslint-disable no-console */
import fs from 'fs/promises'
import process from 'node:process'

import type { PayloadComponent, SanitizedConfig } from '../../config/types.js'

import { iterateConfig } from './iterateConfig.js'
import { addPayloadComponentToImportMap } from './utilities/addPayloadComponentToImportMap.js'
import { getImportMapToBaseDirPath } from './utilities/getImportMapToBaseDirPath.js'
import { resolveImportMapFilePath } from './utilities/resolveImportMapFilePath.js'

type ImportIdentifier = string
type ImportSpecifier = string
type ImportPath = string
type UserImportPath = string

/**
 * Import Map before being written to the file. Only contains all paths
 */
export type InternalImportMap = {
  [path: UserImportPath]: ImportIdentifier
}

/**
 * Imports of the import map.
 */
export type Imports = {
  [identifier: ImportIdentifier]: {
    path: ImportPath
    specifier: ImportSpecifier
  }
}

/**
 * Import Map after being imported from the actual import map. Contains all the actual imported components
 */
export type ImportMap = {
  [path: UserImportPath]: any
}

export type AddToImportMap = (payloadComponent?: PayloadComponent | PayloadComponent[]) => void

export async function generateImportMap(
  config: SanitizedConfig,
  options?: {
    force?: boolean /**
     * If true, will not throw an error if the import map file path cannot be resolved
    Instead, it will return silently.
     */
    ignoreResolveError?: boolean
    log: boolean
  },
): Promise<void> {
  const shouldLog = options?.log ?? true

  if (shouldLog) {
    console.log('Generating import map')
  }

  const importMap: InternalImportMap = {}
  const imports: Imports = {}

  // Determine the root directory of the project - usually the directory where the src or app folder is located
  const rootDir = process.env.ROOT_DIR ?? process.cwd()

  const baseDir = config.admin.importMap.baseDir ?? process.cwd()

  const importMapFilePath = await resolveImportMapFilePath({
    adminRoute: config.routes.admin,
    importMapFile: config?.admin?.importMap?.importMapFile,
    rootDir,
  })

  if (importMapFilePath instanceof Error) {
    if (options?.ignoreResolveError) {
      return
    } else {
      throw importMapFilePath
    }
  }

  const importMapToBaseDirPath = getImportMapToBaseDirPath({
    baseDir,
    importMapPath: importMapFilePath,
  })

  const addToImportMap: AddToImportMap = (payloadComponent) => {
    if (!payloadComponent) {
      return
    }

    if (typeof payloadComponent !== 'object' && typeof payloadComponent !== 'string') {
      console.error(payloadComponent)
      throw new Error('addToImportMap > Payload component must be an object or a string')
    }

    if (Array.isArray(payloadComponent)) {
      for (const component of payloadComponent) {
        addPayloadComponentToImportMap({
          importMap,
          importMapToBaseDirPath,
          imports,
          payloadComponent: component,
        })
      }
    } else {
      addPayloadComponentToImportMap({
        importMap,
        importMapToBaseDirPath,
        imports,
        payloadComponent,
      })
    }
  }

  iterateConfig({
    addToImportMap,
    baseDir: config.admin.importMap.baseDir,
    config,
    importMap,
    imports,
  })

  await writeImportMap({
    componentMap: importMap,
    force: options?.force,
    importMap: imports,
    importMapFilePath,
    log: shouldLog,
  })
}

export async function writeImportMap({
  componentMap,
  force,
  importMap,
  importMapFilePath,
  log,
}: {
  componentMap: InternalImportMap
  force?: boolean
  importMap: Imports
  importMapFilePath: string
  log?: boolean
}) {
  const imports: string[] = []
  for (const [identifier, { path, specifier }] of Object.entries(importMap)) {
    imports.push(`import { ${specifier} as ${identifier} } from '${path}'`)
  }

  const mapKeys: string[] = []
  for (const [userPath, identifier] of Object.entries(componentMap)) {
    mapKeys.push(`  "${userPath}": ${identifier}`)
  }

  const importMapOutputFile = `${imports.join('\n')}

export const importMap = {
${mapKeys.join(',\n')}
}
`

  if (!force) {
    // Read current import map and check in the IMPORTS if there are any new imports. If not, don't write the file.
    const currentImportMap = await fs.readFile(importMapFilePath, 'utf-8')

    if (currentImportMap?.trim() === importMapOutputFile?.trim()) {
      if (log) {
        console.log('No new imports found, skipping writing import map')
      }
      return
    }
  }

  if (log) {
    console.log('Writing import map to', importMapFilePath)
  }

  await fs.writeFile(importMapFilePath, importMapOutputFile)
}
```

--------------------------------------------------------------------------------

---[FILE: iterateCollections.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/iterateCollections.ts

```typescript
import type { SanitizedCollectionConfig } from '../../collections/config/types.js'
import type { SanitizedConfig } from '../../config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { genImportMapIterateFields } from './iterateFields.js'

export function iterateCollections({
  addToImportMap,
  baseDir,
  collections,
  config,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  collections: SanitizedCollectionConfig[]
  config: SanitizedConfig
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const collection of collections) {
    genImportMapIterateFields({
      addToImportMap,
      baseDir,
      config,
      fields: collection.fields,
      importMap,
      imports,
    })

    addToImportMap(collection.admin?.components?.afterList)
    addToImportMap(collection.admin?.components?.listMenuItems)
    addToImportMap(collection.admin?.components?.afterListTable)
    addToImportMap(collection.admin?.components?.beforeList)
    addToImportMap(collection.admin?.components?.beforeListTable)
    addToImportMap(collection.admin?.components?.Description)

    addToImportMap(collection.admin?.components?.edit?.beforeDocumentControls)
    addToImportMap(collection.admin?.components?.edit?.editMenuItems)
    addToImportMap(collection.admin?.components?.edit?.PreviewButton)
    addToImportMap(collection.admin?.components?.edit?.PublishButton)
    addToImportMap(collection.admin?.components?.edit?.SaveButton)
    addToImportMap(collection.admin?.components?.edit?.SaveDraftButton)
    addToImportMap(collection.admin?.components?.edit?.Upload)

    if (collection.upload?.admin?.components?.controls) {
      addToImportMap(collection.upload?.admin?.components?.controls)
    }

    if (collection.admin?.components?.views?.edit) {
      for (const editViewConfig of Object.values(collection.admin?.components?.views?.edit)) {
        if ('Component' in editViewConfig) {
          addToImportMap(editViewConfig?.Component)
        }

        if ('actions' in editViewConfig) {
          addToImportMap(editViewConfig?.actions)
        }

        if ('tab' in editViewConfig) {
          addToImportMap(editViewConfig?.tab?.Component)
          addToImportMap(editViewConfig?.tab?.Pill)
        }
      }
    }

    addToImportMap(collection.admin?.components?.views?.list?.Component)
    addToImportMap(collection.admin?.components?.views?.list?.actions)
  }
}
```

--------------------------------------------------------------------------------

---[FILE: iterateConfig.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/iterateConfig.ts

```typescript
import type { SanitizedConfig } from '../../config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { iterateCollections } from './iterateCollections.js'
import { genImportMapIterateFields } from './iterateFields.js'
import { iterateGlobals } from './iterateGlobals.js'

export function iterateConfig({
  addToImportMap,
  baseDir,
  config,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  importMap: InternalImportMap
  imports: Imports
}) {
  iterateCollections({
    addToImportMap,
    baseDir,
    collections: config.collections,
    config,
    importMap,
    imports,
  })

  iterateGlobals({
    addToImportMap,
    baseDir,
    config,
    globals: config.globals,
    importMap,
    imports,
  })

  if (config?.blocks) {
    const blocks = Object.values(config.blocks)
    if (blocks?.length) {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: blocks,
        importMap,
        imports,
      })
    }
  }

  if (typeof config.admin?.avatar === 'object') {
    addToImportMap(config.admin?.avatar?.Component)
  }

  addToImportMap(config.admin?.components?.Nav)
  addToImportMap(config.admin?.components?.header)
  addToImportMap(config.admin?.components?.logout?.Button)
  addToImportMap(config.admin?.components?.settingsMenu)
  addToImportMap(config.admin?.components?.graphics?.Icon)
  addToImportMap(config.admin?.components?.graphics?.Logo)

  addToImportMap(config.admin?.components?.actions)
  addToImportMap(config.admin?.components?.afterDashboard)
  addToImportMap(config.admin?.components?.afterLogin)
  addToImportMap(config.admin?.components?.afterNavLinks)
  addToImportMap(config.admin?.components?.beforeDashboard)
  addToImportMap(config.admin?.components?.beforeLogin)
  addToImportMap(config.admin?.components?.beforeNavLinks)

  addToImportMap(config.admin?.components?.providers)

  if (config.admin?.components?.views) {
    if (Object.keys(config.admin?.components?.views)?.length) {
      for (const key in config.admin?.components?.views) {
        const adminViewConfig = config.admin?.components?.views[key]
        addToImportMap(adminViewConfig?.Component)
      }
    }
  }

  if (config?.admin?.importMap?.generators?.length) {
    for (const generator of config.admin.importMap.generators) {
      generator({
        addToImportMap,
        baseDir,
        config,
        importMap,
        imports,
      })
    }
  }

  if (config?.admin?.dependencies) {
    for (const dependency of Object.values(config.admin.dependencies)) {
      addToImportMap(dependency.path)
    }
  }

  /*
  if (
    config?.editor &&
    typeof config.editor === 'object' &&
    config.editor.generateImportMap &&
    typeof config.editor.generateImportMap === 'function'
  ) {
    config.editor.generateImportMap({
      addToImportMap,
      baseDir,
      componentMap,
      config,
      importMap,
    })
  }*/ // No need to do that here since in the sanitized editor config, this root editor is already added to the field editor - and we already process that in iterateFields
}
```

--------------------------------------------------------------------------------

---[FILE: iterateFields.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/iterateFields.ts

```typescript
/* eslint-disable @typescript-eslint/no-unused-expressions */
import type { PayloadComponent, SanitizedConfig } from '../../config/types.js'
import type { Block, Field, Tab } from '../../fields/config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

function hasKey<T, K extends string>(
  obj: null | T | undefined,
  key: K,
): obj is { [P in K]: PayloadComponent | PayloadComponent[] } & T {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, key)
}

const defaultUIFieldComponentKeys: Array<'Cell' | 'Description' | 'Field' | 'Filter'> = [
  'Cell',
  'Description',
  'Field',
  'Filter',
]
export function genImportMapIterateFields({
  addToImportMap,
  baseDir,
  config,
  fields,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  fields: Block[] | Field[] | Tab[]
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const field of fields) {
    if ('fields' in field) {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.fields,
        importMap,
        imports,
      })
    } else if (field.type === 'blocks') {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.blocks.filter((block) => typeof block !== 'string'),
        importMap,
        imports,
      })
    } else if (field.type === 'tabs') {
      genImportMapIterateFields({
        addToImportMap,
        baseDir,
        config,
        fields: field.tabs,
        importMap,
        imports,
      })
    } else if (field.type === 'richText') {
      if (
        field?.editor &&
        typeof field.editor === 'object' &&
        field.editor.generateImportMap &&
        typeof field.editor.generateImportMap === 'function'
      ) {
        field.editor.generateImportMap({
          addToImportMap,
          baseDir,
          config,
          importMap,
          imports,
        })
      }
    } else if (field.type === 'ui') {
      if (field?.admin?.components) {
        // Render any extra, untyped components
        for (const key in field.admin.components) {
          if (key in defaultUIFieldComponentKeys) {
            continue
          }
          addToImportMap(field.admin.components[key])
        }
      }
    }

    hasKey(field?.admin, 'jsx') && addToImportMap(field.admin.jsx) // For Blocks

    hasKey(field?.admin?.components, 'Label') && addToImportMap(field.admin.components.Label)

    hasKey(field?.admin?.components, 'Block') && addToImportMap(field.admin.components.Block)

    hasKey(field?.admin?.components, 'Cell') && addToImportMap(field?.admin?.components?.Cell)

    hasKey(field?.admin?.components, 'Description') &&
      addToImportMap(field?.admin?.components?.Description)

    hasKey(field?.admin?.components, 'Field') && addToImportMap(field?.admin?.components?.Field)
    hasKey(field?.admin?.components, 'Filter') && addToImportMap(field?.admin?.components?.Filter)

    hasKey(field?.admin?.components, 'Error') && addToImportMap(field?.admin?.components?.Error)

    hasKey(field?.admin?.components, 'afterInput') &&
      addToImportMap(field?.admin?.components?.afterInput)

    hasKey(field?.admin?.components, 'beforeInput') &&
      addToImportMap(field?.admin?.components?.beforeInput)

    hasKey(field?.admin?.components, 'RowLabel') &&
      addToImportMap(field?.admin?.components?.RowLabel)

    hasKey(field?.admin?.components, 'Diff') && addToImportMap(field?.admin?.components?.Diff)
  }
}
```

--------------------------------------------------------------------------------

---[FILE: iterateGlobals.ts]---
Location: payload-main/packages/payload/src/bin/generateImportMap/iterateGlobals.ts

```typescript
import type { SanitizedConfig } from '../../config/types.js'
import type { SanitizedGlobalConfig } from '../../globals/config/types.js'
import type { AddToImportMap, Imports, InternalImportMap } from './index.js'

import { genImportMapIterateFields } from './iterateFields.js'

export function iterateGlobals({
  addToImportMap,
  baseDir,
  config,
  globals,
  importMap,
  imports,
}: {
  addToImportMap: AddToImportMap
  baseDir: string
  config: SanitizedConfig
  globals: SanitizedGlobalConfig[]
  importMap: InternalImportMap
  imports: Imports
}) {
  for (const global of globals) {
    genImportMapIterateFields({
      addToImportMap,
      baseDir,
      config,
      fields: global.fields,
      importMap,
      imports,
    })

    addToImportMap(global.admin?.components?.elements?.Description)
    addToImportMap(global.admin?.components?.elements?.PreviewButton)
    addToImportMap(global.admin?.components?.elements?.PublishButton)
    addToImportMap(global.admin?.components?.elements?.SaveButton)
    addToImportMap(global.admin?.components?.elements?.SaveDraftButton)

    if (global.admin?.components?.views?.edit) {
      for (const editViewConfig of Object.values(global.admin?.components?.views?.edit)) {
        if ('Component' in editViewConfig) {
          addToImportMap(editViewConfig?.Component)
        }

        if ('actions' in editViewConfig) {
          addToImportMap(editViewConfig?.actions)
        }

        if ('tab' in editViewConfig) {
          addToImportMap(editViewConfig?.tab?.Component)
          addToImportMap(editViewConfig?.tab?.Pill)
        }
      }
    }
  }
}
```

--------------------------------------------------------------------------------

````
