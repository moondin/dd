---
source_txt: fullstack_samples/ShareX-develop
converted_utc: 2025-12-18T13:05:47Z
part: 529
parts_total: 650
---

# FULLSTACK CODE DATABASE SAMPLES ShareX-develop

## Verbatim Content (Part 529 of 650)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - ShareX-develop
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/ShareX-develop
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: Resources.zh-TW.resx]---
Location: ShareX-develop/ShareX.ScreenCaptureLib/Properties/Resources.zh-TW.resx

```text
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.
    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="FFmpegOptionsForm_buttonFFmpegBrowse_Click_Browse_for_ffmpeg_exe" xml:space="preserve">
    <value>瀏覽 ffmpeg.exe</value>
  </data>
  <data name="BaseRegionForm_InitializeComponent_Region_capture" xml:space="preserve">
    <value>區域擷取</value>
  </data>
  <data name="ScrollingCaptureForm_StopCapture_Start_capture" xml:space="preserve">
    <value>開始擷取</value>
  </data>
  <data name="ScrollingCaptureForm_StartCapture_Stop_capture" xml:space="preserve">
    <value>停止擷取</value>
  </data>
  <data name="RectangleTransparent_RectangleTransparent_Rectangle_capture_transparent" xml:space="preserve">
    <value>矩形擷取 (透明)</value>
  </data>
  <data name="RectangleLight_InitializeComponent_Rectangle_capture_light" xml:space="preserve">
    <value>矩形擷取 (高亮)</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Show_FPS" xml:space="preserve">
    <value>顯示幀率</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Height_" xml:space="preserve">
    <value>高：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Width_" xml:space="preserve">
    <value>寬：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Fixed_size_region_mode" xml:space="preserve">
    <value>固定尺寸區域模式</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Show_screen_wide_crosshair" xml:space="preserve">
    <value>顯示全螢幕十字線</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Magnifier_pixel_size_" xml:space="preserve">
    <value>放大鏡像素尺寸：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Magnifier_pixel_count_" xml:space="preserve">
    <value>放大鏡像素數量：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Square_shape_magnifier" xml:space="preserve">
    <value>方形放大鏡</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Show_magnifier" xml:space="preserve">
    <value>顯示放大鏡</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Show_position_and_size_info" xml:space="preserve">
    <value>顯示位置和尺寸資訊</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Multi_region_mode" xml:space="preserve">
    <value>多區域模式</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Options" xml:space="preserve">
    <value>選項</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Capture_monitor" xml:space="preserve">
    <value>擷取顯示器</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Capture_active_monitor" xml:space="preserve">
    <value>擷取目前顯示器</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Capture_fullscreen" xml:space="preserve">
    <value>擷取全螢幕</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Highlight_color___" xml:space="preserve">
    <value>高亮顏色...</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Pixel_size_" xml:space="preserve">
    <value>像素尺寸：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Blur_radius_" xml:space="preserve">
    <value>模糊強度：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Corner_radius_" xml:space="preserve">
    <value>圓角半徑：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Fill_color___" xml:space="preserve">
    <value>填充顏色...</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Border_size_" xml:space="preserve">
    <value>邊框尺寸：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Border_color___" xml:space="preserve">
    <value>邊框顏色...</value>
  </data>
  <data name="WebpageCaptureForm_UpdateControls_Capture" xml:space="preserve">
    <value>擷取</value>
  </data>
  <data name="WebpageCaptureForm_UpdateControls_Stop" xml:space="preserve">
    <value>停止</value>
  </data>
  <data name="CloseEsc" xml:space="preserve">
    <value>關閉 (Esc)</value>
  </data>
  <data name="DropShadowColor" xml:space="preserve">
    <value>陰影顏色...</value>
  </data>
  <data name="EditorStartupForm_ClipboardDoesNotContainAnImage" xml:space="preserve">
    <value>剪貼簿中無圖片。</value>
  </data>
  <data name="ImageEffects" xml:space="preserve">
    <value>新增圖片效果...</value>
  </data>
  <data name="LightResizeNodes" xml:space="preserve">
    <value>使用高亮尺寸調整點</value>
  </data>
  <data name="MagnifyStrength" xml:space="preserve">
    <value>放大強度：</value>
  </data>
  <data name="OpenKeybindsPage" xml:space="preserve">
    <value>開啟按鍵配置網頁...</value>
  </data>
  <data name="RegionCaptureForm_InitializeComponent_ImageEditor" xml:space="preserve">
    <value>圖片編輯器</value>
  </data>
  <data name="RegionCaptureForm_ShowExitConfirmation_ShareXImageEditor" xml:space="preserve">
    <value>ShareX - 圖片編輯器</value>
  </data>
  <data name="RegionCaptureForm_TipYouCanPanImageByHoldingMouseMiddleButtonAndDragging" xml:space="preserve">
    <value>提示：點擊滑鼠中鍵並拖曳即可平移圖片。</value>
  </data>
  <data name="ShapeManager_CenterPoints" xml:space="preserve">
    <value>中心點：</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_Capture" xml:space="preserve">
    <value>擷取</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_EnableAnimations" xml:space="preserve">
    <value>啟用動畫</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_RememberMenuState" xml:space="preserve">
    <value>記住選單狀態</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_SwitchToDrawingToolAfterSelection" xml:space="preserve">
    <value>選取形狀後切換到繪圖工具</value>
  </data>
  <data name="ShapeManager_CreateContextMenu_SwitchToSelectionToolAfterDrawing" xml:space="preserve">
    <value>繪製形狀後切換到選取工具</value>
  </data>
  <data name="ShapeManager_CreateToolbar_AnnotateMenu" xml:space="preserve">
    <value>編輯器選單</value>
  </data>
  <data name="ShapeManager_CreateToolbar_ApplyChangesContinueTaskEnter" xml:space="preserve">
    <value>套用變更並繼續排程 (Enter)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_AutoCloseEditorOnTask" xml:space="preserve">
    <value>在排程中自動關閉編輯器</value>
  </data>
  <data name="ShapeManager_CreateToolbar_AutoCropImage" xml:space="preserve">
    <value>自動裁切圖片...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_BringForward" xml:space="preserve">
    <value>上移一層</value>
  </data>
  <data name="ShapeManager_CreateToolbar_BringToFront" xml:space="preserve">
    <value>置於最上層</value>
  </data>
  <data name="ShapeManager_CreateToolbar_CancelTaskEsc" xml:space="preserve">
    <value>取消排程 (Esc)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_CanvasSize" xml:space="preserve">
    <value>畫布尺寸...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_CaptureRegions" xml:space="preserve">
    <value>擷取區域</value>
  </data>
  <data name="ShapeManager_CreateToolbar_ContinueTaskSpaceOrRightClick" xml:space="preserve">
    <value>繼續排程 (空白鍵或滑鼠右鍵)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_CopyImageToClipboard" xml:space="preserve">
    <value>將圖片複製到剪貼簿 (Ctrl + C)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_CropImage" xml:space="preserve">
    <value>裁切圖片...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Delete" xml:space="preserve">
    <value>刪除</value>
  </data>
  <data name="ShapeManager_CreateToolbar_DeleteAll" xml:space="preserve">
    <value>刪除全部</value>
  </data>
  <data name="ShapeManager_CreateToolbar_DropShadow" xml:space="preserve">
    <value>陰影</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Edit" xml:space="preserve">
    <value>編輯</value>
  </data>
  <data name="ShapeManager_CreateToolbar_EditorStartMode" xml:space="preserve">
    <value>編輯器啟動模式：</value>
  </data>
  <data name="ShapeManager_CreateToolbar_FlipHorizontal" xml:space="preserve">
    <value>水平翻轉</value>
  </data>
  <data name="ShapeManager_CreateToolbar_FlipVertical" xml:space="preserve">
    <value>垂直翻轉</value>
  </data>
  <data name="ShapeManager_CreateToolbar_FontSize" xml:space="preserve">
    <value>字型大小：</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Image" xml:space="preserve">
    <value>圖片</value>
  </data>
  <data name="ShapeManager_CreateToolbar_ImageSize" xml:space="preserve">
    <value>圖片尺寸...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_InsertImageFile" xml:space="preserve">
    <value>插入圖片檔案...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_InsertImageFromScreen" xml:space="preserve">
    <value>從螢幕插入圖片...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_InterpolationMode" xml:space="preserve">
    <value>內插模式：</value>
  </data>
  <data name="ShapeManager_CreateToolbar_LastRegion" xml:space="preserve">
    <value>擷取上個區域</value>
  </data>
  <data name="ShapeManager_CreateToolbar_NewImage" xml:space="preserve">
    <value>新圖片...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_OpenImageFile" xml:space="preserve">
    <value>開啟圖片檔案...</value>
  </data>
  <data name="ShapeManager_CreateToolbar_PasteImageText" xml:space="preserve">
    <value>貼上圖片/文字</value>
  </data>
  <data name="ShapeManager_CreateToolbar_PrintImage" xml:space="preserve">
    <value>列印圖片... (Ctrl + P)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Rotate180" xml:space="preserve">
    <value>旋轉 180°</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Rotate90Clockwise" xml:space="preserve">
    <value>順時針旋轉 90°</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Rotate90CounterClockwise" xml:space="preserve">
    <value>逆時針旋轉 90°</value>
  </data>
  <data name="ShapeManager_CreateToolbar_RunAfterCaptureTasks" xml:space="preserve">
    <value>執行擷取後的排程 (Enter)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_SaveImage" xml:space="preserve">
    <value>儲存圖片 (Ctrl + S)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_SaveImageAs" xml:space="preserve">
    <value>儲存圖片為... (Ctrl + Shift + S)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_SendBackward" xml:space="preserve">
    <value>下移一層</value>
  </data>
  <data name="ShapeManager_CreateToolbar_SendToBack" xml:space="preserve">
    <value>置於底層</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Undo" xml:space="preserve">
    <value>復原</value>
  </data>
  <data name="ShapeManager_CreateToolbar_UploadImage" xml:space="preserve">
    <value>上傳圖片 (Ctrl + U)</value>
  </data>
  <data name="ShapeManager_CreateToolbar_StartingStepValue" xml:space="preserve">
    <value>第一步的值：</value>
  </data>
  <data name="ShapeManager_CursorType" xml:space="preserve">
    <value>游標類型：</value>
  </data>
  <data name="ThisWindowWillCloseBeforeOpeningKeybindsPageWantContinue" xml:space="preserve">
    <value>此視窗將在開啟按鍵配置網頁前關閉。是否要繼續？</value>
  </data>
  <data name="WouldYouLikeToResetOptions" xml:space="preserve">
    <value>是否要重設選項？</value>
  </data>
  <data name="AutoCopyImageToClipboard" xml:space="preserve">
    <value>自動複製圖片到剪貼簿</value>
  </data>
  <data name="Bitrate" xml:space="preserve">
    <value>位元率：</value>
  </data>
  <data name="Blur" xml:space="preserve">
    <value>模糊</value>
  </data>
  <data name="Confirmation" xml:space="preserve">
    <value>確認</value>
  </data>
  <data name="Duplicate" xml:space="preserve">
    <value>複製</value>
  </data>
  <data name="FPSLimit" xml:space="preserve">
    <value>幀率限制：</value>
  </data>
  <data name="Highlight" xml:space="preserve">
    <value>高亮</value>
  </data>
  <data name="ImageCopied" xml:space="preserve">
    <value>已複製圖片</value>
  </data>
  <data name="ImageSaved" xml:space="preserve">
    <value>已儲存圖片</value>
  </data>
  <data name="ImageSavedAs" xml:space="preserve">
    <value>已儲存圖片</value>
  </data>
  <data name="ImageUploading" xml:space="preserve">
    <value>正在上傳圖片</value>
  </data>
  <data name="LockMenu" xml:space="preserve">
    <value>鎖定選單</value>
  </data>
  <data name="MenuIconSize" xml:space="preserve">
    <value>選單圖示大小：</value>
  </data>
  <data name="NewLineCtrlEnterOKEnter" xml:space="preserve">
    <value>Ctrl + Enter：換行；Enter：確認</value>
  </data>
  <data name="NewLineEnterOKCtrlEnter" xml:space="preserve">
    <value>Ctrl + Enter：確認；Enter：換行</value>
  </data>
  <data name="Pause" xml:space="preserve">
    <value>暫停</value>
  </data>
  <data name="Pixelate" xml:space="preserve">
    <value>像素化</value>
  </data>
  <data name="Processing" xml:space="preserve">
    <value>處理中...</value>
  </data>
  <data name="RectangleRegion_GetAreaText_Area" xml:space="preserve">
    <value>X: {0} Y: {1} W: {2} H: {3}</value>
  </data>
  <data name="Resume" xml:space="preserve">
    <value>繼續</value>
  </data>
  <data name="ShapeManager_CreateToolbar_ToolOptions" xml:space="preserve">
    <value>工具選項</value>
  </data>
  <data name="ShapeManager_CreateToolbar_StepType" xml:space="preserve">
    <value>步驟類型：</value>
  </data>
  <data name="ShapeManager_CreateToolbar_ZoomToFitOnOpen" xml:space="preserve">
    <value>打開時縮放到適當大小</value>
  </data>
  <data name="ScreenRecordForm_ConfirmCancel" xml:space="preserve">
    <value>確定要取消這次錄製嗎？</value>
  </data>
  <data name="ScreenRecordForm_Start" xml:space="preserve">
    <value>開始</value>
  </data>
  <data name="ScreenRecordForm_StartRecording_Click_tray_icon_to_start_recording_" xml:space="preserve">
    <value>點擊開始錄製。</value>
  </data>
  <data name="ScreenRecordForm_StartRecording_Click_tray_icon_to_stop_recording_" xml:space="preserve">
    <value>點擊停止錄製。</value>
  </data>
  <data name="ScreenRecordForm_StartRecording_Encoding___" xml:space="preserve">
    <value>轉檔中...</value>
  </data>
  <data name="ScreenRecordForm_StartRecording_Waiting___" xml:space="preserve">
    <value>等待中...</value>
  </data>
  <data name="ScreenRecordForm_Stop" xml:space="preserve">
    <value>停止</value>
  </data>
  <data name="ShapeManager_BorderStyle" xml:space="preserve">
    <value>邊框樣式：</value>
  </data>
  <data name="ShapeManager_ArrowHeadDirection" xml:space="preserve">
    <value>箭頭頭部方向：</value>
  </data>
  <data name="CutOutEffectSize" xml:space="preserve">
    <value>剪紙效果大小：</value>
  </data>
  <data name="CutOutEffectType" xml:space="preserve">
    <value>剪紙效果：</value>
  </data>
  <data name="ShapeManager_CreateToolbar_Redo" xml:space="preserve">
    <value>重做</value>
  </data>
  <data name="ImageURL" xml:space="preserve">
    <value>圖片網址</value>
  </data>
  <data name="CutOutBackgroundColor" xml:space="preserve">
    <value>剪紙背景顏色...</value>
  </data>
  <data name="RegionCaptureForm_SaveChangesBeforeClosingEditor" xml:space="preserve">
    <value>有尚未儲存的變更。

是否要在關閉圖片編輯器前儲存變更？</value>
  </data>
</root>
```

--------------------------------------------------------------------------------

---[FILE: FFmpegCaptureDevice.cs]---
Location: ShareX-develop/ShareX.ScreenCaptureLib/ScreenRecording/FFmpegCaptureDevice.cs

```csharp
#region License Information (GPL v3)

/*
    ShareX - A program that allows you to take screenshots and share any file type
    Copyright (c) 2007-2025 ShareX Team

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

    Optionally you can also view the license at <http://www.gnu.org/licenses/>.
*/

#endregion License Information (GPL v3)

namespace ShareX.ScreenCaptureLib
{
    public class FFmpegCaptureDevice
    {
        public string Value { get; set; }
        public string Title { get; set; }

        public FFmpegCaptureDevice(string value, string title)
        {
            Value = value;
            Title = title;
        }

        public static FFmpegCaptureDevice None { get; } = new FFmpegCaptureDevice("", "None");
        public static FFmpegCaptureDevice GDIGrab { get; } = new FFmpegCaptureDevice("gdigrab", "gdigrab (Graphics Device Interface)");
        public static FFmpegCaptureDevice DDAGrab { get; } = new FFmpegCaptureDevice("ddagrab", "ddagrab (Desktop Duplication API)");
        public static FFmpegCaptureDevice ScreenCaptureRecorder { get; } = new FFmpegCaptureDevice("screen-capture-recorder", "dshow (screen-capture-recorder)");
        public static FFmpegCaptureDevice VirtualAudioCapturer { get; } = new FFmpegCaptureDevice("virtual-audio-capturer", "dshow (virtual-audio-capturer)");

        public override string ToString()
        {
            return Title;
        }
    }
}
```

--------------------------------------------------------------------------------

---[FILE: FFmpegOptions.cs]---
Location: ShareX-develop/ShareX.ScreenCaptureLib/ScreenRecording/FFmpegOptions.cs

```csharp
#region License Information (GPL v3)

/*
    ShareX - A program that allows you to take screenshots and share any file type
    Copyright (c) 2007-2025 ShareX Team

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

    Optionally you can also view the license at <http://www.gnu.org/licenses/>.
*/

#endregion License Information (GPL v3)

using ShareX.HelpersLib;
using System;

namespace ShareX.ScreenCaptureLib
{
    public class FFmpegOptions
    {
        // General
        public bool OverrideCLIPath { get; set; } = false;
        public string CLIPath { get; set; } = "";
        public string VideoSource { get; set; } = FFmpegCaptureDevice.GDIGrab.Value;
        public string AudioSource { get; set; } = FFmpegCaptureDevice.None.Value;
        public FFmpegVideoCodec VideoCodec { get; set; } = FFmpegVideoCodec.libx264;
        public FFmpegAudioCodec AudioCodec { get; set; } = FFmpegAudioCodec.libvoaacenc;
        public string UserArgs { get; set; } = "";
        public bool UseCustomCommands { get; set; } = false;
        public string CustomCommands { get; set; } = "";

        // Video
        public FFmpegPreset x264_Preset { get; set; } = FFmpegPreset.ultrafast;
        public int x264_CRF { get; set; } = 28;
        public bool x264_Use_Bitrate { get; set; } = false;
        public int x264_Bitrate { get; set; } = 3000; // kbps
        public int VPx_Bitrate { get; set; } = 3000; // kbps
        public int XviD_QScale { get; set; } = 10;
        public FFmpegNVENCPreset NVENC_Preset { get; set; } = FFmpegNVENCPreset.p4;
        public FFmpegNVENCTune NVENC_Tune { get; set; } = FFmpegNVENCTune.ll;
        public int NVENC_Bitrate { get; set; } = 3000; // kbps
        public FFmpegPaletteGenStatsMode GIFStatsMode { get; set; } = FFmpegPaletteGenStatsMode.full;
        public FFmpegPaletteUseDither GIFDither { get; set; } = FFmpegPaletteUseDither.sierra2_4a;
        public int GIFBayerScale { get; set; } = 2;
        public FFmpegAMFUsage AMF_Usage { get; set; } = FFmpegAMFUsage.lowlatency;
        public FFmpegAMFQuality AMF_Quality { get; set; } = FFmpegAMFQuality.speed;
        public int AMF_Bitrate { get; set; } = 3000; // kbps
        public FFmpegQSVPreset QSV_Preset { get; set; } = FFmpegQSVPreset.fast;
        public int QSV_Bitrate { get; set; } = 3000; // kbps

        // Audio
        public int AAC_Bitrate { get; set; } = 128; // kbps
        public int Opus_Bitrate { get; set; } = 128; // kbps
        public int Vorbis_QScale { get; set; } = 3;
        public int MP3_QScale { get; set; } = 4;

        public string FFmpegPath
        {
            get
            {
                if (OverrideCLIPath && !string.IsNullOrEmpty(CLIPath))
                {
                    return FileHelpers.GetAbsolutePath(CLIPath);
                }

                return FileHelpers.GetAbsolutePath("ffmpeg.exe");
            }
        }

        public string Extension
        {
            get
            {
                if (!string.IsNullOrEmpty(VideoSource))
                {
                    switch (VideoCodec)
                    {
                        case FFmpegVideoCodec.libx264:
                        case FFmpegVideoCodec.libx265:
                        case FFmpegVideoCodec.h264_nvenc:
                        case FFmpegVideoCodec.hevc_nvenc:
                        case FFmpegVideoCodec.h264_amf:
                        case FFmpegVideoCodec.hevc_amf:
                        case FFmpegVideoCodec.h264_qsv:
                        case FFmpegVideoCodec.hevc_qsv:
                            return "mp4";
                        case FFmpegVideoCodec.libvpx:
                        case FFmpegVideoCodec.libvpx_vp9:
                            return "webm";
                        case FFmpegVideoCodec.libxvid:
                            return "avi";
                        case FFmpegVideoCodec.gif:
                            return "gif";
                        case FFmpegVideoCodec.libwebp:
                            return "webp";
                        case FFmpegVideoCodec.apng:
                            return "apng";
                    }
                }
                else if (!string.IsNullOrEmpty(AudioSource))
                {
                    switch (AudioCodec)
                    {
                        case FFmpegAudioCodec.libvoaacenc:
                            return "m4a";
                        case FFmpegAudioCodec.libopus:
                            return "opus";
                        case FFmpegAudioCodec.libvorbis:
                            return "ogg";
                        case FFmpegAudioCodec.libmp3lame:
                            return "mp3";
                    }
                }

                return "mp4";
            }
        }

        public bool IsSourceSelected => IsVideoSourceSelected || IsAudioSourceSelected;

        public bool IsVideoSourceSelected => !string.IsNullOrEmpty(VideoSource);

        public bool IsAudioSourceSelected => !string.IsNullOrEmpty(AudioSource) && (!IsVideoSourceSelected || !IsAnimatedImage);

        public bool IsAnimatedImage => VideoCodec == FFmpegVideoCodec.gif || VideoCodec == FFmpegVideoCodec.libwebp || VideoCodec == FFmpegVideoCodec.apng;

        public bool IsEvenSizeRequired => !IsAnimatedImage;

        // TEMP: For backward compatibility
        public void FixSources()
        {
            if (VideoSource.Equals("None", StringComparison.OrdinalIgnoreCase))
            {
                VideoSource = FFmpegCaptureDevice.None.Value;
            }
            else if (VideoSource.Equals("GDI grab", StringComparison.OrdinalIgnoreCase))
            {
                VideoSource = FFmpegCaptureDevice.GDIGrab.Value;
            }

            if (AudioSource.Equals("None", StringComparison.OrdinalIgnoreCase))
            {
                AudioSource = FFmpegCaptureDevice.None.Value;
            }
        }
    }
}
```

--------------------------------------------------------------------------------

---[FILE: HardDiskCache.cs]---
Location: ShareX-develop/ShareX.ScreenCaptureLib/ScreenRecording/HardDiskCache.cs

```csharp
#region License Information (GPL v3)

/*
    ShareX - A program that allows you to take screenshots and share any file type
    Copyright (c) 2007-2025 ShareX Team

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

    Optionally you can also view the license at <http://www.gnu.org/licenses/>.
*/

#endregion License Information (GPL v3)

using ShareX.HelpersLib;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace ShareX.ScreenCaptureLib
{
    public class HardDiskCache : ImageCache
    {
        public int Count
        {
            get
            {
                if (indexList != null)
                {
                    return indexList.Count;
                }

                return 0;
            }
        }

        private FileStream fsCache;
        private List<LocationInfo> indexList;

        public HardDiskCache(ScreenRecordingOptions options)
        {
            Options = options;
            FileHelpers.CreateDirectoryFromFilePath(Options.OutputPath);
            fsCache = new FileStream(Options.OutputPath, FileMode.Create, FileAccess.Write, FileShare.Read);
            indexList = new List<LocationInfo>();
        }

        protected override void WriteFrame(Image img)
        {
            using (MemoryStream ms = new MemoryStream())
            {
                img.Save(ms, ImageFormat.Bmp);
                long position = fsCache.Position;
                ms.CopyStreamTo(fsCache);
                indexList.Add(new LocationInfo(position, fsCache.Length - position));
            }
        }

        public override void Dispose()
        {
            if (fsCache != null)
            {
                fsCache.Dispose();
            }

            base.Dispose();
        }

        public IEnumerable<Image> GetImageEnumerator()
        {
            if (!IsWorking && File.Exists(Options.OutputPath) && indexList != null && indexList.Count > 0)
            {
                using (FileStream fsCache = new FileStream(Options.OutputPath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    foreach (LocationInfo index in indexList)
                    {
                        using (MemoryStream ms = new MemoryStream())
                        {
                            fsCache.CopyStreamTo64(ms, index.Location, (int)index.Length);
                            yield return Image.FromStream(ms);
                        }
                    }
                }
            }
        }
    }
}
```

--------------------------------------------------------------------------------

---[FILE: ImageCache.cs]---
Location: ShareX-develop/ShareX.ScreenCaptureLib/ScreenRecording/ImageCache.cs

```csharp
#region License Information (GPL v3)

/*
    ShareX - A program that allows you to take screenshots and share any file type
    Copyright (c) 2007-2025 ShareX Team

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

    Optionally you can also view the license at <http://www.gnu.org/licenses/>.
*/

#endregion License Information (GPL v3)

using System;
using System.Collections.Concurrent;
using System.Drawing;
using System.Threading;

namespace ShareX.ScreenCaptureLib
{
    public abstract class ImageCache : IDisposable
    {
        public bool IsWorking { get; protected set; }
        public ScreenRecordingOptions Options { get; set; }

        protected Thread task;
        protected BlockingCollection<Image> imageQueue;

        public ImageCache()
        {
            imageQueue = new BlockingCollection<Image>();
        }

        public void AddImageAsync(Image img)
        {
            if (!IsWorking)
            {
                StartConsumerThread();
            }

            imageQueue.Add(img);
        }

        protected virtual void StartConsumerThread()
        {
            if (!IsWorking)
            {
                IsWorking = true;

                task = new Thread(() =>
                {
                    try
                    {
                        while (!imageQueue.IsCompleted)
                        {
                            Image img = null;

                            try
                            {
                                img = imageQueue.Take();

                                if (img != null)
                                {
                                    //using (new DebugTimer("WriteFrame"))
                                    WriteFrame(img);
                                }
                            }
                            catch (InvalidOperationException)
                            {
                            }
                            finally
                            {
                                if (img != null) img.Dispose();
                            }
                        }
                    }
                    finally
                    {
                        IsWorking = false;
                    }
                });

                task.Start();
            }
        }

        protected abstract void WriteFrame(Image img);

        public void Finish()
        {
            if (IsWorking)
            {
                imageQueue.CompleteAdding();
                task.Join();
            }

            Dispose();
        }

        public virtual void Dispose()
        {
            if (imageQueue != null)
            {
                imageQueue.Dispose();
            }
        }
    }
}
```

--------------------------------------------------------------------------------

````
