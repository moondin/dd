---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:14Z
part: 946
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 946 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: 0403_create_role_based_groups_for_internal_realms.py]---
Location: zulip-main/zerver/migrations/0403_create_role_based_groups_for_internal_realms.py
Signals: Django

```python
# Generated by Django 3.2.13 on 2022-06-28 17:36

from django.conf import settings
from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.utils.timezone import now as timezone_now

# This migration is a copy of
# zerver/migrations/0382_create_role_based_system_groups.py" run
# for the internal realm only.


def create_role_based_system_groups_for_internal_realms(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    UserProfile = apps.get_model("zerver", "UserProfile")
    UserGroup = apps.get_model("zerver", "UserGroup")
    GroupGroupMembership = apps.get_model("zerver", "GroupGroupMembership")
    UserGroupMembership = apps.get_model("zerver", "UserGroupMembership")

    UserProfile.ROLE_REALM_OWNER = 100
    UserProfile.ROLE_REALM_ADMINISTRATOR = 200
    UserProfile.ROLE_MODERATOR = 300
    UserProfile.ROLE_MEMBER = 400
    UserProfile.ROLE_GUEST = 600

    try:
        realm = Realm.objects.get(string_id=settings.SYSTEM_BOT_REALM)
    except Realm.DoesNotExist:
        # Server not initialized, or no system bot realm. Either way,
        # we shouldn't do anything.
        return

    SYSTEM_USER_GROUP_ROLE_MAP = {
        UserProfile.ROLE_REALM_OWNER: {
            "name": "@role:owners",
            "description": "Owners of this organization",
        },
        UserProfile.ROLE_REALM_ADMINISTRATOR: {
            "name": "@role:administrators",
            "description": "Administrators of this organization, including owners",
        },
        UserProfile.ROLE_MODERATOR: {
            "name": "@role:moderators",
            "description": "Moderators of this organization, including administrators",
        },
        UserProfile.ROLE_MEMBER: {
            "name": "@role:members",
            "description": "Members of this organization, not including guests",
        },
        UserProfile.ROLE_GUEST: {
            "name": "@role:everyone",
            "description": "Everyone in this organization, including guests",
        },
    }

    with transaction.atomic():
        if UserGroup.objects.filter(
            realm=realm, name="@role:internet", is_system_group=True
        ).exists():
            # Handle the case where we are rerunning after a
            # failure, and had already created groups.
            return

        role_system_groups_dict = {
            role: UserGroup(
                name=user_group_params["name"],
                description=user_group_params["description"],
                realm=realm,
                is_system_group=True,
            )
            for role, user_group_params in SYSTEM_USER_GROUP_ROLE_MAP.items()
        }

        full_members_system_group = UserGroup(
            name="@role:fullmembers",
            description="Members of this organization, not including new accounts and guests",
            realm=realm,
            is_system_group=True,
        )
        everyone_on_internet_system_group = UserGroup(
            name="@role:internet",
            description="Everyone on the Internet",
            realm=realm,
            is_system_group=True,
        )

        system_user_groups_list = [
            role_system_groups_dict[UserProfile.ROLE_REALM_OWNER],
            role_system_groups_dict[UserProfile.ROLE_REALM_ADMINISTRATOR],
            role_system_groups_dict[UserProfile.ROLE_MODERATOR],
            full_members_system_group,
            role_system_groups_dict[UserProfile.ROLE_MEMBER],
            role_system_groups_dict[UserProfile.ROLE_GUEST],
            everyone_on_internet_system_group,
        ]

        UserGroup.objects.bulk_create(system_user_groups_list)

        subgroup_objects = []
        subgroup, remaining_groups = system_user_groups_list[0], system_user_groups_list[1:]
        for supergroup in remaining_groups:
            subgroup_objects.append(GroupGroupMembership(subgroup=subgroup, supergroup=supergroup))
            subgroup = supergroup

        GroupGroupMembership.objects.bulk_create(subgroup_objects)

        users = UserProfile.objects.filter(realm=realm).only("id", "role", "date_joined")
        group_membership_objects = []
        for user in users:
            system_group = role_system_groups_dict[user.role]
            group_membership_objects.append(
                UserGroupMembership(user_profile=user, user_group=system_group)
            )

            if (
                user.role == UserProfile.ROLE_MEMBER
                and (timezone_now() - user.date_joined).days >= realm.waiting_period_threshold
            ):
                group_membership_objects.append(
                    UserGroupMembership(user_profile=user, user_group=full_members_system_group)
                )

        UserGroupMembership.objects.bulk_create(group_membership_objects)


def delete_role_based_system_groups_for_internal_realms(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserGroup = apps.get_model("zerver", "UserGroup")
    GroupGroupMembership = apps.get_model("zerver", "GroupGroupMembership")
    UserGroupMembership = apps.get_model("zerver", "UserGroupMembership")
    Realm = apps.get_model("zerver", "Realm")

    try:
        realm = Realm.objects.get(string_id=settings.SYSTEM_BOT_REALM)
    except Realm.DoesNotExist:
        # Server not initialized, or no system bot realm. Either way, we shouldn't do anything.
        return

    with transaction.atomic():
        GroupGroupMembership.objects.filter(subgroup__realm=realm).delete()
        UserGroupMembership.objects.filter(
            user_group__realm=realm, user_group__is_system_group=True
        ).delete()
        UserGroup.objects.filter(realm=realm, is_system_group=True).delete()


class Migration(migrations.Migration):
    """This migration is a copy of
    "zerver/migrations/0402_alter_usertopic_visibility_policy.py" run
    for the internal realm only.
    """

    dependencies = [
        ("zerver", "0402_alter_usertopic_visibility_policy"),
    ]

    operations = [
        migrations.RunPython(
            create_role_based_system_groups_for_internal_realms,
            reverse_code=delete_role_based_system_groups_for_internal_realms,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0404_realm_enable_read_receipts.py]---
Location: zulip-main/zerver/migrations/0404_realm_enable_read_receipts.py
Signals: Django

```python
# Generated by Django 4.0.6 on 2022-08-04 07:38

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0403_create_role_based_groups_for_internal_realms"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="enable_read_receipts",
            field=models.BooleanField(default=False),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0405_set_default_for_enable_read_receipts.py]---
Location: zulip-main/zerver/migrations/0405_set_default_for_enable_read_receipts.py
Signals: Django

```python
# Generated by Django 4.0.6 on 2022-08-08 16:52

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Q


def set_default_for_enable_read_receipts(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    # We enable read receipts by default in realms which require an invitation to
    # join or which allow only users having emails with specific domains to join.
    Realm.objects.filter(Q(invite_required=True) | Q(emails_restricted_to_domains=True)).update(
        enable_read_receipts=True
    )


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0404_realm_enable_read_receipts"),
    ]

    operations = [
        migrations.RunPython(set_default_for_enable_read_receipts, elidable=True),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0406_alter_realm_message_content_edit_limit_seconds.py]---
Location: zulip-main/zerver/migrations/0406_alter_realm_message_content_edit_limit_seconds.py
Signals: Django

```python
# Generated by Django 3.2.12 on 2022-04-12 14:51

from django.db import migrations, models
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def make_zero_invalid_for_message_content_edit_limit(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    Realm.DEFAULT_MESSAGE_CONTENT_EDIT_LIMIT_SECONDS = 600

    Realm.objects.filter(allow_message_editing=True, message_content_edit_limit_seconds=0).update(
        message_content_edit_limit_seconds=None
    )

    Realm.objects.filter(allow_message_editing=False, message_content_edit_limit_seconds=0).update(
        message_content_edit_limit_seconds=Realm.DEFAULT_MESSAGE_CONTENT_EDIT_LIMIT_SECONDS
    )


def reverse_make_zero_invalid_for_message_content_edit_limit(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    Realm.DEFAULT_MESSAGE_CONTENT_EDIT_LIMIT_SECONDS = 600

    Realm.objects.filter(
        allow_message_editing=True, message_content_edit_limit_seconds=None
    ).update(message_content_edit_limit_seconds=0)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0405_set_default_for_enable_read_receipts"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realm",
            name="message_content_edit_limit_seconds",
            field=models.IntegerField(default=600, null=True),
        ),
        migrations.RunPython(
            make_zero_invalid_for_message_content_edit_limit,
            reverse_code=reverse_make_zero_invalid_for_message_content_edit_limit,
            elidable=True,
        ),
        migrations.AlterField(
            model_name="realm",
            name="message_content_edit_limit_seconds",
            field=models.PositiveIntegerField(default=600, null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0407_userprofile_user_list_style.py]---
Location: zulip-main/zerver/migrations/0407_userprofile_user_list_style.py
Signals: Django

```python
# Generated by Django 4.0.6 on 2022-08-14 18:23

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0406_alter_realm_message_content_edit_limit_seconds"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmuserdefault",
            name="user_list_style",
            field=models.PositiveSmallIntegerField(default=3),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="user_list_style",
            field=models.PositiveSmallIntegerField(default=3),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0408_stream_can_remove_subscribers_group.py]---
Location: zulip-main/zerver/migrations/0408_stream_can_remove_subscribers_group.py
Signals: Django

```python
# Generated by Django 3.2.13 on 2022-06-24 14:18

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0407_userprofile_user_list_style"),
    ]

    operations = [
        migrations.AddField(
            model_name="stream",
            name="can_remove_subscribers_group",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.RESTRICT, to="zerver.usergroup"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0409_set_default_for_can_remove_subscribers_group.py]---
Location: zulip-main/zerver/migrations/0409_set_default_for_can_remove_subscribers_group.py
Signals: Django

```python
# Generated by Django 3.2.13 on 2022-06-28 12:02

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def set_default_value_for_can_remove_subscribers_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Stream = apps.get_model("zerver", "Stream")
    Realm = apps.get_model("zerver", "Realm")
    UserGroup = apps.get_model("zerver", "UserGroup")

    for realm in Realm.objects.all().iterator():
        admins_group = UserGroup.objects.get(
            name="@role:administrators", realm=realm, is_system_group=True
        )
        Stream.objects.filter(realm=realm, can_remove_subscribers_group=None).update(
            can_remove_subscribers_group=admins_group
        )


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0408_stream_can_remove_subscribers_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_remove_subscribers_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0410_alter_stream_can_remove_subscribers_group.py]---
Location: zulip-main/zerver/migrations/0410_alter_stream_can_remove_subscribers_group.py
Signals: Django

```python
# Generated by Django 4.0.6 on 2022-07-22 14:47

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0409_set_default_for_can_remove_subscribers_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="stream",
            name="can_remove_subscribers_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT, to="zerver.usergroup"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0411_alter_muteduser_muted_user_and_more.py]---
Location: zulip-main/zerver/migrations/0411_alter_muteduser_muted_user_and_more.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-15 09:27

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0410_alter_stream_can_remove_subscribers_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="muteduser",
            name="muted_user",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="muted",
                to=settings.AUTH_USER_MODEL,
            ),
        ),
        migrations.AlterField(
            model_name="muteduser",
            name="user_profile",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="muter",
                to=settings.AUTH_USER_MODEL,
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0412_customprofilefield_display_in_profile_summary.py]---
Location: zulip-main/zerver/migrations/0412_customprofilefield_display_in_profile_summary.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-19 17:28

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0411_alter_muteduser_muted_user_and_more"),
    ]

    operations = [
        migrations.AddField(
            model_name="customprofilefield",
            name="display_in_profile_summary",
            field=models.BooleanField(default=False),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0413_set_presence_enabled_false_for_user_status_away.py]---
Location: zulip-main/zerver/migrations/0413_set_presence_enabled_false_for_user_status_away.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-21 15:01

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps

AWAY = 1


# Set presence_enabled to False for all users with a UserStatus.status of AWAY.
def set_presence_enabled_false_if_user_status_away(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserProfile = apps.get_model("zerver", "UserProfile")
    UserProfile.objects.filter(userstatus__status=AWAY).update(presence_enabled=False)


# Set UserStatus.status to AWAY for all users with presence_enabled False.
def set_userstatus_away_if_presence_enabled_false(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserStatus = apps.get_model("zerver", "UserStatus")
    UserStatus.objects.filter(user_profile__presence_enabled=False).update(status=AWAY)


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0412_customprofilefield_display_in_profile_summary"),
    ]

    operations = [
        migrations.RunPython(
            set_presence_enabled_false_if_user_status_away,
            reverse_code=set_userstatus_away_if_presence_enabled_false,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0414_remove_userstatus_status.py]---
Location: zulip-main/zerver/migrations/0414_remove_userstatus_status.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-22 12:12

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0413_set_presence_enabled_false_for_user_status_away"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="userstatus",
            name="status",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0415_delete_scimclient.py]---
Location: zulip-main/zerver/migrations/0415_delete_scimclient.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-24 06:32

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0414_remove_userstatus_status"),
    ]

    operations = [
        migrations.DeleteModel(
            name="SCIMClient",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0416_set_default_emoji_style.py]---
Location: zulip-main/zerver/migrations/0416_set_default_emoji_style.py
Signals: Django

```python
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def update_deprecated_emoji_style(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    """
    This migration updates the emoji style for users who are using the
    deprecated Google blob style. Unless they are part of an organization
    which has Google blob as an organization default, these users will
    now use the modern Google emoji style.
    """

    UserProfile = apps.get_model("zerver", "UserProfile")
    RealmUserDefault = apps.get_model("zerver", "RealmUserDefault")

    UserProfile.objects.filter(emojiset="google-blob").exclude(
        realm__in=RealmUserDefault.objects.filter(emojiset="google-blob").values("realm")
    ).update(emojiset="google")


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0415_delete_scimclient"),
    ]

    operations = [
        migrations.RunPython(update_deprecated_emoji_style, elidable=True),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0417_alter_customprofilefield_field_type.py]---
Location: zulip-main/zerver/migrations/0417_alter_customprofilefield_field_type.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-10-04 13:59

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0416_set_default_emoji_style"),
    ]

    operations = [
        migrations.AlterField(
            model_name="customprofilefield",
            name="field_type",
            field=models.PositiveSmallIntegerField(
                choices=[
                    (4, "Date"),
                    (7, "External account"),
                    (5, "Link"),
                    (3, "List of options"),
                    (8, "Pronouns"),
                    (2, "Text (long)"),
                    (1, "Text (short)"),
                    (6, "Users"),
                ],
                default=1,
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0418_archivedmessage_realm_message_realm.py]---
Location: zulip-main/zerver/migrations/0418_archivedmessage_realm_message_realm.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-26 21:02

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0417_alter_customprofilefield_field_type"),
    ]

    operations = [
        migrations.AddField(
            model_name="archivedmessage",
            name="realm",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.CASCADE, to="zerver.realm"
            ),
        ),
        migrations.AddField(
            model_name="message",
            name="realm",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.CASCADE, to="zerver.realm"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0419_backfill_message_realm.py]---
Location: zulip-main/zerver/migrations/0419_backfill_message_realm.py
Signals: Django

```python
from django.conf import settings
from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Exists, Max, OuterRef, Subquery


def backfill_message_realm(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    RECIPIENT_PERSONAL = 1
    RECIPIENT_STREAM = 2
    RECIPIENT_HUDDLE = 3

    Message = apps.get_model("zerver", "Message")
    ArchivedMessage = apps.get_model("zerver", "ArchivedMessage")
    Recipient = apps.get_model("zerver", "Recipient")
    Subscription = apps.get_model("zerver", "Subscription")
    Stream = apps.get_model("zerver", "Stream")
    UserProfile = apps.get_model("zerver", "UserProfile")
    Huddle = apps.get_model("zerver", "Huddle")

    print()

    print("Deleting dangling Recipient objects and their messages, which are inaccessible.")
    Recipient.objects.annotate(
        has_object=Exists(UserProfile.objects.filter(id=OuterRef("type_id")))
    ).filter(type=RECIPIENT_PERSONAL, has_object=False).delete()
    Recipient.objects.annotate(
        has_object=Exists(Stream.objects.filter(id=OuterRef("type_id")))
    ).filter(type=RECIPIENT_STREAM, has_object=False).delete()
    Recipient.objects.annotate(
        has_object=Exists(Huddle.objects.filter(id=OuterRef("type_id")))
    ).filter(type=RECIPIENT_HUDDLE, has_object=False).delete()

    BATCH_SIZE = 10000
    for message_model in [Message, ArchivedMessage]:
        lower_bound = 1

        max_id = message_model.objects.aggregate(Max("id"))["id__max"]
        if max_id is None:
            continue

        while lower_bound <= max_id:
            # Django's range() function is inclusive on both ends.
            upper_bound = lower_bound + BATCH_SIZE - 1
            print(f"Processing batch {lower_bound} to {upper_bound} for {message_model.__name__}")

            with transaction.atomic():
                message_model.objects.filter(
                    id__range=(lower_bound, upper_bound),
                    recipient__type=RECIPIENT_STREAM,
                ).update(
                    realm=Subquery(
                        Recipient.objects.filter(pk=OuterRef("recipient")).values("stream__realm")
                    )
                )

                # Private message to cross-realm bots are a special case, and the .realm
                # of the message should be realm of the sender.
                message_model.objects.filter(
                    id__range=(lower_bound, upper_bound),
                    recipient__type=RECIPIENT_PERSONAL,
                    recipient__userprofile__delivery_email__in=settings.CROSS_REALM_BOT_EMAILS,
                ).update(
                    realm=Subquery(
                        UserProfile.objects.filter(pk=OuterRef("sender")).values("realm")
                    )
                )

                message_model.objects.filter(
                    id__range=(lower_bound, upper_bound),
                    recipient__type=RECIPIENT_PERSONAL,
                ).exclude(
                    recipient__userprofile__delivery_email__in=settings.CROSS_REALM_BOT_EMAILS
                ).update(
                    realm=Subquery(
                        Recipient.objects.filter(pk=OuterRef("recipient")).values(
                            "userprofile__realm"
                        )
                    )
                )

                # Huddles don't have a direct way of finding their
                # realm, so we have to go through the Subscription
                # table. For huddles including a cross-realm bot, all
                # of the other users will be in the same realm, so
                # just find any of those users to get the message's realm.
                message_model.objects.filter(
                    id__range=(lower_bound, upper_bound),
                    recipient__type=RECIPIENT_HUDDLE,
                ).update(
                    realm=Subquery(
                        Subscription.objects.filter(recipient=OuterRef("recipient"))
                        .exclude(user_profile__delivery_email__in=settings.CROSS_REALM_BOT_EMAILS)
                        .values("user_profile__realm")[:1]
                    )
                )

            lower_bound += BATCH_SIZE


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0418_archivedmessage_realm_message_realm"),
    ]

    operations = [
        migrations.RunPython(
            backfill_message_realm,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0420_alter_archivedmessage_realm_alter_message_realm.py]---
Location: zulip-main/zerver/migrations/0420_alter_archivedmessage_realm_alter_message_realm.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-28 13:59

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0419_backfill_message_realm"),
    ]

    operations = [
        migrations.AlterField(
            model_name="archivedmessage",
            name="realm",
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to="zerver.realm"),
        ),
        migrations.AlterField(
            model_name="message",
            name="realm",
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to="zerver.realm"),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0421_migrate_pronouns_custom_profile_fields.py]---
Location: zulip-main/zerver/migrations/0421_migrate_pronouns_custom_profile_fields.py
Signals: Django

```python
# Generated by Django 4.1.2 on 2022-10-21 06:31

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def migrate_pronouns_custom_profile_fields(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    CustomProfileField = apps.get_model("zerver", "CustomProfileField")
    SHORT_TEXT = 1
    PRONOUNS = 8

    CustomProfileField.objects.filter(field_type=SHORT_TEXT, name__icontains="pronoun").update(
        field_type=PRONOUNS
    )


def reverse_migrate_pronouns_custom_profile_fields(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    CustomProfileField = apps.get_model("zerver", "CustomProfileField")
    SHORT_TEXT = 1
    PRONOUNS = 8

    CustomProfileField.objects.filter(field_type=PRONOUNS).update(field_type=SHORT_TEXT)


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0420_alter_archivedmessage_realm_alter_message_realm"),
    ]

    operations = [
        migrations.RunPython(
            migrate_pronouns_custom_profile_fields,
            reverse_code=reverse_migrate_pronouns_custom_profile_fields,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0422_multiuseinvite_status.py]---
Location: zulip-main/zerver/migrations/0422_multiuseinvite_status.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-11 22:03

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0421_migrate_pronouns_custom_profile_fields"),
    ]

    operations = [
        migrations.AddField(
            model_name="multiuseinvite",
            name="status",
            field=models.IntegerField(default=0),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0423_fix_email_gateway_attachment_owner.py]---
Location: zulip-main/zerver/migrations/0423_fix_email_gateway_attachment_owner.py
Signals: Django

```python
from datetime import timedelta

from django.conf import settings
from django.db import connection, migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from psycopg2.sql import SQL, Identifier, Literal


def fix_email_gateway_attachment_owner(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    UserProfile = apps.get_model("zerver", "UserProfile")
    Client = apps.get_model("zerver", "Client")
    Message = apps.get_model("zerver", "Message")
    ArchivedMessage = apps.get_model("zerver", "ArchivedMessage")
    Stream = apps.get_model("zerver", "Stream")
    Attachment = apps.get_model("zerver", "Attachment")
    ArchivedAttachment = apps.get_model("zerver", "ArchivedAttachment")

    if not Realm.objects.exists():
        return

    mail_gateway_bot = UserProfile.objects.get(email__iexact=settings.EMAIL_GATEWAY_BOT)

    # "Internal" is the client-id of all mail gateway posts
    internal_client, _ = Client.objects.get_or_create(name="Internal")

    # We only look in Attachment and not ArchivedAttachment because,
    # never having been associated with a message, there is no way for
    # the attachments to have been archived.
    orphan_attachments = Attachment.objects.filter(
        messages=None,
        owner_id=mail_gateway_bot.id,
    )
    if len(orphan_attachments) == 0:
        return

    print()
    print(f"Found {len(orphan_attachments)} email gateway attachments to reattach")
    for attachment in orphan_attachments:
        # We look for the message posted by "Internal" at the same
        # time, in the same realm, which has a link to the attachment
        # but no "has_attachments".  There are potentially other,
        # later, messages (possibly from other users, to other
        # places!) which tried to link to the attachment; we do not
        # fix those references, because finding them efficiently is
        # quite hard, as is calculating if they "should" have had
        # access to the attachment at the time.
        print(
            f"Looking for a message to attach {attachment.path_id}, created {attachment.create_time}"
        )
        possible_matches = []
        for model_class in (Message, ArchivedMessage):
            possible_matches.extend(
                # All messages with this bug will have
                # `has_attachment=False`, since they failed to attach
                # the contents.  However, we cannot limit to
                # sender=mail_gateway_bot because they were sent "as"
                # some other user.
                model_class.objects.filter(
                    has_attachment=False,
                    realm_id=attachment.realm_id,
                    sending_client_id=internal_client.id,
                    date_sent__gte=attachment.create_time,
                    date_sent__lte=attachment.create_time + timedelta(minutes=5),
                    content__contains="/user_uploads/" + attachment.path_id,
                ).order_by("date_sent")
            )
        if len(possible_matches) == 0:
            print("  No matches!")
            continue

        # If there are 1 or more matches, we assume the earliest is
        # the correct one, since it's ~impossible to have predicted
        # the URL before it was first sent.
        message = possible_matches[0]
        print(f"  Found {message.id} @ {message.date_sent} by {message.sender.delivery_email})")

        # If this is an ArchivedMessage, then we have to move the
        # Attachment into an ArchivedAttachment.  We also have to
        # generate an zerver_archivedattachment_message row with an id
        # based on the next free from zerver_attachment_message, since
        # those are one id space.
        if isinstance(message, ArchivedMessage):
            # move_rows
            fields = list(Attachment._meta.fields)
            src_fields = [Identifier("zerver_attachment", field.column) for field in fields]
            dst_fields = [Identifier(field.column) for field in fields]
            with connection.cursor() as cursor:
                raw_query = SQL(
                    """
                    INSERT INTO zerver_archivedattachment ({dst_fields})
                        SELECT {src_fields}
                        FROM zerver_attachment
                        WHERE id = {id}
                    ON CONFLICT (id) DO NOTHING
                    RETURNING id
                    """
                )
                cursor.execute(
                    raw_query.format(
                        src_fields=SQL(",").join(src_fields),
                        dst_fields=SQL(",").join(dst_fields),
                        id=Literal(attachment.id),
                    )
                )
                archived_ids = [id for (id,) in cursor.fetchall()]
                if len(archived_ids) != 1:
                    print("!!! Did not create one archived attachment row!")
            attachment.delete()
            attachment = ArchivedAttachment.objects.get(id=archived_ids[0])

        # Determine message (and thus attachment) properties; this is
        # from do_claim_attachments
        is_message_realm_public = False
        is_message_web_public = False
        if message.recipient.type == 2:  # Recipient.STREAM
            stream = Stream.objects.get(id=message.recipient.type_id)
            is_message_realm_public = not stream.invite_only and not stream.is_in_zephyr_realm
            is_message_web_public = stream.is_web_public

        attachment.owner_id = message.sender_id
        attachment.is_web_public = is_message_web_public
        attachment.is_realm_public = is_message_realm_public
        attachment.save(update_fields=["owner_id", "is_web_public", "is_realm_public"])

        if isinstance(attachment, ArchivedAttachment):
            assert isinstance(message, ArchivedMessage)
            # We need to use the sequence from
            # zerver_attachment_messages, since that id is reused when
            # restoring the message.
            with connection.cursor() as cursor:
                raw_query = SQL(
                    """
                    INSERT INTO zerver_archivedattachment_messages
                           (id, archivedattachment_id, archivedmessage_id)
                    VALUES (nextval(pg_get_serial_sequence('zerver_attachment_messages', 'id')),
                            {attachment_id}, {message_id})
                    """
                )
                cursor.execute(
                    raw_query.format(
                        attachment_id=Literal(attachment.id),
                        message_id=Literal(message.id),
                    )
                )
        else:
            assert isinstance(message, Message)
            attachment.messages.add(message)

        message.has_attachment = True
        message.save(update_fields=["has_attachment"])


class Migration(migrations.Migration):
    """
    Messages sent "as" a user via the email gateway had their
    attachments left orphan, accidentally owned by the email gateway
    bot.  Find each such orphaned attachment, and re-own it and attach
    it to the appropriate message.

    """

    dependencies = [
        ("zerver", "0422_multiuseinvite_status"),
    ]

    operations = [
        migrations.RunPython(
            fix_email_gateway_attachment_owner,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0424_realm_move_messages_within_stream_limit_seconds.py]---
Location: zulip-main/zerver/migrations/0424_realm_move_messages_within_stream_limit_seconds.py
Signals: Django

```python
# Generated by Django 4.1.5 on 2023-01-26 14:27

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0423_fix_email_gateway_attachment_owner"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="move_messages_within_stream_limit_seconds",
            field=models.PositiveIntegerField(default=604800, null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0425_realm_move_messages_between_streams_limit_seconds.py]---
Location: zulip-main/zerver/migrations/0425_realm_move_messages_between_streams_limit_seconds.py
Signals: Django

```python
# Generated by Django 4.1.5 on 2023-01-26 14:28

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0424_realm_move_messages_within_stream_limit_seconds"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="move_messages_between_streams_limit_seconds",
            field=models.PositiveIntegerField(default=604800, null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0426_add_email_address_visibility_setting.py]---
Location: zulip-main/zerver/migrations/0426_add_email_address_visibility_setting.py
Signals: Django

```python
# Generated by Django 3.2.8 on 2021-10-21 07:23

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0425_realm_move_messages_between_streams_limit_seconds"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmuserdefault",
            name="email_address_visibility",
            field=models.PositiveSmallIntegerField(default=1),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="email_address_visibility",
            field=models.PositiveSmallIntegerField(default=1),
        ),
    ]
```

--------------------------------------------------------------------------------

````
