---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:13Z
part: 607
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 607 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: tableJson.ts]---
Location: payload-main/test/lexical-mdx/tableJson.ts

```typescript
export const tableJson = {
  children: [
    {
      children: [
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' Option            ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 1,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' Default route           ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 1,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' Description                                     ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 1,
          rowSpan: 1,
        },
      ],
      direction: null,
      format: '',
      indent: 0,
      type: 'tablerow',
      version: 1,
    },
    {
      children: [
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' ',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 16,
                  mode: 'normal',
                  style: '',
                  text: 'account',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' *         ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: '                         ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: " The user's account page.                        ",
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
      ],
      direction: null,
      format: '',
      indent: 0,
      type: 'tablerow',
      version: 1,
    },
    {
      children: [
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' ',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 16,
                  mode: 'normal',
                  style: '',
                  text: 'createFirstUser',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' ',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 16,
                  mode: 'normal',
                  style: '',
                  text: '/create-first-user',
                  type: 'text',
                  version: 1,
                },
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: '    ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
        {
          children: [
            {
              children: [
                {
                  detail: 0,
                  format: 0,
                  mode: 'normal',
                  style: '',
                  text: ' The page to create the first user.              ',
                  type: 'text',
                  version: 1,
                },
              ],
              direction: null,
              format: '',
              indent: 0,
              type: 'paragraph',
              version: 1,
              textFormat: 0,
              textStyle: '',
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          type: 'tablecell',
          version: 1,
          backgroundColor: null,
          colSpan: 1,
          headerState: 0,
          rowSpan: 1,
        },
      ],
      direction: null,
      format: '',
      indent: 0,
      type: 'tablerow',
      version: 1,
    },
  ],
  direction: null,
  format: '',
  indent: 0,
  type: 'table',
  version: 1,
}
```

--------------------------------------------------------------------------------

---[FILE: textToRichText.ts]---
Location: payload-main/test/lexical-mdx/textToRichText.ts

```typescript
export function textToRichText(text: string) {
  return {
    root: {
      children: [
        {
          children: [
            {
              detail: 0,
              format: 0,
              mode: 'normal',
              style: '',
              text,
              type: 'text',
              version: 1,
            },
          ],
          direction: null,
          format: '',
          indent: 0,
          textFormat: 0,
          textStyle: '',
          type: 'paragraph',
          version: 1,
        },
      ],
      direction: null,
      format: '',
      indent: 0,
      type: 'root',
      version: 1,
    },
  }
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/lexical-mdx/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.json]---
Location: payload-main/test/lexical-mdx/tsconfig.json

```json
{
  "extends": "../tsconfig.json"
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/lexical-mdx/collections/Media/index.ts

```typescript
import type { CollectionConfig } from 'payload'

export const mediaSlug = 'media'

export const MediaCollection: CollectionConfig = {
  slug: mediaSlug,
  access: {
    create: () => true,
    read: () => true,
  },
  fields: [],
  upload: {
    crop: true,
    focalPoint: true,
    imageSizes: [
      {
        name: 'thumbnail',
        height: 200,
        width: 200,
      },
      {
        name: 'medium',
        height: 800,
        width: 800,
      },
      {
        name: 'large',
        height: 1200,
        width: 1200,
      },
    ],
  },
}
```

--------------------------------------------------------------------------------

---[FILE: CodeFields.tsx]---
Location: payload-main/test/lexical-mdx/collections/Posts/CodeFields.tsx
Signals: React

```typescript
'use client'

import type { CodeFieldClient, CodeFieldClientProps } from 'payload'

import { CodeField, useFormFields } from '@payloadcms/ui'
import React, { useMemo } from 'react'

import { languages } from './shared.js'

const languageKeyToMonacoLanguageMap = {
  plaintext: 'plaintext',
  ts: 'typescript',
  tsx: 'typescript',
}

export const Code: React.FC<CodeFieldClientProps> = ({
  autoComplete,
  field,
  forceRender,
  path,
  permissions,
  readOnly,
  renderedBlocks,
  schemaPath,
  validate,
}) => {
  const languageField = useFormFields(([fields]) => fields['language'])

  const language: string =
    (languageField?.value as string) || (languageField.initialValue as string) || 'typescript'

  const label = languages[language as keyof typeof languages]

  const props: CodeFieldClient = useMemo<CodeFieldClient>(
    () => ({
      ...field,
      type: 'code',
      admin: {
        ...field.admin,
        description: 'test',
        editorOptions: {
          onMount: (editor, monaco) => {
            // Set module resolution to NodeNext to enable autocompletion
            monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
              allowNonTsExtensions: true,
              module: monaco.languages.typescript.ModuleKind.ESNext,
              moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
              target: monaco.languages.typescript.ScriptTarget.ESNext,
              typeRoots: ['node_modules/@types'],
            })

            monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
              noSemanticValidation: false,
              noSyntaxValidation: false,
            })

            const libUri = 'node_modules/@types/payload/index.d.ts'

            const run = async () => {
              const types = await fetch('https://unpkg.com/payload@latest/dist/index.d.ts')
              const libSource = await types.text()
              monaco.languages.typescript.typescriptDefaults.addExtraLib(libSource, libUri)
            }
            void run()
          },
        } as any,
        label,
        language: languageKeyToMonacoLanguageMap[language] || language,
      },
    }),
    [field, language, label],
  )

  const key = `${field.name}-${language}-${label}`

  return (
    props && (
      <CodeField
        autoComplete={autoComplete}
        field={props}
        forceRender={forceRender}
        key={key}
        onMount={(editor, monaco) => {
          console.log('editor mounted')
          // Set module resolution to NodeNext to enable autocompletion
          monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
            allowNonTsExtensions: true,
            moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
            paths: {
              payload: ['file:///node_modules/payload/index.d.ts'],
            },
            target: monaco.languages.typescript.ScriptTarget.ESNext,
            typeRoots: ['node_modules/@types', 'node_modules/payload'],
          })
          const run = async () => {
            const types = await fetch('https://unpkg.com/payload@latest/dist/index.d.ts')
            const typesText = await types.text()
            monaco.languages.typescript.typescriptDefaults.addExtraLib(
              typesText,
              'file:///node_modules/payload/index.d.ts',
            )
          }
          void run()
        }}
        path={path}
        permissions={permissions}
        readOnly={readOnly}
        renderedBlocks={renderedBlocks}
        schemaPath={schemaPath}
        validate={validate}
      />
    )
  )
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/lexical-mdx/collections/Posts/index.ts

```typescript
import type { CollectionConfig } from 'payload'

import {
  BlocksFeature,
  EXPERIMENTAL_TableFeature,
  FixedToolbarFeature,
  lexicalEditor,
  TreeViewFeature,
} from '@payloadcms/richtext-lexical'

import { loadMDXAfterRead, saveMDXBeforeChange } from '../../mdx/hooks.js'
import { BannerBlock } from '../../mdx/jsxBlocks/banner.js'
import { CodeBlock } from '../../mdx/jsxBlocks/code/code.js'
import { InlineCodeBlock } from '../../mdx/jsxBlocks/inlineCode.js'
import { PackageInstallOptions } from '../../mdx/jsxBlocks/packageInstallOptions.js'
import { RestExamplesBlock } from '../../mdx/jsxBlocks/restExamples/index.js'
import { TextContainerBlock } from '../../mdx/jsxBlocks/TextContainer.js'
import { TextContainerNoTrimBlock } from '../../mdx/jsxBlocks/TextContainerNoTrim.js'

export const postsSlug = 'posts'

export const PostsCollection: CollectionConfig = {
  slug: postsSlug,
  admin: {
    useAsTitle: 'docPath',
  },
  hooks: {
    beforeChange: [saveMDXBeforeChange],
    afterRead: [loadMDXAfterRead],
  },
  fields: [
    {
      name: 'docPath',
      type: 'text',
      required: true,
    },
    {
      type: 'collapsible',
      label: 'FrontMatter',
      admin: {
        position: 'sidebar',
      },
      fields: [
        {
          name: 'frontMatter',
          type: 'array',
          fields: [
            {
              type: 'text',
              name: 'key',
            },
            {
              type: 'text',
              name: 'value',
            },
          ],
        },
      ],
    },
    {
      name: 'richText',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          TreeViewFeature(),
          EXPERIMENTAL_TableFeature(),
          FixedToolbarFeature(),
          BlocksFeature({
            blocks: [
              BannerBlock,
              CodeBlock,
              PackageInstallOptions,
              TextContainerNoTrimBlock,
              TextContainerBlock,
              RestExamplesBlock,
            ],
            inlineBlocks: [InlineCodeBlock],
          }),
        ],
      }),
    },
    {
      name: 'richTextUnconverted',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          TreeViewFeature(),
          EXPERIMENTAL_TableFeature(),
          FixedToolbarFeature(),
          BlocksFeature({
            blocks: [
              BannerBlock,
              CodeBlock,
              PackageInstallOptions,
              TextContainerNoTrimBlock,
              TextContainerBlock,
              RestExamplesBlock,
            ],
            inlineBlocks: [InlineCodeBlock],
          }),
        ],
      }),
    },
  ],
  versions: {
    drafts: true,
  },
}
```

--------------------------------------------------------------------------------

---[FILE: shared.ts]---
Location: payload-main/test/lexical-mdx/collections/Posts/shared.ts

```typescript
import path from 'path'
import { fileURLToPath } from 'url'

export const docsBasePath =
  typeof window === 'undefined'
    ? path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../../sampleDocs')
    : null
export const languages = {
  ts: 'TypeScript',
  plaintext: 'Plain Text',
  tsx: 'TSX',
  js: 'JavaScript',
  jsx: 'JSX',
}

export const bannerTypes = {
  success: 'Success',
  info: 'Info',
  warning: 'Warning',
}
```

--------------------------------------------------------------------------------

---[FILE: hooks.ts]---
Location: payload-main/test/lexical-mdx/mdx/hooks.ts

```typescript
import type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'
import type { CollectionAfterReadHook, CollectionBeforeChangeHook, RichTextField } from 'payload'

import {
  $convertFromMarkdownString,
  extractFrontmatter,
  frontmatterToObject,
  getEnabledNodes,
  type LexicalRichTextAdapter,
  objectToFrontmatter,
  type SanitizedServerEditorConfig,
} from '@payloadcms/richtext-lexical'
import { createHeadlessEditor } from '@payloadcms/richtext-lexical/lexical/headless'
import { $convertToMarkdownString } from '@payloadcms/richtext-lexical/lexical/markdown'
import fs from 'node:fs'
import path from 'path'
import { deepCopyObjectSimple } from 'payload'

import { docsBasePath } from '../collections/Posts/shared.js'

export const editorJSONToMDX = ({
  editorState,
  editorConfig,
  frontMatterData,
}: {
  editorConfig: SanitizedServerEditorConfig
  editorState: any
  frontMatterData?: any
}) => {
  const headlessEditor = createHeadlessEditor({
    nodes: getEnabledNodes({
      editorConfig,
    }),
  })

  // Convert lexical state to markdown
  // Import editor state into your headless editor
  try {
    headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState)) // This should commit the editor state immediately
  } catch (e) {
    console.error('Error parsing editor state', e)
  }

  // Export to markdown
  let markdown: string
  headlessEditor.getEditorState().read(() => {
    markdown = $convertToMarkdownString(editorConfig?.features?.markdownTransformers)
  })

  if (!frontMatterData) {
    return markdown
  }

  const frontMatterOriginalData = deepCopyObjectSimple(frontMatterData)

  //Frontmatter
  const frontmatterData = {}

  if (frontMatterOriginalData) {
    for (const frontMatterArrayEntry of frontMatterOriginalData) {
      frontmatterData[frontMatterArrayEntry.key] = frontMatterArrayEntry.value
    }

    const frontmatterString = objectToFrontmatter(frontmatterData)

    if (frontmatterString?.length) {
      markdown = frontmatterString + '\n' + markdown
    }
  }

  return markdown
}

export const saveMDXBeforeChange: CollectionBeforeChangeHook = ({ collection, data, context }) => {
  if (context.seed) {
    return data
  }
  const docFilePath = path.join(docsBasePath, data.docPath)

  const field: RichTextField = collection.fields.find(
    (field) => 'name' in field && field.name === 'richText',
  ) as RichTextField
  const value = data[field.name]

  const editorConfig: SanitizedServerEditorConfig = (field.editor as LexicalRichTextAdapter)
    .editorConfig

  const markdown = editorJSONToMDX({
    editorState: value,
    editorConfig,
    frontMatterData: data.frontMatter,
  })

  if (markdown?.trim()?.length) {
    // Write markdown to '../../../../docs/admin/overview.mdx'
    fs.writeFileSync(docFilePath, markdown, {
      encoding: 'utf-8',
    })
  }

  return null // Do not save anything to database
}

export function mdxToEditorJSON({
  mdxWithFrontmatter,
  editorConfig,
}: {
  editorConfig: SanitizedServerEditorConfig
  mdxWithFrontmatter: string
}): {
  editorState: SerializedEditorState
  frontMatter: { key: string; value: string }[]
} {
  const frontMatter = extractFrontmatter(mdxWithFrontmatter)

  const mdx = frontMatter.content

  const headlessEditor = createHeadlessEditor({
    nodes: getEnabledNodes({
      editorConfig,
    }),
  })

  headlessEditor.update(
    () => {
      $convertFromMarkdownString(mdx, editorConfig.features.markdownTransformers)
    },
    { discrete: true },
  )

  const frontMatterArray = frontMatter?.frontmatter?.length
    ? Object.entries(frontmatterToObject(frontMatter.frontmatter)).map(([key, value]) => ({
        key,
        value,
      }))
    : []

  return {
    editorState: headlessEditor.getEditorState().toJSON(),
    frontMatter: frontMatterArray,
  }
}

export const loadMDXAfterRead: CollectionAfterReadHook = ({ collection, doc, context }) => {
  if (context.seed) {
    return doc
  }
  const field: RichTextField = collection.fields.find(
    (field) => 'name' in field && field.name === 'richText',
  ) as RichTextField

  const docFilePath = path.join(docsBasePath, doc.docPath)

  const mdxWithFrontmatter = fs.readFileSync(docFilePath, {
    encoding: 'utf-8',
  })
  const editorConfig: SanitizedServerEditorConfig = (field.editor as LexicalRichTextAdapter)
    .editorConfig

  const result = mdxToEditorJSON({
    mdxWithFrontmatter,
    editorConfig,
  })

  return {
    ...doc,
    richText: result.editorState,
    frontMatter: result.frontMatter,
  }
}
```

--------------------------------------------------------------------------------

---[FILE: banner.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/banner.ts

```typescript
import type { Block } from 'payload'

import { BlocksFeature, lexicalEditor, TreeViewFeature } from '@payloadcms/richtext-lexical'

import { bannerTypes } from '../../collections/Posts/shared.js'
import { InlineCodeBlock } from './inlineCode.js'

export const BannerBlock: Block = {
  slug: 'Banner',
  jsx: {
    import: ({ props, children, markdownToLexical }) => {
      return {
        type: props?.type,
        content: markdownToLexical({ markdown: children }),
      }
    },
    export: ({ fields, lexicalToMarkdown }) => {
      const props: any = {}
      if (fields.type) {
        props.type = fields.type
      }

      return {
        props,
        children: lexicalToMarkdown({ editorState: fields.content }),
      }
    },
  },
  fields: [
    {
      type: 'select',
      name: 'type',
      options: Object.entries(bannerTypes).map(([key, value]) => ({
        label: value,
        value: key,
      })),
      defaultValue: 'info',
    },
    {
      name: 'content',
      type: 'richText',
      editor: lexicalEditor({
        features: ({ defaultFeatures }) => [
          ...defaultFeatures,
          TreeViewFeature(),
          BlocksFeature({
            inlineBlocks: [InlineCodeBlock],
          }),
        ],
      }),
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: inlineCode.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/inlineCode.ts

```typescript
import type { Block } from 'payload'

export const InlineCodeBlock: Block = {
  slug: 'InlineCode',
  jsx: {
    import: ({ children }) => {
      return {
        code: children,
      }
    },
    export: ({ fields }) => {
      return {
        props: {},
        children: fields.code,
      }
    },
  },
  fields: [
    {
      name: 'code',
      type: 'code',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: packageInstallOptions.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/packageInstallOptions.ts

```typescript
import type { Block } from 'payload'

export const PackageInstallOptions: Block = {
  slug: 'PackageInstallOptions',
  jsx: {
    import: ({ props, children, markdownToLexical }) => {
      return {
        global: props?.global,
        packageId: props?.packageId,
        someNestedObject: props?.someNestedObject,
        uniqueId: props?.uniqueId,
        update: props?.update,
        someObject: props?.someObject,
      }
    },
    export: ({ fields, lexicalToMarkdown }) => {
      return {
        props: {
          global: fields?.global,
          packageId: fields?.packageId,
          someNestedObject: fields?.someNestedObject,
          uniqueId: fields?.uniqueId,
          update: fields?.update,
          someObject: fields?.someObject,
        },
      }
    },
  },
  fields: [
    {
      name: 'packageId',
      type: 'textarea',
    },
    {
      name: 'global',
      type: 'checkbox',
    },
    {
      name: 'someObject',
      type: 'json',
    },
    {
      name: 'update',
      type: 'checkbox',
    },
    {
      name: 'uniqueId',
      type: 'text',
    },
    {
      name: 'someNestedObject',
      type: 'code',
      admin: {
        hidden: true,
      },
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: TextContainer.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/TextContainer.ts

```typescript
import type { Block } from 'payload'

export const TextContainerBlock: Block = {
  slug: 'TextContainer',
  jsx: {
    import: ({ children }) => {
      return {
        text: children,
      }
    },
    export: ({ fields }) => {
      return {
        props: {},
        children: fields.text,
      }
    },
  },
  fields: [
    {
      name: 'text',
      type: 'text',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: TextContainerNoTrim.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/TextContainerNoTrim.ts

```typescript
import type { Block } from 'payload'

export const TextContainerNoTrimBlock: Block = {
  slug: 'TextContainerNoTrim',
  jsx: {
    import: ({ children }) => {
      return {
        text: children,
      }
    },
    export: ({ fields }) => {
      return {
        props: {},
        children: fields.text,
      }
    },
    doNotTrimChildren: true,
  },
  fields: [
    {
      name: 'text',
      type: 'text',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: code.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/code/code.ts

```typescript
import type { Block } from 'payload'

import { languages } from '../../../collections/Posts/shared.js'
import { codeConverter } from './converter.js'

export const CodeBlock: Block = {
  slug: 'Code',
  admin: {
    jsx: './mdx/jsxBlocks/code/converterClient.js#codeConverterClient',
  },
  jsx: codeConverter,
  fields: [
    {
      type: 'select',
      name: 'language',
      options: Object.entries(languages).map(([key, value]) => ({
        label: value,
        value: key,
      })),
      defaultValue: 'ts',
    },
    {
      admin: {
        components: {
          Field: './collections/Posts/CodeFields.js#Code',
        },
      },
      name: 'code',
      type: 'code',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: converter.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/code/converter.ts

```typescript
import type { BlockJSX } from 'payload'

export const codeConverter: BlockJSX = {
  customStartRegex: /^[ \t]*```(\w+)?/,
  customEndRegex: {
    optional: true,
    regExp: /[ \t]*```$/,
  },
  doNotTrimChildren: true,
  import: ({ openMatch, children, closeMatch }) => {
    const language = openMatch[1]

    // Removed first and last \n from children if present
    if (children.startsWith('\n')) {
      children = children.slice(1)
    }
    if (children.endsWith('\n')) {
      children = children.slice(0, -1)
    }

    const isSingleLineAndComplete =
      !!closeMatch && !children.includes('\n') && openMatch.input?.trim() !== '```' + language

    if (isSingleLineAndComplete) {
      return {
        language: '',
        code: language + (children?.length ? children : ''), // No need to add space to children as they are not trimmed
      }
    }

    return {
      language,
      code: children,
    }
  },
  export: ({ fields }) => {
    const isSingleLine = !fields.code.includes('\n') && !fields.language?.length
    if (isSingleLine) {
      return '```' + fields.code + '```'
    }

    return '```' + (fields.language || '') + (fields.code ? '\n' + fields.code : '') + '\n' + '```'
  },
}
```

--------------------------------------------------------------------------------

---[FILE: converterClient.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/code/converterClient.ts

```typescript
'use client'

export { codeConverter as codeConverterClient } from './converter.js'
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/lexical-mdx/mdx/jsxBlocks/restExamples/index.ts

```typescript
import type { Block } from 'payload'

export const RestExamplesBlock: Block = {
  slug: 'restExamples',
  fields: [
    {
      name: 'data',
      type: 'array',
      fields: [
        {
          name: 'operation',
          type: 'text',
        },
        {
          name: 'method',
          type: 'text',
        },
        {
          name: 'path',
          type: 'text',
        },
        {
          name: 'description',
          type: 'text',
        },
        {
          name: 'example',
          type: 'group',
          fields: [
            {
              name: 'slug',
              type: 'text',
            },
            {
              name: 'req',
              type: 'json',
            },
            {
              name: 'res',
              type: 'json',
            },
            {
              name: 'drawerContent',
              type: 'textarea',
            },
          ],
        },
      ],
    },
  ],
  interfaceName: 'RestExamplesBlock',
  jsx: {
    export: ({ fields, lexicalToMarkdown }) => {
      return {
        props: {
          data: fields.data.map((item) => {
            return {
              ...item,
              example: {
                ...item.example,
                drawerContent:
                  lexicalToMarkdown && item.example.drawerContent
                    ? item.example.drawerContent
                    : undefined,
              },
            }
          }),
        },
      }
    },
    import: ({ children, markdownToLexical, props }) => {
      return {
        data: props.data.map((item) => {
          return {
            ...item,
            example: {
              ...item.example,
              drawerContent:
                markdownToLexical && item.example.drawerContent
                  ? item.example.drawerContent
                  : undefined,
            },
          }
        }),
      }
    },
  },
}
```

--------------------------------------------------------------------------------

---[FILE: test.mdx]---
Location: payload-main/test/lexical-mdx/sampleDocs/test.mdx

```text
# You can write MDX here

Write whatever content you want for testing purposes
```

--------------------------------------------------------------------------------

---[FILE: code1.input.mdx]---
Location: payload-main/test/lexical-mdx/tests/code1.input.mdx

```text
```ts
import { buildConfig } from 'payload'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

export default buildConfig({
  collections: [
    // your collections here
  ],
  // Pass the Lexical editor to the root config
  editor: lexicalEditor({}),
})
```
```

--------------------------------------------------------------------------------

---[FILE: code1.output.json]---
Location: payload-main/test/lexical-mdx/tests/code1.output.json

```json
{
  "editorState": {
    "root": {
      "children": [
        {
          "format": "",
          "type": "block",
          "version": 2,
          "fields": {
            "blockType": "Code",
            "language": "ts",
            "code": "import { buildConfig } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nexport default buildConfig({\n  collections: [\n    // your collections here\n  ],\n  // Pass the Lexical editor to the root config\n  editor: lexicalEditor({}),\n})",
            "id": "6774559ba09e004452672523"
          }
        }
      ],
      "direction": null,
      "format": "",
      "indent": 0,
      "type": "root",
      "version": 1
    }
  },
  "frontMatter": []
}
```

--------------------------------------------------------------------------------

---[FILE: code1.test.ts]---
Location: payload-main/test/lexical-mdx/tests/code1.test.ts

```typescript
import { readFileSync } from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

import type { Test } from '../int.spec.js'

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

export const codeTest1: Test = {
  input: readFileSync(path.resolve(dirname, 'code1.input.mdx'), 'utf-8'),
  rootChildren: JSON.parse(readFileSync(path.resolve(dirname, 'code1.output.json'), 'utf-8'))
    .editorState.root.children,
}
```

--------------------------------------------------------------------------------

````
