---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:14Z
part: 948
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 948 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: 0450_backfill_subscription_auditlogs.py]---
Location: zulip-main/zerver/migrations/0450_backfill_subscription_auditlogs.py
Signals: Django

```python
# Generated by Django 4.2 on 2023-04-19 18:18


from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max, Min
from django.utils.timezone import now as timezone_now


def backfill_missing_subscriptions(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    """Backfill subscription realm audit log events for users which are
    currently subscribed but don't have any, presumably due to some
    historical bug.  This is important because those rows are
    necessary when reactivating a user who is currently
    soft-deactivated.

    For each stream, we find the subscribed users who have no relevant
    realm audit log entries, and create a backfill=True subscription
    audit log entry which is the latest it could have been, based on
    UserMessage rows.

    """

    Stream = apps.get_model("zerver", "Stream")
    RealmAuditLog = apps.get_model("zerver", "RealmAuditLog")
    Subscription = apps.get_model("zerver", "Subscription")
    UserMessage = apps.get_model("zerver", "UserMessage")
    Message = apps.get_model("zerver", "Message")

    def get_last_message_id() -> int:
        # We generally use this function to populate RealmAuditLog, and
        # the max id here is actually system-wide, not per-realm.  I
        # assume there's some advantage in not filtering by realm.
        last_id = Message.objects.aggregate(Max("id"))["id__max"]
        if last_id is None:
            # During initial realm creation, there might be 0 messages in
            # the database; in that case, the `aggregate` query returns
            # None.  Since we want an int for "beginning of time", use -1.
            last_id = -1
        return last_id

    for stream in Stream.objects.all().iterator():
        with transaction.atomic():
            subscribed_user_ids = set(
                Subscription.objects.filter(recipient_id=stream.recipient_id).values_list(
                    "user_profile_id", flat=True
                )
            )
            user_ids_in_audit_log = set(
                RealmAuditLog.objects.filter(
                    realm=stream.realm,
                    event_type__in=[
                        301,  # RealmAuditLog.SUBSCRIPTION_CREATED
                        302,  # RealmAuditLog.SUBSCRIPTION_ACTIVATED
                        303,  # RealmAuditLog.SUBSCRIPTION_DEACTIVATED
                    ],
                    modified_stream=stream,
                )
                .distinct("modified_user_id")
                .values_list("modified_user_id", flat=True)
            )

            user_ids_missing_events = subscribed_user_ids - user_ids_in_audit_log
            if not user_ids_missing_events:
                continue

            last_message_id = get_last_message_id()
            now = timezone_now()
            backfills = []
            for user_id in sorted(user_ids_missing_events):
                print(
                    f"Backfilling subscription event for {user_id} in stream {stream.id} in realm {stream.realm.string_id}"
                )
                aggregated = UserMessage.objects.filter(
                    user_profile_id=user_id,
                    message__recipient=stream.recipient_id,
                ).aggregate(
                    earliest_date=Min("message__date_sent"),
                    earliest_message_id=Min("message_id"),
                    latest_date=Max("message__date_sent"),
                    latest_message_id=Max("message_id"),
                )

                # Assume we subscribed right before the first message we
                # saw -- or, if we don't see any, right now.  This makes
                # this safe for streams which do not have shared history.
                if aggregated["earliest_message_id"] is not None:
                    event_last_message_id = aggregated["earliest_message_id"] - 1
                else:
                    event_last_message_id = last_message_id
                if aggregated["earliest_date"] is not None:
                    event_time = aggregated["earliest_date"]
                else:
                    event_time = now
                log_event = RealmAuditLog(
                    event_time=event_time,
                    event_last_message_id=event_last_message_id,
                    backfilled=True,
                    event_type=301,  # RealmAuditLog.SUBSCRIPTION_CREATED
                    realm_id=stream.realm_id,
                    modified_user_id=user_id,
                    modified_stream_id=stream.id,
                )
                backfills.append(log_event)

                # If the subscription is not active, then we also need
                # to manufacture a SUBSCRIPTION_DEACTIVATED event,
                # which we assume to be whenever the last received
                # UserMessage row was.
                sub = Subscription.objects.get(
                    user_profile_id=user_id, recipient_id=stream.recipient_id
                )
                if sub.active:
                    continue
                if aggregated["latest_message_id"] is not None:
                    event_last_message_id = aggregated["latest_message_id"]
                else:
                    event_last_message_id = last_message_id
                if aggregated["latest_date"] is not None:
                    event_time = aggregated["latest_date"]
                else:
                    event_time = now
                deactivated_log_event = RealmAuditLog(
                    event_time=event_time,
                    event_last_message_id=event_last_message_id,
                    backfilled=True,
                    event_type=303,  # RealmAuditLog.SUBSCRIPTION_DEACTIVATED
                    realm_id=stream.realm_id,
                    modified_user_id=user_id,
                    modified_stream_id=stream.id,
                )
                backfills.append(deactivated_log_event)

            RealmAuditLog.objects.bulk_create(backfills)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0449_scheduledmessage_zerver_unsent_scheduled_messages_indexes"),
    ]

    operations = [
        migrations.RunPython(
            backfill_missing_subscriptions, reverse_code=migrations.RunPython.noop, elidable=True
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0451_add_userprofile_api_key_index.py]---
Location: zulip-main/zerver/migrations/0451_add_userprofile_api_key_index.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-05-18 15:20


from django.db import migrations, models

from zerver.lib.utils import generate_api_key


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0450_backfill_subscription_auditlogs"),
    ]

    operations = [
        migrations.AlterField(
            model_name="userprofile",
            name="api_key",
            field=models.CharField(default=generate_api_key, max_length=32, unique=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0452_realmauditlog_extra_data_json.py]---
Location: zulip-main/zerver/migrations/0452_realmauditlog_extra_data_json.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-30 20:25

import django
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0451_add_userprofile_api_key_index"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmauditlog",
            name="extra_data_json",
            field=models.JSONField(
                default=dict, encoder=django.core.serializers.json.DjangoJSONEncoder
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0453_followed_topic_notifications.py]---
Location: zulip-main/zerver/migrations/0453_followed_topic_notifications.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-05-24 11:09

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0452_realmauditlog_extra_data_json"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmuserdefault",
            name="enable_followed_topic_audible_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="realmuserdefault",
            name="enable_followed_topic_desktop_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="realmuserdefault",
            name="enable_followed_topic_email_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="realmuserdefault",
            name="enable_followed_topic_push_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="realmuserdefault",
            name="enable_followed_topic_wildcard_mentions_notify",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="enable_followed_topic_audible_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="enable_followed_topic_desktop_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="enable_followed_topic_email_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="enable_followed_topic_push_notifications",
            field=models.BooleanField(default=True),
        ),
        migrations.AddField(
            model_name="userprofile",
            name="enable_followed_topic_wildcard_mentions_notify",
            field=models.BooleanField(default=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0454_usergroup_can_mention_group.py]---
Location: zulip-main/zerver/migrations/0454_usergroup_can_mention_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:47

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0453_followed_topic_notifications"),
    ]

    operations = [
        migrations.AddField(
            model_name="usergroup",
            name="can_mention_group",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.RESTRICT, to="zerver.usergroup"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0455_set_default_for_can_mention_group.py]---
Location: zulip-main/zerver/migrations/0455_set_default_for_can_mention_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:47

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max, Min, OuterRef


def set_default_value_for_can_mention_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserGroup = apps.get_model("zerver", "UserGroup")

    BATCH_SIZE = 1000
    max_id = UserGroup.objects.filter(can_mention_group=None).aggregate(Max("id"))["id__max"]

    if max_id is None:
        # Do nothing if there are no UserGroups on the server.
        return

    lower_bound = UserGroup.objects.filter(can_mention_group=None).aggregate(Min("id"))["id__min"]
    while lower_bound <= max_id:
        upper_bound = lower_bound + BATCH_SIZE - 1
        print(f"Processing batch {lower_bound} to {upper_bound} for UserGroup")

        with transaction.atomic():
            UserGroup.objects.filter(
                id__range=(lower_bound, upper_bound), can_mention_group=None, is_system_group=True
            ).update(
                can_mention_group=UserGroup.objects.filter(
                    name="@role:nobody", realm=OuterRef("realm"), is_system_group=True
                ).values("pk")
            )

            UserGroup.objects.filter(
                id__range=(lower_bound, upper_bound), can_mention_group=None, is_system_group=False
            ).update(
                can_mention_group=UserGroup.objects.filter(
                    name="@role:everyone", realm=OuterRef("realm"), is_system_group=True
                ).values("pk")
            )

        lower_bound += BATCH_SIZE


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0454_usergroup_can_mention_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_mention_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0456_alter_usergroup_can_mention_group.py]---
Location: zulip-main/zerver/migrations/0456_alter_usergroup_can_mention_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:58

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0455_set_default_for_can_mention_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="usergroup",
            name="can_mention_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT, to="zerver.usergroup"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0457_backfill_scheduledmessagenotificationemail_trigger.py]---
Location: zulip-main/zerver/migrations/0457_backfill_scheduledmessagenotificationemail_trigger.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-20 12:07

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0456_alter_usergroup_can_mention_group"),
    ]

    operations = [
        migrations.RunSQL(
            """
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'stream_wildcard_mentioned'
            WHERE trigger = 'wildcard_mentioned';
            """,
            reverse_sql="""
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'wildcard_mentioned'
            WHERE trigger = 'stream_wildcard_mentioned';
            """,
            elidable=True,
        ),
        migrations.RunSQL(
            """
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'stream_wildcard_mentioned_in_followed_topic'
            WHERE trigger = 'followed_topic_wildcard_mentioned';
            """,
            reverse_sql="""
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'followed_topic_wildcard_mentioned'
            WHERE trigger = 'stream_wildcard_mentioned_in_followed_topic';
            """,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0458_realmauditlog_modified_user_group.py]---
Location: zulip-main/zerver/migrations/0458_realmauditlog_modified_user_group.py
Signals: Django

```python
# Generated by Django 4.1.3 on 2022-11-13 00:00

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0457_backfill_scheduledmessagenotificationemail_trigger"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmauditlog",
            name="modified_user_group",
            field=models.ForeignKey(
                null=True, on_delete=django.db.models.deletion.CASCADE, to="zerver.usergroup"
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0459_remove_invalid_characters_from_user_group_name.py]---
Location: zulip-main/zerver/migrations/0459_remove_invalid_characters_from_user_group_name.py
Signals: Django

```python
# Generated by Django 4.2.2 on 2023-07-03 06:39

from typing import Any

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps

INVALID_NAME_PREFIXES = ["@", "role:", "user:", "stream:", "channel:", "group:"]


def check_group_name_starts_with_invalid_prefix(group_name: str) -> str:
    for invalid_prefix in INVALID_NAME_PREFIXES:
        if group_name.startswith(invalid_prefix):
            return invalid_prefix
    return ""


def remove_invalid_characters_from_user_group_name(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserGroup = apps.get_model("zerver", "UserGroup")
    Realm = apps.get_model("zerver", "Realm")

    @transaction.atomic
    def update_single_realm(realm: Any) -> None:
        # Remove "@" character from name of role-based system groups.
        groups_to_update = []
        for group in UserGroup.objects.filter(realm=realm, is_system_group=True):
            if group.name[0] != "@":
                # We skip the group if its name has already been updated.
                continue

            old_group_name = group.name
            group.name = old_group_name.removeprefix("@")
            groups_to_update.append(group)

        # Fix the name of non-system groups as well.
        existing_group_names = UserGroup.objects.filter(
            realm=realm, is_system_group=False
        ).values_list("name", flat=True)
        existing_group_names_set = set(existing_group_names)
        for prefix in INVALID_NAME_PREFIXES:
            groups = UserGroup.objects.filter(
                realm=realm, is_system_group=False, name__startswith=prefix
            )
            for group in groups:
                orig_group_name = group.name
                group_name = group.name
                while True:
                    matching_invalid_prefix = check_group_name_starts_with_invalid_prefix(
                        group_name
                    )
                    if len(matching_invalid_prefix) == 0:
                        break
                    group_name = group_name.removeprefix(matching_invalid_prefix)

                if len(group_name) > 0 and group_name not in existing_group_names_set:
                    group.name = group_name
                else:
                    group.name = f"group:{group.id}"

                existing_group_names_set.add(group.name)
                groups_to_update.append(group)
                print(f"Renaming {orig_group_name} to {group_name} for {group.id} in {realm.id}")

        UserGroup.objects.bulk_update(groups_to_update, ["name"])

    for realm in Realm.objects.all().iterator():
        update_single_realm(realm)


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0458_realmauditlog_modified_user_group"),
    ]

    operations = [
        migrations.RunPython(
            remove_invalid_characters_from_user_group_name,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0460_backfill_realmauditlog_extradata_to_json_field.py]---
Location: zulip-main/zerver/migrations/0460_backfill_realmauditlog_extradata_to_json_field.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-09-30 20:30

import ast

import orjson
from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import F, JSONField, Model
from django.db.models.functions import Cast, JSONObject

# This migration is mostly the same as
# backfill_remote_realmauditlog_extradata_to_json_field in zilencer.

OLD_VALUE = "1"
NEW_VALUE = "2"
USER_FULL_NAME_CHANGED = 124
REALM_DISCOUNT_CHANGED = 209
BATCH_SIZE = 5000

DISCOUNT_DATA_TEMPLATE = """Audit log entry {id} with event type REALM_DISCOUNT_CHANGED is skipped.
The data consistency needs to be manually checked.
  Discount data to remove after the upcoming JSONField migration:
{data_to_remove}
  Discount data to keep after the upcoming JSONField migration:
{data_to_keep}
"""

OVERWRITE_TEMPLATE = """Audit log entry with id {id} has extra_data_json been inconsistently overwritten.
  The old value is:
{old_value}
  The new value is:
{new_value}
"""


@transaction.atomic
def do_bulk_backfill_extra_data(
    audit_log_model: type[Model], id_lower_bound: int, id_upper_bound: int
) -> None:
    # First handle the special case for audit logs with the
    # USER_FULL_NAME_CHANGED event, which stores the full name not as
    # str(dict()) but a plain str. Note that we only update the entries where
    # extra_data_json has the default value, because we do not want to override
    # existing audit log entries with a NEW_VALUE of None for extra_data_json.
    # We do not need to skip existing entries for other parts of backfilling
    # because we have double-write implemented so that the backfilled value
    # will still be consistent.
    audit_log_model._default_manager.filter(
        event_type=USER_FULL_NAME_CHANGED,
        id__range=(id_lower_bound, id_upper_bound),
        extra_data_json={},
        # extra_data used to keeps track of the old name. As a result, we know
        # nothing about what NEW_VALUE would be especially if the name has been
        # changed multiple times. extra_data_json is a JSONObject whose
        # OLD_VALUE and NEW_VALUE is mapped from the value of the extra_data
        # field (which is just a old full name string) and None, respectively.
        # Documentation for JSONObject:
        # https://docs.djangoproject.com/en/5.0/ref/models/database-functions/#jsonobject
    ).update(extra_data_json=JSONObject(**{OLD_VALUE: "extra_data", NEW_VALUE: None}))

    inconsistent_extra_data_json: list[tuple[int, str, object, object]] = []
    # A dict converted with str() will start with a open bracket followed by a
    # single quote, as opposed to a JSON-encoded value, which will use a
    # _double_ quote. We use this to filter out those entries with malformed
    # extra_data to be handled later. This should only update rows with
    # extra_data populated with orjson.dumps.

    # The first query below checks for entries that would have extra_data_json
    # being overwritten by the migration with a value inconsistent with its
    # previous value.
    inconsistent_extra_data_json.extend(
        audit_log_model._default_manager.filter(
            extra_data__isnull=False, id__range=(id_lower_bound, id_upper_bound)
        )
        .annotate(new_extra_data_json=Cast("extra_data", output_field=JSONField()))
        .exclude(extra_data__startswith="{'")
        .exclude(event_type=USER_FULL_NAME_CHANGED)
        .exclude(extra_data_json={})
        .exclude(extra_data_json=F("new_extra_data_json"))
        .values_list("id", "extra_data", "extra_data_json", "new_extra_data_json")
    )
    (
        audit_log_model._default_manager.filter(
            extra_data__isnull=False,
            id__range=(id_lower_bound, id_upper_bound),
            extra_data_json__inconsistent_old_extra_data__isnull=True,
        )
        .exclude(extra_data__startswith="{'")
        .exclude(event_type=USER_FULL_NAME_CHANGED)
        .update(extra_data_json=Cast("extra_data", output_field=JSONField()))
    )

    python_valued_audit_log_entries = audit_log_model._default_manager.filter(
        extra_data__startswith="{'",
        id__range=(id_lower_bound, id_upper_bound),
        extra_data_json__inconsistent_old_extra_data__isnull=True,
    )
    for audit_log_entry in python_valued_audit_log_entries:
        # extra_data for entries that store dict stringified with builtins.str()
        # are converted back with ast.literal_eval for safety and efficiency.
        # str()'d extra_data with the REALM_DISCOUNT_CHANGED event type is not
        # handled by this migration. We expect that all such entries are
        # manually converted beforehand or an error will occur during the
        # migration, because ast.literal_eval does not allow the evaluation of
        # Decimal.
        old_value = audit_log_entry.extra_data_json  # type: ignore[attr-defined] # The migration cannot depend on zerver.models, which contains the real type of the RealmAuditLog model, so it cannot be properly typed.
        if audit_log_entry.event_type == REALM_DISCOUNT_CHANGED:  # type: ignore[attr-defined] # Explained above.
            print(
                DISCOUNT_DATA_TEMPLATE.format(
                    id=audit_log_entry.id,  # type: ignore[attr-defined] # Explained above.
                    data_to_remove=audit_log_entry.extra_data,  # type: ignore[attr-defined] # Explained above.
                    data_to_keep=old_value,
                )
            )
            continue
        new_value = ast.literal_eval(audit_log_entry.extra_data)  # type: ignore[attr-defined] # Explained above.
        if old_value not in ({}, new_value):
            inconsistent_extra_data_json.append(
                (audit_log_entry.id, audit_log_entry.extra_data, old_value, new_value)  # type: ignore[attr-defined] # Explained above.
            )
        audit_log_entry.extra_data_json = new_value  # type: ignore[attr-defined] # Explained above.
    audit_log_model._default_manager.bulk_update(
        python_valued_audit_log_entries, fields=["extra_data_json"]
    )

    if inconsistent_extra_data_json:
        audit_log_entries = []
        for (
            audit_log_entry_id,
            old_extra_data,
            old_extra_data_json,
            new_extra_data_json,
        ) in inconsistent_extra_data_json:
            audit_log_entry = audit_log_model._default_manager.get(id=audit_log_entry_id)
            assert isinstance(old_extra_data_json, dict)
            if "inconsistent_old_extra_data" in old_extra_data_json:
                # Skip entries that have been backfilled and detected as
                # anomalies before.
                continue
            assert isinstance(new_extra_data_json, dict)
            audit_log_entry.extra_data_json = {  # type: ignore[attr-defined] # Explained above.
                **new_extra_data_json,
                "inconsistent_old_extra_data": old_extra_data,
                "inconsistent_old_extra_data_json": old_extra_data_json,
            }
            audit_log_entries.append(audit_log_entry)
            print(
                OVERWRITE_TEMPLATE.format(
                    id=audit_log_entry_id,
                    old_value=orjson.dumps(old_extra_data_json).decode(),
                    new_value=orjson.dumps(new_extra_data_json).decode(),
                )
            )
        audit_log_model._default_manager.bulk_update(audit_log_entries, fields=["extra_data_json"])


def backfill_extra_data(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    audit_log_model = apps.get_model("zerver", "RealmAuditLog")
    if not audit_log_model.objects.filter(extra_data__isnull=False).exists():
        return

    audit_log_entries = audit_log_model.objects.filter(extra_data__isnull=False)
    id_lower_bound = audit_log_entries.earliest("id").id
    id_upper_bound = audit_log_entries.latest("id").id
    while id_lower_bound <= id_upper_bound:
        do_bulk_backfill_extra_data(
            audit_log_model, id_lower_bound, min(id_lower_bound + BATCH_SIZE, id_upper_bound)
        )
        id_lower_bound += BATCH_SIZE + 1


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0459_remove_invalid_characters_from_user_group_name"),
    ]

    operations = [
        migrations.RunPython(
            backfill_extra_data, reverse_code=migrations.RunPython.noop, elidable=True
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0461_alter_realm_default_code_block_language.py]---
Location: zulip-main/zerver/migrations/0461_alter_realm_default_code_block_language.py
Signals: Django

```python
# Generated by Django 4.2.2 on 2023-07-11 14:04

from django.db import migrations, models
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def set_default_code_block_language_to_empty_string(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    Realm.objects.filter(default_code_block_language=None).update(default_code_block_language="")


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0460_backfill_realmauditlog_extradata_to_json_field"),
    ]

    operations = [
        # Change default value from None to empty string for new realms
        migrations.AlterField(
            model_name="realm",
            name="default_code_block_language",
            field=models.TextField(null=True, default=""),
        ),
        # Update existing realms with None to have empty string
        migrations.RunPython(
            set_default_code_block_language_to_empty_string,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
        # Remove null=True for this realm field
        migrations.AlterField(
            model_name="realm",
            name="default_code_block_language",
            field=models.TextField(default=""),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0462_realmplayground_url_template.py]---
Location: zulip-main/zerver/migrations/0462_realmplayground_url_template.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-05-27 00:06

from django.db import migrations, models

from zerver.models.linkifiers import url_template_validator


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0461_alter_realm_default_code_block_language"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmplayground",
            name="url_template",
            field=models.TextField(null=True, validators=[url_template_validator]),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0463_backfill_realmplayground_url_template.py]---
Location: zulip-main/zerver/migrations/0463_backfill_realmplayground_url_template.py
Signals: Django

```python
import uri_template
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def transform_to_url_template_syntax(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    realm_playground_model = apps.get_model("zerver", "RealmPlayground")

    # Only the null entries are realm playgrounds that exist prior to the
    # addition of url_template
    realm_playgrounds = realm_playground_model.objects.filter(url_template__isnull=True)
    escape_table = str.maketrans(
        {
            "{": "%7B",
            "}": "%7D",
        }
    )
    for realm_playground in realm_playgrounds:
        # It is originally expected to have the code appended to the end of
        # url_prefix. Therefore, making a template having only one variable that
        # expands at the end of it should suffice to replicate the old behavior
        # for the legacy prefix strings. Note that we use simple expansion
        # instead of reserved expansion here (i.e.: {code} instead of {+code})
        # because the code segment is supposed to be URL encoded.
        converted_template = realm_playground.url_prefix.translate(escape_table) + "{code}"
        if not uri_template.validate(converted_template):
            raise RuntimeError(
                f'Failed to convert url prefix "{realm_playground.url_prefix}". The converted template "{converted_template}" is invalid.'
            )
        realm_playground.url_template = converted_template
    realm_playground_model.objects.bulk_update(realm_playgrounds, fields=["url_template"])


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0462_realmplayground_url_template"),
    ]

    operations = [
        migrations.RunPython(
            transform_to_url_template_syntax,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0464_remove_realmplayground_url_prefix.py]---
Location: zulip-main/zerver/migrations/0464_remove_realmplayground_url_prefix.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-05-27 03:13

from django.db import migrations, models

from zerver.models.linkifiers import url_template_validator


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0463_backfill_realmplayground_url_template"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="realmplayground",
            name="url_prefix",
        ),
        migrations.AlterField(
            model_name="realmplayground",
            name="url_template",
            field=models.TextField(validators=[url_template_validator], null=False),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0465_backfill_scheduledmessagenotificationemail_trigger.py]---
Location: zulip-main/zerver/migrations/0465_backfill_scheduledmessagenotificationemail_trigger.py
Signals: Django

```python
# Generated by Django 4.2.3 on 2023-08-04 14:08

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0464_remove_realmplayground_url_prefix"),
    ]

    operations = [
        migrations.RunSQL(
            """
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'direct_message'
            WHERE trigger = 'private_message';
            """,
            reverse_sql="""
            UPDATE zerver_scheduledmessagenotificationemail
            SET trigger = 'private_message'
            WHERE trigger = 'direct_message';
            """,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0466_realmfilter_order.py]---
Location: zulip-main/zerver/migrations/0466_realmfilter_order.py
Signals: Django

```python
# Generated by Django 4.2.3 on 2023-08-09 18:48

from django.db import migrations, models
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import F


def migrate_set_order_value(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    RealmFilter = apps.get_model("zerver", "RealmFilter")
    RealmFilter.objects.all().update(order=F("id"))


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0465_backfill_scheduledmessagenotificationemail_trigger"),
    ]

    operations = [
        migrations.AddField(
            model_name="realmfilter",
            name="order",
            field=models.IntegerField(default=0),
        ),
        migrations.RunPython(
            migrate_set_order_value, reverse_code=migrations.RunPython.noop, elidable=True
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0467_rename_extradata_realmauditlog_extra_data_json.py]---
Location: zulip-main/zerver/migrations/0467_rename_extradata_realmauditlog_extra_data_json.py
Signals: Django

```python
# Generated by Django 4.0.7 on 2022-10-02 17:02

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0466_realmfilter_order"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="realmauditlog",
            name="extra_data",
        ),
        migrations.RenameField(
            model_name="realmauditlog",
            old_name="extra_data_json",
            new_name="extra_data",
        ),
    ]
```

--------------------------------------------------------------------------------

````
