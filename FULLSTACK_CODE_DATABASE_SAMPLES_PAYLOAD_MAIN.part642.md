---
source_txt: fullstack_samples/payload-main
converted_utc: 2025-12-18T13:05:13Z
part: 642
parts_total: 695
---

# FULLSTACK CODE DATABASE SAMPLES payload-main

## Verbatim Content (Part 642 of 695)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - payload-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/payload-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: payload-types.ts]---
Location: payload-main/test/plugin-redirects/payload-types.ts

```typescript
/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:types` to regenerate this file.
 */

/**
 * Supported timezones in IANA format.
 *
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "supportedTimezones".
 */
export type SupportedTimezones =
  | 'Pacific/Midway'
  | 'Pacific/Niue'
  | 'Pacific/Honolulu'
  | 'Pacific/Rarotonga'
  | 'America/Anchorage'
  | 'Pacific/Gambier'
  | 'America/Los_Angeles'
  | 'America/Tijuana'
  | 'America/Denver'
  | 'America/Phoenix'
  | 'America/Chicago'
  | 'America/Guatemala'
  | 'America/New_York'
  | 'America/Bogota'
  | 'America/Caracas'
  | 'America/Santiago'
  | 'America/Buenos_Aires'
  | 'America/Sao_Paulo'
  | 'Atlantic/South_Georgia'
  | 'Atlantic/Azores'
  | 'Atlantic/Cape_Verde'
  | 'Europe/London'
  | 'Europe/Berlin'
  | 'Africa/Lagos'
  | 'Europe/Athens'
  | 'Africa/Cairo'
  | 'Europe/Moscow'
  | 'Asia/Riyadh'
  | 'Asia/Dubai'
  | 'Asia/Baku'
  | 'Asia/Karachi'
  | 'Asia/Tashkent'
  | 'Asia/Calcutta'
  | 'Asia/Dhaka'
  | 'Asia/Almaty'
  | 'Asia/Jakarta'
  | 'Asia/Bangkok'
  | 'Asia/Shanghai'
  | 'Asia/Singapore'
  | 'Asia/Tokyo'
  | 'Asia/Seoul'
  | 'Australia/Brisbane'
  | 'Australia/Sydney'
  | 'Pacific/Guam'
  | 'Pacific/Noumea'
  | 'Pacific/Auckland'
  | 'Pacific/Fiji';

export interface Config {
  auth: {
    users: UserAuthOperations;
  };
  blocks: {};
  collections: {
    users: User;
    pages: Page;
    redirects: Redirect;
    'payload-kv': PayloadKv;
    'payload-locked-documents': PayloadLockedDocument;
    'payload-preferences': PayloadPreference;
    'payload-migrations': PayloadMigration;
  };
  collectionsJoins: {};
  collectionsSelect: {
    users: UsersSelect<false> | UsersSelect<true>;
    pages: PagesSelect<false> | PagesSelect<true>;
    redirects: RedirectsSelect<false> | RedirectsSelect<true>;
    'payload-kv': PayloadKvSelect<false> | PayloadKvSelect<true>;
    'payload-locked-documents': PayloadLockedDocumentsSelect<false> | PayloadLockedDocumentsSelect<true>;
    'payload-preferences': PayloadPreferencesSelect<false> | PayloadPreferencesSelect<true>;
    'payload-migrations': PayloadMigrationsSelect<false> | PayloadMigrationsSelect<true>;
  };
  db: {
    defaultIDType: string;
  };
  globals: {};
  globalsSelect: {};
  locale: 'en' | 'es' | 'de';
  user: User & {
    collection: 'users';
  };
  jobs: {
    tasks: unknown;
    workflows: unknown;
  };
}
export interface UserAuthOperations {
  forgotPassword: {
    email: string;
    password: string;
  };
  login: {
    email: string;
    password: string;
  };
  registerFirstUser: {
    email: string;
    password: string;
  };
  unlock: {
    email: string;
    password: string;
  };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users".
 */
export interface User {
  id: string;
  updatedAt: string;
  createdAt: string;
  email: string;
  resetPasswordToken?: string | null;
  resetPasswordExpiration?: string | null;
  salt?: string | null;
  hash?: string | null;
  loginAttempts?: number | null;
  lockUntil?: string | null;
  sessions?:
    | {
        id: string;
        createdAt?: string | null;
        expiresAt: string;
      }[]
    | null;
  password?: string | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "pages".
 */
export interface Page {
  id: string;
  title: string;
  excerpt?: string | null;
  updatedAt: string;
  createdAt: string;
  _status?: ('draft' | 'published') | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "redirects".
 */
export interface Redirect {
  id: string;
  from: string;
  to?: {
    type?: ('reference' | 'custom') | null;
    reference?: {
      relationTo: 'pages';
      value: string | Page;
    } | null;
    url?: string | null;
  };
  type: '301' | '302';
  customField?: string | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-kv".
 */
export interface PayloadKv {
  id: string;
  key: string;
  data:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents".
 */
export interface PayloadLockedDocument {
  id: string;
  document?:
    | ({
        relationTo: 'users';
        value: string | User;
      } | null)
    | ({
        relationTo: 'pages';
        value: string | Page;
      } | null)
    | ({
        relationTo: 'redirects';
        value: string | Redirect;
      } | null);
  globalSlug?: string | null;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences".
 */
export interface PayloadPreference {
  id: string;
  user: {
    relationTo: 'users';
    value: string | User;
  };
  key?: string | null;
  value?:
    | {
        [k: string]: unknown;
      }
    | unknown[]
    | string
    | number
    | boolean
    | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations".
 */
export interface PayloadMigration {
  id: string;
  name?: string | null;
  batch?: number | null;
  updatedAt: string;
  createdAt: string;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "users_select".
 */
export interface UsersSelect<T extends boolean = true> {
  updatedAt?: T;
  createdAt?: T;
  email?: T;
  resetPasswordToken?: T;
  resetPasswordExpiration?: T;
  salt?: T;
  hash?: T;
  loginAttempts?: T;
  lockUntil?: T;
  sessions?:
    | T
    | {
        id?: T;
        createdAt?: T;
        expiresAt?: T;
      };
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "pages_select".
 */
export interface PagesSelect<T extends boolean = true> {
  title?: T;
  excerpt?: T;
  updatedAt?: T;
  createdAt?: T;
  _status?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "redirects_select".
 */
export interface RedirectsSelect<T extends boolean = true> {
  from?: T;
  to?:
    | T
    | {
        type?: T;
        reference?: T;
        url?: T;
      };
  type?: T;
  customField?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-kv_select".
 */
export interface PayloadKvSelect<T extends boolean = true> {
  key?: T;
  data?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-locked-documents_select".
 */
export interface PayloadLockedDocumentsSelect<T extends boolean = true> {
  document?: T;
  globalSlug?: T;
  user?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-preferences_select".
 */
export interface PayloadPreferencesSelect<T extends boolean = true> {
  user?: T;
  key?: T;
  value?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "payload-migrations_select".
 */
export interface PayloadMigrationsSelect<T extends boolean = true> {
  name?: T;
  batch?: T;
  updatedAt?: T;
  createdAt?: T;
}
/**
 * This interface was referenced by `Config`'s JSON-Schema
 * via the `definition` "auth".
 */
export interface Auth {
  [k: string]: unknown;
}


declare module 'payload' {
  // @ts-ignore 
  export interface GeneratedTypes extends Config {}
}
```

--------------------------------------------------------------------------------

---[FILE: shared.ts]---
Location: payload-main/test/plugin-redirects/shared.ts

```typescript
export const pagesSlug = 'pages'
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.eslint.json]---
Location: payload-main/test/plugin-redirects/tsconfig.eslint.json

```json
{
  // extend your base config to share compilerOptions, etc
  //"extends": "./tsconfig.json",
  "compilerOptions": {
    // ensure that nobody can accidentally use this config for a build
    "noEmit": true
  },
  "include": [
    // whatever paths you intend to lint
    "./**/*.ts",
    "./**/*.tsx"
  ]
}
```

--------------------------------------------------------------------------------

---[FILE: tsconfig.json]---
Location: payload-main/test/plugin-redirects/tsconfig.json

```json
{
  "extends": "../tsconfig.json"
}
```

--------------------------------------------------------------------------------

---[FILE: Pages.ts]---
Location: payload-main/test/plugin-redirects/collections/Pages.ts

```typescript
import type { CollectionConfig } from 'payload'

import { pagesSlug } from '../shared.js'

export const Pages: CollectionConfig = {
  slug: pagesSlug,
  labels: {
    singular: 'Page',
    plural: 'Pages',
  },
  admin: {
    useAsTitle: 'title',
  },
  versions: {
    drafts: true,
  },
  fields: [
    {
      name: 'title',
      label: 'Title',
      type: 'text',
      required: true,
    },
    {
      name: 'excerpt',
      label: 'Excerpt',
      type: 'text',
    },
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: Users.ts]---
Location: payload-main/test/plugin-redirects/collections/Users.ts

```typescript
import type { CollectionConfig } from 'payload'

export const Users: CollectionConfig = {
  slug: 'users',
  auth: true,
  admin: {
    useAsTitle: 'email',
  },
  access: {
    read: () => true,
  },
  fields: [
    // Email added by default
    // Add more fields as needed
  ],
}
```

--------------------------------------------------------------------------------

---[FILE: index.ts]---
Location: payload-main/test/plugin-redirects/seed/index.ts

```typescript
import type { Payload } from 'payload'

import type { PayloadRequest } from '../../../packages/payload/types.js'

export const seed = async (payload: Payload): Promise<boolean> => {
  payload.logger.info('Seeding data...')
  const req = {} as PayloadRequest

  try {
    await payload.create({
      collection: 'users',
      data: {
        email: 'demo@payloadcms.com',
        password: 'demo',
      },
      req,
    })

    return true
  } catch (err) {
    console.error(err)
    return false
  }
}
```

--------------------------------------------------------------------------------

---[FILE: config.ts]---
Location: payload-main/test/plugin-search/config.ts

```typescript
import { fileURLToPath } from 'node:url'
import path from 'path'
const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)
import { searchPlugin } from '@payloadcms/plugin-search'
import { randomUUID } from 'node:crypto'

import { buildConfigWithDefaults } from '../buildConfigWithDefaults.js'
import { devUser } from '../credentials.js'
import { Pages } from './collections/Pages.js'
import { Posts } from './collections/Posts.js'
import { Users } from './collections/Users.js'
import { seed } from './seed/index.js'

export default buildConfigWithDefaults({
  collections: [
    Users,
    Pages,
    Posts,
    {
      slug: 'custom-ids-1',
      fields: [{ type: 'text', name: 'id' }],
    },
    {
      slug: 'custom-ids-2',
      fields: [{ type: 'text', name: 'id' }],
    },
  ],
  localization: {
    defaultLocale: 'en',
    fallback: true,
    locales: ['en', 'es', 'de'],
  },
  admin: {
    importMap: {
      baseDir: path.resolve(dirname),
    },
  },
  onInit: async (payload) => {
    await payload.create({
      collection: 'users',
      data: {
        email: devUser.email,
        password: devUser.password,
      },
    })

    await seed(payload)
  },
  plugins: [
    searchPlugin({
      beforeSync: ({ originalDoc, searchDoc }) => {
        return {
          ...searchDoc,
          excerpt: originalDoc?.excerpt || 'This is a fallback excerpt',
          slug: originalDoc.slug,
        }
      },
      collections: ['pages', 'posts', 'custom-ids-1', 'custom-ids-2'],
      defaultPriorities: {
        pages: 10,
        posts: ({ title }) => (title === 'Hello, world!' ? 30 : 20),
      },
      searchOverrides: {
        access: {
          // Used for int test
          delete: ({ req: { user } }) => user?.email === devUser.email,
        },
        fields: ({ defaultFields }) => [
          ...defaultFields,
          // This is necessary to test whether search docs were deleted or not with SQLite
          // Because IDs in SQLite, apparently, aren't unique if we count deleted rows without AUTOINCREMENT option
          // Thus we have a custom UUID field.
          {
            name: 'id',
            type: 'text',
            hooks: {
              beforeChange: [
                ({ operation }) => {
                  if (operation === 'create') {
                    return randomUUID()
                  }
                },
              ],
            },
          },
          {
            name: 'excerpt',
            type: 'textarea',
            admin: {
              position: 'sidebar',
            },
          },
          {
            name: 'slug',
            required: false,
            type: 'text',
            localized: true,
          },
        ],
      },
    }),
  ],
  typescript: {
    outputFile: path.resolve(dirname, 'payload-types.ts'),
  },
})
```

--------------------------------------------------------------------------------

---[FILE: int.spec.ts]---
Location: payload-main/test/plugin-search/int.spec.ts

```typescript
import type { Payload } from 'payload'

import path from 'path'
import { wait } from 'payload/shared'
import { fileURLToPath } from 'url'

import type { NextRESTClient } from '../helpers/NextRESTClient.js'

import { devUser } from '../credentials.js'
import { initPayloadInt } from '../helpers/initPayloadInt.js'
import { pagesSlug, postsSlug } from './shared.js'

let payload: Payload
let restClient: NextRESTClient
let token: string

const filename = fileURLToPath(import.meta.url)
const dirname = path.dirname(filename)

describe('@payloadcms/plugin-search', () => {
  beforeAll(async () => {
    ;({ payload, restClient } = await initPayloadInt(dirname))

    const data = await restClient
      .POST('/users/login', {
        body: JSON.stringify({
          email: devUser.email,
          password: devUser.password,
        }),
      })
      .then((res) => res.json())

    token = data.token
  })

  beforeEach(async () => {
    await payload.delete({
      collection: 'search',
      depth: 0,
      where: {
        id: {
          exists: true,
        },
      },
    })
    await Promise.all([
      payload.delete({
        collection: postsSlug,
        depth: 0,
        where: {
          id: {
            exists: true,
          },
        },
      }),
      payload.delete({
        collection: pagesSlug,
        depth: 0,
        where: {
          id: {
            exists: true,
          },
        },
      }),
    ])
  })

  afterAll(async () => {
    await payload.destroy()
  })

  it('should add a search collection', async () => {
    const search = await payload.find({
      collection: 'search',
      depth: 0,
      limit: 1,
    })

    expect(search).toBeTruthy()
  })

  it('should sync published pages to the search collection', async () => {
    const pageToSync = await payload.create({
      collection: 'pages',
      data: {
        _status: 'published',
        excerpt: 'This is a test page',
        title: 'Hello, world!',
      },
    })

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: pageToSync.id,
        },
      },
    })

    expect(results).toHaveLength(1)
    expect(results[0].doc.value).toBe(pageToSync.id)
    expect(results[0].title).toBe('Hello, world!')
    expect(results[0].excerpt).toBe('This is a test page')
  })

  it('should not sync drafts pages to the search collection', async () => {
    const draftPage = await payload.create({
      collection: 'pages',
      data: {
        _status: 'draft',
        excerpt: 'This is a test page',
        title: 'Hello, world!',
      },
    })

    // wait for the search document to be potentially created
    // we do not await this within the `syncToSearch` hook
    await wait(200)

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: draftPage.id,
        },
      },
    })

    expect(results).toHaveLength(0)
  })

  it('should not delete a search doc if a published item has a new draft but remains published', async () => {
    const publishedPage = await payload.create({
      collection: 'pages',
      data: {
        _status: 'published',
        title: 'Published title!',
      },
    })

    // wait for the search document to be potentially created
    // we do not await this within the `syncToSearch` hook
    await wait(200)

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: publishedPage.id,
        },
      },
    })

    expect(results).toHaveLength(1)

    // Create a new draft
    await payload.update({
      collection: 'pages',
      id: publishedPage.id,
      draft: true,
      data: {
        _status: 'draft',
        title: 'Draft title!',
      },
    })

    // This should remain with the published content
    const { docs: updatedResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: publishedPage.id,
        },
      },
    })

    expect(updatedResults).toHaveLength(1)

    await payload.update({
      collection: 'pages',
      id: publishedPage.id,
      data: {
        _status: 'draft',
        title: 'Drafted again',
      },
    })

    // Should now be deleted given we've unpublished the page
    const { docs: deletedResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: publishedPage.id,
        },
      },
    })

    expect(deletedResults).toHaveLength(0)
  })

  it('should sync changes made to an existing search document', async () => {
    const pageToReceiveUpdates = await payload.create({
      collection: 'pages',
      data: {
        _status: 'published',
        excerpt: 'This is a test page',
        title: 'Hello, world!',
      },
    })

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: pageToReceiveUpdates.id,
        },
      },
    })

    expect(results).toHaveLength(1)
    expect(results[0].doc.value).toBe(pageToReceiveUpdates.id)
    expect(results[0].title).toBe('Hello, world!')
    expect(results[0].excerpt).toBe('This is a test page')

    await payload.update({
      id: pageToReceiveUpdates.id,
      collection: 'pages',
      data: {
        excerpt: 'This is a test page (updated)',
        title: 'Hello, world! (updated)',
      },
    })

    // wait for the search document to be potentially updated
    // we do not await this within the `syncToSearch` hook
    await wait(200)

    // Do not add `limit` to this query, this way we can test if multiple documents were created
    const { docs: updatedResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: pageToReceiveUpdates.id,
        },
      },
    })

    expect(updatedResults).toHaveLength(1)
    expect(updatedResults[0].doc.value).toBe(pageToReceiveUpdates.id)
    expect(updatedResults[0].title).toBe('Hello, world! (updated)')
    expect(updatedResults[0].excerpt).toBe('This is a test page (updated)')
  })

  it('should clear the search document when the original document is deleted', async () => {
    const page = await payload.create({
      collection: 'pages',
      data: {
        _status: 'published',
        excerpt: 'This is a test page',
        title: 'Hello, world!',
      },
    })

    // wait for the search document to be created
    // we do not await this within the `syncToSearch` hook
    await wait(200)

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: page.id,
        },
      },
    })

    expect(results).toHaveLength(1)
    expect(results[0].doc.value).toBe(page.id)

    await payload.delete({
      id: page.id,
      collection: 'pages',
    })

    // wait for the search document to be potentially deleted
    // we do not await this within the `syncToSearch` hook
    await wait(200)

    const { docs: deletedResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        id: {
          equals: results[0].id,
        },
      },
    })

    expect(deletedResults).toHaveLength(0)
  })

  it('should clear the proper search document when having the same doc.value but different doc.relationTo', async () => {
    const custom_id_1 = await payload.create({
      collection: 'custom-ids-1',
      data: { id: 'custom_id' },
    })

    await payload.create({
      collection: 'custom-ids-2',
      data: { id: 'custom_id' },
    })

    await wait(200)

    const {
      docs: [docBefore],
    } = await payload.find({
      collection: 'search',
      where: { 'doc.value': { equals: 'custom_id' } },
      limit: 1,
      sort: 'createdAt',
    })

    expect(docBefore.doc.relationTo).toBe('custom-ids-1')

    await payload.delete({ collection: 'custom-ids-1', id: custom_id_1.id })

    await wait(200)

    const {
      docs: [docAfter],
    } = await payload.find({
      collection: 'search',
      where: { 'doc.value': { equals: 'custom_id' } },
      limit: 1,
      sort: 'createdAt',
    })

    expect(docAfter.doc.relationTo).toBe('custom-ids-2')
  })

  it('should sync localized data', async () => {
    const createdDoc = await payload.create({
      collection: 'posts',
      data: {
        _status: 'published',
        title: 'test title',
        slug: 'es',
      },
      locale: 'es',
    })

    await payload.update({
      collection: 'posts',
      id: createdDoc.id,
      data: {
        _status: 'published',
        title: 'test title',
        slug: 'en',
      },
      locale: 'en',
    })

    const syncedSearchData = await payload.find({
      collection: 'search',
      locale: 'es',
      where: {
        and: [
          {
            'doc.value': {
              equals: createdDoc.id,
            },
          },
        ],
      },
    })

    expect(syncedSearchData.docs[0].slug).toEqual('es')
  })

  it('should respond with 401 when invalid permissions on user before reindex', async () => {
    const testCreds = {
      email: 'test@payloadcms.com',
      password: 'test',
    }

    await payload.create({
      collection: 'users',
      data: testCreds,
    })

    const testUserRes = await restClient.POST(`/users/login`, {
      body: JSON.stringify(testCreds),
    })

    const testUser = await testUserRes.json()

    const endpointRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: [postsSlug],
      }),
      headers: {
        Authorization: `JWT ${testUser.token}`,
      },
    })

    expect(endpointRes.status).toEqual(401)
  })

  it('should respond with 400 when invalid collection args passed to reindex', async () => {
    const endpointNoArgsRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({}),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    const endpointEmptyArrRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: [],
      }),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    const endpointInvalidArrRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: ['users'],
      }),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    expect(endpointNoArgsRes.status).toBe(400)
    expect(endpointEmptyArrRes.status).toBe(400)
    expect(endpointInvalidArrRes.status).toBe(400)
  })

  it('should delete existing search indexes before reindexing', async () => {
    await payload.create({
      collection: postsSlug,
      data: {
        title: 'post_1',
        _status: 'published',
      },
    })

    await wait(200)

    await payload.create({
      collection: postsSlug,
      data: {
        title: 'post_2',
        _status: 'published',
      },
    })

    const { docs } = await payload.find({ collection: 'search' })

    await wait(200)

    const endpointRes = await restClient.POST('/search/reindex', {
      body: JSON.stringify({
        collections: [postsSlug],
      }),
    })

    expect(endpointRes.status).toBe(200)

    await wait(200)

    const { docs: results } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        id: {
          in: docs.map((doc) => doc.id),
        },
      },
    })

    // Should have no docs with these ID
    // after reindex since it deletes indexes and recreates them
    expect(results).toHaveLength(0)
  })

  it('should reindex whole collections', async () => {
    await Promise.all([
      payload.create({
        collection: pagesSlug,
        data: {
          title: 'Test page title',
          _status: 'published',
        },
      }),
      payload.create({
        collection: postsSlug,
        data: {
          title: 'Test page title',
          _status: 'published',
        },
      }),
    ])

    await wait(200)

    const { totalDocs: totalBeforeReindex } = await payload.count({
      collection: 'search',
    })

    const endpointRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: [postsSlug, pagesSlug],
      }),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    expect(endpointRes.status).toBe(200)

    const { totalDocs: totalAfterReindex } = await payload.count({
      collection: 'search',
    })

    expect(totalAfterReindex).toBe(totalBeforeReindex)
  })

  it('should exclude drafts from reindexing by default', async () => {
    await Promise.all([
      payload.create({
        collection: pagesSlug,
        data: {
          title: 'Test page published',
          _status: 'published',
        },
      }),
      payload.create({
        collection: pagesSlug,
        data: {
          title: 'Test page draft',
          _status: 'draft',
        },
      }),
    ])

    await wait(200)

    const { totalDocs: totalBeforeReindex } = await payload.count({
      collection: 'search',
    })

    expect(totalBeforeReindex).toBe(1)

    const endpointRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: [pagesSlug],
      }),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    expect(endpointRes.status).toBe(200)

    const { totalDocs: totalAfterReindex } = await payload.count({
      collection: 'search',
    })

    expect(totalAfterReindex).toBe(totalBeforeReindex)

    const data = await endpointRes.json()

    const totalDocs = 2
    const nonDrafts = 1
    expect(data.message).toBe(
      `Successfully reindexed ${nonDrafts} of ${totalDocs} documents from ${pagesSlug} and skipped ${totalDocs - nonDrafts} drafts.`,
    )
  })

  it('should reindex all configured locales', async () => {
    const post = await payload.create({
      collection: postsSlug,
      locale: 'en',
      data: {
        title: 'Test page published',
        _status: 'published',
        slug: 'test-en',
      },
    })
    await payload.update({
      collection: postsSlug,
      id: post.id,
      locale: 'es',
      data: {
        _status: 'published',
        slug: 'test-es',
      },
    })
    await payload.update({
      collection: postsSlug,
      id: post.id,
      locale: 'de',
      data: {
        _status: 'published',
        slug: 'test-de',
      },
    })

    const {
      docs: [postBeforeReindex],
    } = await payload.find({
      collection: 'search',
      locale: 'all',
      where: {
        doc: {
          equals: {
            value: post.id,
            relationTo: postsSlug,
          },
        },
      },
      pagination: false,
      limit: 1,
      depth: 0,
    })

    expect(postBeforeReindex?.slug).not.toBeFalsy()

    const endpointRes = await restClient.POST(`/search/reindex`, {
      body: JSON.stringify({
        collections: [postsSlug],
      }),
      headers: {
        Authorization: `JWT ${token}`,
      },
    })

    expect(endpointRes.status).toBe(200)

    const {
      docs: [postAfterReindex],
    } = await payload.find({
      collection: 'search',
      locale: 'all',
      where: {
        doc: {
          equals: {
            value: post.id,
            relationTo: postsSlug,
          },
        },
      },
      pagination: false,
      limit: 1,
      depth: 0,
    })

    expect(postAfterReindex?.slug).not.toBeFalsy()
    expect(postAfterReindex?.slug).toStrictEqual(postBeforeReindex?.slug)
  })

  it('should sync trashed documents correctly with search plugin', async () => {
    // Create a published post
    const publishedPost = await payload.create({
      collection: postsSlug,
      data: {
        title: 'Post to be trashed',
        excerpt: 'This post will be soft deleted',
        _status: 'published',
      },
    })

    // Wait for the search document to be created
    await wait(200)

    // Verify the search document was created
    const { docs: initialSearchResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: publishedPost.id,
        },
      },
    })

    expect(initialSearchResults).toHaveLength(1)
    expect(initialSearchResults[0]?.title).toBe('Post to be trashed')

    // Soft delete the post (move to trash)
    await payload.update({
      collection: postsSlug,
      id: publishedPost.id,
      data: {
        deletedAt: new Date().toISOString(),
      },
    })

    // Wait for the search plugin to sync the trashed document
    await wait(200)

    // Verify the search document still exists but is properly synced
    // The search document should remain and be updated correctly
    const { docs: trashedSearchResults } = await payload.find({
      collection: 'search',
      depth: 0,
      where: {
        'doc.value': {
          equals: publishedPost.id,
        },
      },
    })

    // The search document should still exist
    expect(trashedSearchResults).toHaveLength(0)

    // Clean up by permanently deleting the trashed post
    await payload.delete({
      collection: postsSlug,
      id: publishedPost.id,
      trash: true, // permanently delete
    })
  })
})
```

--------------------------------------------------------------------------------

````
