---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:14Z
part: 955
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 955 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: 0600_set_default_for_can_add_members_group.py]---
Location: zulip-main/zerver/migrations/0600_set_default_for_can_add_members_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-07 17:05

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import F, Max, Min, OuterRef


def set_default_value_for_can_add_members_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    Realm = apps.get_model("zerver", "Realm")

    BATCH_SIZE = 1000
    max_id = NamedUserGroup.objects.filter(can_add_members_group=None).aggregate(Max("id"))[
        "id__max"
    ]

    if max_id is None:
        # Do nothing if there are no user groups on the server.
        return

    lower_bound = NamedUserGroup.objects.filter(can_add_members_group=None).aggregate(Min("id"))[
        "id__min"
    ]

    owners_system_group_ids = NamedUserGroup.objects.filter(name="role:owners").values_list(
        "id", flat=True
    )
    realm_ids_allowing_owners_to_manage_all_groups = Realm.objects.filter(
        can_manage_all_groups__in=owners_system_group_ids
    ).values_list("id", flat=True)

    admins_system_group_ids = NamedUserGroup.objects.filter(name="role:administrators").values_list(
        "id", flat=True
    )
    realm_ids_allowing_admins_to_manage_all_groups = Realm.objects.filter(
        can_manage_all_groups__in=admins_system_group_ids
    ).values_list("id", flat=True)

    moderators_system_group_ids = NamedUserGroup.objects.filter(name="role:moderators").values_list(
        "id", flat=True
    )
    realm_ids_allowing_moderators_to_manage_all_groups = Realm.objects.filter(
        can_manage_all_groups__in=moderators_system_group_ids
    ).values_list("id", flat=True)

    members_system_group_ids = NamedUserGroup.objects.filter(name="role:members").values_list(
        "id", flat=True
    )
    realm_ids_allowing_members_to_manage_all_groups = Realm.objects.filter(
        can_manage_all_groups__in=members_system_group_ids
    ).values_list("id", flat=True)

    while lower_bound <= max_id:
        upper_bound = lower_bound + BATCH_SIZE - 1
        print(f"Processing batch {lower_bound} to {upper_bound} for NamedUserGroup")

        with transaction.atomic():
            # Initialize to the corresponding system group, i.e. just
            # copy from can_manage_all_groups. Previously, either
            # owners/administrators/moderators or group members were
            # allowed to manage the group if they were part of
            # can_manage_all_groups. Non members were not allowed to
            # manage the group unless for the roles mentioned above.
            # That is why copying from can_manage_all_groups should
            # give the identical set of users permission.
            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_add_members_group=None,
                realm_id__in=realm_ids_allowing_owners_to_manage_all_groups,
            ).update(
                can_add_members_group=NamedUserGroup.objects.filter(
                    name="role:owners",
                    realm_for_sharding=OuterRef("realm_for_sharding"),
                    is_system_group=True,
                ).values("pk")
            )

            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_add_members_group=None,
                realm_id__in=realm_ids_allowing_admins_to_manage_all_groups,
            ).update(
                can_add_members_group=NamedUserGroup.objects.filter(
                    name="role:administrators",
                    realm_for_sharding=OuterRef("realm_for_sharding"),
                    is_system_group=True,
                ).values("pk")
            )

            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_add_members_group=None,
                realm_id__in=realm_ids_allowing_moderators_to_manage_all_groups,
            ).update(
                can_add_members_group=NamedUserGroup.objects.filter(
                    name="role:moderators",
                    realm_for_sharding=OuterRef("realm_for_sharding"),
                    is_system_group=True,
                ).values("pk")
            )

            # Initialize can_add_members_group to the group itself.
            # This should give the identical set of users permission,
            # since users could only exercise the permission previously
            # if they were a member of the group.
            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_add_members_group=None,
                realm_id__in=realm_ids_allowing_members_to_manage_all_groups,
            ).update(can_add_members_group=F("id"))

            # For the remaining group options, there is no direct
            # translation to can_add_members_group. We'll pick the
            # closest safe choice i.e. moderators for this.
            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_add_members_group=None,
            ).update(
                can_add_members_group=NamedUserGroup.objects.filter(
                    name="role:moderators",
                    realm_for_sharding=OuterRef("realm_for_sharding"),
                    is_system_group=True,
                ).values("pk")
            )

        lower_bound += BATCH_SIZE


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ("zerver", "0599_namedusergroup_add_can_add_members_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_add_members_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0601_alter_namedusergroup_can_add_members_group.py]---
Location: zulip-main/zerver/migrations/0601_alter_namedusergroup_can_add_members_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-09 08:25

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0600_set_default_for_can_add_members_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="namedusergroup",
            name="can_add_members_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0602_remap_can_manage_all_groups.py]---
Location: zulip-main/zerver/migrations/0602_remap_can_manage_all_groups.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-10 10:41

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max, OuterRef


def remap_can_manage_all_groups_for_existing_realms(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    max_id = NamedUserGroup.objects.aggregate(Max("id"))["id__max"]

    if max_id is None:
        # Do nothing if there are no user groups on the server.
        return

    with transaction.atomic():
        # Since can_manage_group, can_add_members_group, etc. have
        # migrated to the nearest possible value from
        # user_group_edit_policy, we want to set
        # can_manage_all_groups to the most restrictive setting
        # previously possible. We've chosen administrators as the
        # value here since the highest possible
        # user_group_edit_policy was with role administrators.
        Realm.objects.update(
            can_manage_all_groups=NamedUserGroup.objects.filter(
                name="role:administrators", realm=OuterRef("id"), is_system_group=True
            ).values("pk")
        )


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ("zerver", "0601_alter_namedusergroup_can_add_members_group"),
    ]

    operations = [
        migrations.RunPython(
            remap_can_manage_all_groups_for_existing_realms,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0603_realm_can_add_custom_emoji_group.py]---
Location: zulip-main/zerver/migrations/0603_realm_can_add_custom_emoji_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-04 07:01

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0602_remap_can_manage_all_groups"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="can_add_custom_emoji_group",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0604_set_default_value_for_can_add_custom_emoji_group.py]---
Location: zulip-main/zerver/migrations/0604_set_default_value_for_can_add_custom_emoji_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:47

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import OuterRef


def set_default_value_for_can_add_custom_emoji_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")

    add_custom_emoji_policy_to_group_name = {
        1: "role:members",
        2: "role:administrators",
        3: "role:fullmembers",
        4: "role:moderators",
    }

    for id, group_name in add_custom_emoji_policy_to_group_name.items():
        Realm.objects.filter(can_add_custom_emoji_group=None, add_custom_emoji_policy=id).update(
            can_add_custom_emoji_group=NamedUserGroup.objects.filter(
                name=group_name, realm=OuterRef("id"), is_system_group=True
            ).values("pk")
        )


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0603_realm_can_add_custom_emoji_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_add_custom_emoji_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0605_alter_realm_can_add_custom_emoji_group.py]---
Location: zulip-main/zerver/migrations/0605_alter_realm_can_add_custom_emoji_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-04 07:06

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0604_set_default_value_for_can_add_custom_emoji_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realm",
            name="can_add_custom_emoji_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0606_remove_realm_add_custom_emoji_policy.py]---
Location: zulip-main/zerver/migrations/0606_remove_realm_add_custom_emoji_policy.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-05 04:45

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0605_alter_realm_can_add_custom_emoji_group"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="realm",
            name="add_custom_emoji_policy",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0607_namedusergroup_add_can_leave_group.py]---
Location: zulip-main/zerver/migrations/0607_namedusergroup_add_can_leave_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-14 04:57

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0606_remove_realm_add_custom_emoji_policy"),
    ]

    operations = [
        migrations.AddField(
            model_name="namedusergroup",
            name="can_leave_group",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0608_set_default_for_can_leave_group.py]---
Location: zulip-main/zerver/migrations/0608_set_default_for_can_leave_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-14 05:08

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max, Min, OuterRef


def set_default_value_for_can_leave_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")
    BATCH_SIZE = 1000

    max_id = NamedUserGroup.objects.filter(can_leave_group=None).aggregate(Max("id"))["id__max"]
    if max_id is None:
        # Do nothing if there are no user groups on the server.
        return

    lower_bound = NamedUserGroup.objects.filter(can_leave_group=None).aggregate(Min("id"))[
        "id__min"
    ]
    while lower_bound <= max_id + BATCH_SIZE / 2:
        upper_bound = lower_bound + BATCH_SIZE - 1
        print(f"Processing batch {lower_bound} to {upper_bound} for NamedUserGroup")

        with transaction.atomic():
            # Everyone should be able to leave the group they have
            # joined by default.
            NamedUserGroup.objects.filter(
                id__range=(lower_bound, upper_bound),
                can_leave_group=None,
            ).update(
                can_leave_group=NamedUserGroup.objects.filter(
                    name="role:everyone",
                    realm_for_sharding=OuterRef("realm_for_sharding"),
                    is_system_group=True,
                ).values("pk")
            )

        lower_bound += BATCH_SIZE


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0607_namedusergroup_add_can_leave_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_leave_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0609_alter_namedusergroup_can_leave_group.py]---
Location: zulip-main/zerver/migrations/0609_alter_namedusergroup_can_leave_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-14 04:57

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0608_set_default_for_can_leave_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="namedusergroup",
            name="can_leave_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0610_mark_introduce_resolve_topic_modal_as_read.py]---
Location: zulip-main/zerver/migrations/0610_mark_introduce_resolve_topic_modal_as_read.py
Signals: Django

```python
# Generated by Django 5.0.6 on 2024-10-16 09:24

from django.db import connection, migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max, Min
from django.utils.timezone import now as timezone_now
from psycopg2.sql import SQL


def mark_introduce_resolve_topic_modal_as_read(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserActivity = apps.get_model("zerver", "UserActivity")
    max_id = UserActivity.objects.filter(query="update_message_backend").aggregate(
        Max("user_profile_id")
    )["user_profile_id__max"]

    if max_id is None:
        return

    BATCH_SIZE = 10000
    max_id += BATCH_SIZE / 2
    lower_id_bound = UserActivity.objects.filter(query="update_message_backend").aggregate(
        Min("user_profile_id")
    )["user_profile_id__min"]
    timestamp_value = timezone_now()
    while lower_id_bound < max_id:
        upper_id_bound = min(lower_id_bound + BATCH_SIZE - 1, max_id)
        with connection.cursor() as cursor:
            query = SQL("""
                INSERT INTO zerver_onboardingstep (user_id, onboarding_step, timestamp)
                SELECT user_profile_id, 'intro_resolve_topic', %(timestamp_value)s
                FROM zerver_useractivity
                WHERE query = 'update_message_backend'
                AND user_profile_id >= %(lower_id_bound)s AND user_profile_id <= %(upper_id_bound)s
                ON CONFLICT (user_id, onboarding_step) DO NOTHING;
                """)
            cursor.execute(
                query,
                {
                    "timestamp_value": timestamp_value,
                    "lower_id_bound": lower_id_bound,
                    "upper_id_bound": upper_id_bound,
                },
            )

        print(f"Processed {upper_id_bound} / {max_id}")
        lower_id_bound += BATCH_SIZE


def mark_introduce_resolve_topic_modal_as_unread(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    OnboardingStep = apps.get_model("zerver", "OnboardingStep")

    OnboardingStep.objects.filter(onboarding_step="intro_resolve_topic").delete()


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        ("zerver", "0609_alter_namedusergroup_can_leave_group"),
    ]

    operations = [
        migrations.RunPython(
            mark_introduce_resolve_topic_modal_as_read,
            reverse_code=mark_introduce_resolve_topic_modal_as_unread,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0611_realm_can_move_messages_between_channels_group.py]---
Location: zulip-main/zerver/migrations/0611_realm_can_move_messages_between_channels_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-12 13:48

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0610_mark_introduce_resolve_topic_modal_as_read"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="can_move_messages_between_channels_group",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0612_set_default_value_for_can_move_messages_between_channels_group.py]---
Location: zulip-main/zerver/migrations/0612_set_default_value_for_can_move_messages_between_channels_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:47

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import OuterRef


def set_default_value_for_can_move_messages_between_channels_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")

    move_messages_between_streams_policy_to_group_name = {
        1: "role:members",
        2: "role:administrators",
        3: "role:fullmembers",
        4: "role:moderators",
        6: "role:nobody",
    }

    for id, group_name in move_messages_between_streams_policy_to_group_name.items():
        Realm.objects.filter(
            can_move_messages_between_channels_group=None, move_messages_between_streams_policy=id
        ).update(
            can_move_messages_between_channels_group=NamedUserGroup.objects.filter(
                name=group_name, realm=OuterRef("id"), is_system_group=True
            ).values("pk")
        )


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0611_realm_can_move_messages_between_channels_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_move_messages_between_channels_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0613_alter_realm_can_move_messages_between_channels_group.py]---
Location: zulip-main/zerver/migrations/0613_alter_realm_can_move_messages_between_channels_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-12 13:54

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0612_set_default_value_for_can_move_messages_between_channels_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realm",
            name="can_move_messages_between_channels_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0614_remove_realm_move_messages_between_streams_policy.py]---
Location: zulip-main/zerver/migrations/0614_remove_realm_move_messages_between_streams_policy.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-15 09:51

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0613_alter_realm_can_move_messages_between_channels_group"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="realm",
            name="move_messages_between_streams_policy",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0615_system_bot_avatars.py]---
Location: zulip-main/zerver/migrations/0615_system_bot_avatars.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-14 23:22

from django.conf import settings
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def set_system_bot_avatar_source_user(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserProfile = apps.get_model("zerver", "UserProfile")
    UserProfile.objects.filter(
        email__in=[
            settings.EMAIL_GATEWAY_BOT,
            settings.NOTIFICATION_BOT,
            settings.WELCOME_BOT,
        ]
    ).update(avatar_source="U")


def set_system_bot_avatar_source_gravatar(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    UserProfile = apps.get_model("zerver", "UserProfile")
    UserProfile.objects.filter(
        email__in=[
            settings.EMAIL_GATEWAY_BOT,
            settings.NOTIFICATION_BOT,
            settings.WELCOME_BOT,
        ]
    ).update(avatar_source="G")


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0614_remove_realm_move_messages_between_streams_policy"),
    ]

    operations = [
        migrations.RunPython(
            set_system_bot_avatar_source_user,
            elidable=True,
            reverse_code=set_system_bot_avatar_source_gravatar,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0616_userprofile_can_change_user_emails.py]---
Location: zulip-main/zerver/migrations/0616_userprofile_can_change_user_emails.py
Signals: Django

```python
# Generated by Django 5.0.8 on 2024-09-02 20:36

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0615_system_bot_avatars"),
    ]

    operations = [
        migrations.AddField(
            model_name="userprofile",
            name="can_change_user_emails",
            field=models.BooleanField(db_index=True, default=False),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0617_remove_prefix_from_archived_streams.py]---
Location: zulip-main/zerver/migrations/0617_remove_prefix_from_archived_streams.py
Signals: Django

```python
import hashlib

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps


def remove_prefix_from_archived_streams(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Stream = apps.get_model("zerver", "Stream")
    archived_streams = Stream.objects.filter(deactivated=True)

    for archived_stream in archived_streams:
        old_prefix = "!DEACTIVATED:"
        streamID = str(archived_stream.id)
        stream_id_hash_object = hashlib.sha512(streamID.encode())
        hashed_stream_id = stream_id_hash_object.hexdigest()[0:7]
        prefix = hashed_stream_id + old_prefix
        prefix_length = len(prefix)
        old_name = archived_stream.name
        new_name = old_name
        if old_name.startswith(prefix):
            new_name = old_name[prefix_length:]

        # Check for archived streams before commit 1b6f68b.
        elif old_prefix in old_name:
            prefix_end_index = old_name.find(old_prefix) + len(old_prefix)
            new_name = old_name[prefix_end_index:]

        else:
            continue

        # Check if there's an active stream or another archived stream with the new name
        if not Stream.objects.filter(
            realm_id=archived_stream.realm_id, name__iexact=new_name
        ).exists():
            archived_stream.name = new_name
            archived_stream.save(update_fields=["name"])


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        (
            "zerver",
            "0616_userprofile_can_change_user_emails",
        ),
    ]

    operations = [
        migrations.RunPython(
            remove_prefix_from_archived_streams,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0618_realm_can_move_messages_between_topics_group.py]---
Location: zulip-main/zerver/migrations/0618_realm_can_move_messages_between_topics_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-25 14:21

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0617_remove_prefix_from_archived_streams"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="can_move_messages_between_topics_group",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0619_set_default_value_for_can_move_messages_between_topics_group.py]---
Location: zulip-main/zerver/migrations/0619_set_default_value_for_can_move_messages_between_topics_group.py
Signals: Django

```python
# Generated by Django 4.2.1 on 2023-06-12 10:47

from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import OuterRef


def set_default_value_for_can_move_messages_between_topics_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    Realm = apps.get_model("zerver", "Realm")
    NamedUserGroup = apps.get_model("zerver", "NamedUserGroup")

    edit_topic_policy_to_group_name = {
        1: "role:members",
        2: "role:administrators",
        3: "role:fullmembers",
        4: "role:moderators",
        5: "role:everyone",
        6: "role:nobody",
    }

    for id, group_name in edit_topic_policy_to_group_name.items():
        Realm.objects.filter(
            can_move_messages_between_topics_group=None, edit_topic_policy=id
        ).update(
            can_move_messages_between_topics_group=NamedUserGroup.objects.filter(
                name=group_name, realm=OuterRef("id"), is_system_group=True
            ).values("pk")
        )


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0618_realm_can_move_messages_between_topics_group"),
    ]

    operations = [
        migrations.RunPython(
            set_default_value_for_can_move_messages_between_topics_group,
            elidable=True,
            reverse_code=migrations.RunPython.noop,
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0620_alter_realm_can_move_messages_between_topics_group.py]---
Location: zulip-main/zerver/migrations/0620_alter_realm_can_move_messages_between_topics_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-25 14:25

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0619_set_default_value_for_can_move_messages_between_topics_group"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realm",
            name="can_move_messages_between_topics_group",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0621_remove_realm_edit_topic_policy.py]---
Location: zulip-main/zerver/migrations/0621_remove_realm_edit_topic_policy.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-27 16:28

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0620_alter_realm_can_move_messages_between_topics_group"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="realm",
            name="edit_topic_policy",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0622_backfill_imageattachment_again.py]---
Location: zulip-main/zerver/migrations/0622_backfill_imageattachment_again.py
Signals: Django

```python
# Duplicate of database migration 0576, because the original used the
# wrong path for servers using the local file upload backend, and
# many servers had already upgraded to 9.2 where it was backported.

import os
from functools import reduce
from operator import or_

import boto3
import pyvips
from botocore.client import Config
from botocore.exceptions import ClientError
from botocore.response import StreamingBody
from django.conf import settings
from django.db import migrations
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Exists, OuterRef, Q

from zerver.lib.partial import partial


def backfill_imageattachment(apps: StateApps, schema_editor: BaseDatabaseSchemaEditor) -> None:
    ImageAttachment = apps.get_model("zerver", "ImageAttachment")
    Attachment = apps.get_model("zerver", "Attachment")

    if settings.LOCAL_UPLOADS_DIR is None:
        upload_bucket = boto3.resource(
            "s3",
            aws_access_key_id=settings.S3_KEY,
            aws_secret_access_key=settings.S3_SECRET_KEY,
            region_name=settings.S3_REGION,
            endpoint_url=settings.S3_ENDPOINT_URL,
            config=Config(
                signature_version=None,
                s3={"addressing_style": settings.S3_ADDRESSING_STYLE},
            ),
        ).Bucket(settings.S3_AUTH_UPLOADS_BUCKET)

    # Historical attachments do not have a mime_type value, so we used
    # to rely on the file extension.  We replicate that when
    # backfilling.  This is the value from zerver.lib.markdown:
    IMAGE_EXTENSIONS = [".bmp", ".gif", ".jpe", ".jpeg", ".jpg", ".png", ".webp"]

    extension_limits = Q()
    extension_limits = reduce(
        or_,
        [Q(file_name__endswith=extension) for extension in IMAGE_EXTENSIONS],
        extension_limits,
    )

    attachments_query = (
        Attachment.objects.alias(
            has_imageattachment=Exists(ImageAttachment.objects.filter(path_id=OuterRef("path_id")))
        )
        .filter(extension_limits, has_imageattachment=False)
        .order_by("id")
    )

    already_processed = 0
    total_to_process = attachments_query.count()
    min_id: int | None = 0
    while True:
        attachments = attachments_query.filter(id__gt=min_id)[:100]

        min_id = None
        for attachment in attachments:
            min_id = attachment.id
            already_processed += 1

            if settings.LOCAL_UPLOADS_DIR is None:
                try:
                    metadata = upload_bucket.Object(attachment.path_id).get()
                except ClientError:
                    print(f"{attachment.path_id}: Missing!")
                    continue

                def s3_read(streamingbody: StreamingBody, size: int) -> bytes:
                    return streamingbody.read(amt=size)

                # We use the streaming body to only pull down as much
                # of the image as we need to examine the headers --
                # generally about 40k
                source: pyvips.Source = pyvips.SourceCustom()
                source.on_read(partial(s3_read, metadata["Body"]))
            else:
                assert settings.LOCAL_FILES_DIR is not None
                attachment_path = os.path.join(settings.LOCAL_FILES_DIR, attachment.path_id)
                if not os.path.exists(attachment_path):
                    print(f"{attachment.path_id}: Missing!")
                    continue
                source = pyvips.Source.new_from_file(attachment_path)
            try:
                image = pyvips.Image.new_from_source(source, "", access="sequential")

                # "original_width_px" and "original_height_px" here are
                # _as rendered_, after applying the orientation
                # information which the image may contain.
                if (
                    "orientation" in image.get_fields()
                    and image.get("orientation") >= 5
                    and image.get("orientation") <= 8
                ):
                    (width, height) = (image.height, image.width)
                else:
                    (width, height) = (image.width, image.height)

                ImageAttachment.objects.create(
                    realm_id=attachment.realm_id,
                    path_id=attachment.path_id,
                    original_width_px=width,
                    original_height_px=height,
                    frames=image.get_n_pages(),
                    thumbnail_metadata=[],
                )
            except pyvips.Error:
                pass

        print(f"Processed {already_processed}/{total_to_process}")
        if min_id is None:
            break


class Migration(migrations.Migration):
    atomic = False
    dependencies = [
        # Because this will be backported to 9.x, we only depend on the last migration in 9.x
        ("zerver", "0576_backfill_imageattachment"),
    ]

    operations = [
        migrations.RunPython(
            backfill_imageattachment, reverse_code=migrations.RunPython.noop, elidable=True
        )
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0623_merge_20241030_1835.py]---
Location: zulip-main/zerver/migrations/0623_merge_20241030_1835.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-10-30 18:35

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0621_remove_realm_edit_topic_policy"),
        ("zerver", "0622_backfill_imageattachment_again"),
    ]

    operations = []
```

--------------------------------------------------------------------------------

---[FILE: 0624_alter_realmexport_tarball_size_bytes.py]---
Location: zulip-main/zerver/migrations/0624_alter_realmexport_tarball_size_bytes.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-11-14 05:12

from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0623_merge_20241030_1835"),
    ]

    operations = [
        migrations.AlterField(
            model_name="realmexport",
            name="tarball_size_bytes",
            field=models.PositiveBigIntegerField(default=None, null=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0625_realm_can_invite_users_group.py]---
Location: zulip-main/zerver/migrations/0625_realm_can_invite_users_group.py
Signals: Django

```python
# Generated by Django 5.0.9 on 2024-11-13 18:13

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("zerver", "0624_alter_realmexport_tarball_size_bytes"),
    ]

    operations = [
        migrations.AddField(
            model_name="realm",
            name="can_invite_users_group",
            field=models.ForeignKey(
                null=True,
                on_delete=django.db.models.deletion.RESTRICT,
                related_name="+",
                to="zerver.usergroup",
            ),
        ),
    ]
```

--------------------------------------------------------------------------------

````
