---
source_txt: fullstack_samples/zulip-main
converted_utc: 2025-12-18T13:06:12Z
part: 21
parts_total: 1290
---

# FULLSTACK CODE DATABASE SAMPLES zulip-main

## Verbatim Content (Part 21 of 1290)

````text
================================================================================
FULLSTACK SAMPLES CODE DATABASE (VERBATIM) - zulip-main
================================================================================
Generated: December 18, 2025
Source: fullstack_samples/zulip-main
================================================================================

NOTES:
- This output is verbatim because the source is user-owned.
- Large/binary files may be skipped by size/binary detection limits.

================================================================================

---[FILE: 0015_alter_confirmation_object_id.py]---
Location: zulip-main/confirmation/migrations/0015_alter_confirmation_object_id.py
Signals: Django

```python
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("confirmation", "0014_confirmation_confirmatio_content_80155a_idx"),
        # We want to be linking to tables that are already bigints
        ("zerver", "0531_convert_most_ids_to_bigints"),
    ]

    operations = [
        migrations.AlterField(
            model_name="confirmation",
            name="object_id",
            field=models.PositiveBigIntegerField(db_index=True),
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0016_realmcreationkey_to_realmcreationstatus.py]---
Location: zulip-main/confirmation/migrations/0016_realmcreationkey_to_realmcreationstatus.py
Signals: Django

```python
# Generated by Django 5.2.3 on 2025-07-04 20:33

from datetime import timedelta

from django.conf import settings
from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Max


def migrate_realmcreationkey_to_realmcreationstatus(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    """
    This migration is for switching from using a separate RealmCreationKey class
    for realm creation keys to just using the Confirmation system.

    The aim is to iterate through all the existing RealmCreationKey and create
    a corresponding Confirmation+RealmCreationStatus.

    For validity of these objects, we only need to worry about RealmCreationKeys
    expired due to time. This is taken care of by making sure we set expiry_date
    on the Confirmation we're creating.
    The way the RealmCreationKey system worked was to .delete() the RealmCreationKey
    objects when they were used - so those simply no longer exist and we don't need to
    worry about this case.
    """
    CAN_CREATE_REALM = 11

    Confirmation = apps.get_model("confirmation", "Confirmation")
    ContentType = apps.get_model("contenttypes", "ContentType")
    RealmCreationKey = apps.get_model("confirmation", "RealmCreationKey")
    RealmCreationStatus = apps.get_model("zerver", "RealmCreationStatus")
    realm_creation_status_content_type, _created = ContentType.objects.get_or_create(
        model="realmcreationstatus", app_label="zerver"
    )

    BATCH_SIZE = 10000
    max_id = RealmCreationKey.objects.aggregate(Max("id"))["id__max"]
    if max_id is None:
        # Nothing to do.
        return

    lower_bound = 1
    while lower_bound <= max_id + (BATCH_SIZE / 2):
        upper_bound = lower_bound + BATCH_SIZE - 1
        creation_keys = RealmCreationKey.objects.filter(id__range=(lower_bound, upper_bound))
        creation_statuses_to_create = []
        confirmations_to_create = []
        for creation_key in creation_keys:
            # These keys were generated in the same way as keys for Confirmation objects,
            # so we can copy them over without breaking anything.
            key = creation_key.creation_key
            date_created = creation_key.date_created
            presume_email_valid = creation_key.presume_email_valid

            creation_status = RealmCreationStatus(
                status=0, date_created=date_created, presume_email_valid=presume_email_valid
            )
            confirmation = Confirmation(
                content_type=realm_creation_status_content_type,
                type=CAN_CREATE_REALM,
                confirmation_key=key,
                date_sent=date_created,
                expiry_date=date_created
                + timedelta(days=settings.CAN_CREATE_REALM_LINK_VALIDITY_DAYS),
            )

            # To attach the Confirmations to RealmCreationStatus objects we need to set the
            # confirmation.object_id to their respective ids. But we haven't saved
            # the RealmCreationStatus objs to the database yet - so we don't have ids.
            #
            # After we .bulk_create() them, their .id attributes will be populated.
            # So for now we just link the RealmCreationStatus to the Confirmation
            # via a temporary ._object attribute - which we'll use later to set
            # the .object_id as intended.
            confirmation._object = creation_status

            creation_statuses_to_create.append(creation_status)
            confirmations_to_create.append(confirmation)
        with transaction.atomic():
            RealmCreationStatus.objects.bulk_create(creation_statuses_to_create)

            # Now the objects in creation_statuses_to_create have had their .id
            # attrs populated. For every confirmation, confirmation._object
            # points to its corresponding RealmCreationStatus - so now we can
            # set the confirmation.object_id values and clear out the temporary
            # ._object attr.
            for confirmation in confirmations_to_create:
                confirmation.object_id = confirmation._object.id
                delattr(confirmation, "_object")
            Confirmation.objects.bulk_create(confirmations_to_create)

        lower_bound += BATCH_SIZE


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("confirmation", "0015_alter_confirmation_object_id"),
        ("zerver", "0747_realmcreationstatus"),
    ]

    operations = [
        migrations.RunPython(
            migrate_realmcreationkey_to_realmcreationstatus,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: 0017_delete_realmcreationkey.py]---
Location: zulip-main/confirmation/migrations/0017_delete_realmcreationkey.py
Signals: Django

```python
# Generated by Django 5.2.3 on 2025-07-04 19:08

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("confirmation", "0016_realmcreationkey_to_realmcreationstatus"),
    ]

    operations = [
        migrations.DeleteModel(
            name="RealmCreationKey",
        ),
    ]
```

--------------------------------------------------------------------------------

---[FILE: urls.py]---
Location: zulip-main/corporate/urls.py
Signals: Django

```python
from typing import Any

from django.conf.urls import include
from django.urls import path
from django.views.generic import RedirectView, TemplateView

from corporate.views.audit_logs import get_remote_server_logs
from corporate.views.billing_page import (
    billing_page,
    remote_realm_billing_page,
    remote_server_billing_page,
    remote_server_deactivate_page,
    update_plan,
    update_plan_for_remote_realm,
    update_plan_for_remote_server,
)
from corporate.views.event_status import (
    event_status,
    event_status_page,
    remote_realm_event_status,
    remote_realm_event_status_page,
    remote_server_event_status,
    remote_server_event_status_page,
)
from corporate.views.installation_activity import (
    get_installation_activity,
    get_integrations_activity,
)
from corporate.views.plan_activity import get_plan_ledger
from corporate.views.portico import (
    app_download_link_redirect,
    apps_view,
    communities_view,
    customer_portal,
    hello_view,
    invoices_page,
    landing_view,
    plans_view,
    remote_realm_customer_portal,
    remote_realm_invoices_page,
    remote_realm_plans_page,
    remote_server_customer_portal,
    remote_server_invoices_page,
    remote_server_plans_page,
    team_view,
)
from corporate.views.realm_activity import get_realm_activity
from corporate.views.remote_activity import get_remote_server_activity
from corporate.views.remote_billing_page import (
    remote_billing_legacy_server_confirm_login,
    remote_billing_legacy_server_from_login_confirmation_link,
    remote_billing_legacy_server_login,
    remote_realm_billing_confirm_email,
    remote_realm_billing_finalize_login,
    remote_realm_billing_from_login_confirmation_link,
)
from corporate.views.session import (
    start_card_update_stripe_session,
    start_card_update_stripe_session_for_realm_upgrade,
    start_card_update_stripe_session_for_remote_realm,
    start_card_update_stripe_session_for_remote_realm_upgrade,
    start_card_update_stripe_session_for_remote_server,
    start_card_update_stripe_session_for_remote_server_upgrade,
)
from corporate.views.sponsorship import (
    remote_realm_sponsorship,
    remote_realm_sponsorship_page,
    remote_server_sponsorship,
    remote_server_sponsorship_page,
    sponsorship,
    sponsorship_page,
)
from corporate.views.support import (
    demo_request,
    remote_servers_support,
    sales_support_request,
    support,
    support_request,
)
from corporate.views.upgrade import (
    remote_realm_upgrade,
    remote_realm_upgrade_page,
    remote_server_upgrade,
    remote_server_upgrade_page,
    upgrade,
    upgrade_page,
)
from corporate.views.user_activity import get_user_activity
from corporate.views.webhook import stripe_webhook
from zerver.lib.rest import rest_path
from zerver.lib.url_redirects import LANDING_PAGE_REDIRECTS

i18n_urlpatterns: Any = [
    path("jobs/", TemplateView.as_view(template_name="corporate/jobs.html")),
    # Billing
    path("billing/", billing_page, name="billing_page"),
    path("invoices/", invoices_page, name="invoices_page"),
    path("customer_portal/", customer_portal, name="customer_portal_page"),
    path("sponsorship/", sponsorship_page, name="sponsorship_request"),
    path("upgrade/", upgrade_page, name="upgrade_page"),
    path("support/", support_request),
    path("request-demo/", demo_request),
    path("contact-sales/", sales_support_request),
    path("billing/event_status/", event_status_page, name="event_status_page"),
    path("stripe/webhook/", stripe_webhook, name="stripe_webhook"),
    # Server admin (user_profile.is_staff) visible stats pages
    path("activity", get_installation_activity),
    path("activity/integrations", get_integrations_activity),
    path("activity/support", support, name="support"),
    path("realm_activity/<realm_str>/", get_realm_activity),
    path("user_activity/<user_profile_id>/", get_user_activity),
    path("activity/remote", get_remote_server_activity),
    path("activity/remote/support", remote_servers_support, name="remote_servers_support"),
    path("activity/remote/logs/server/<uuid>/", get_remote_server_logs),
    path("activity/plan_ledger/<plan_id>/", get_plan_ledger),
]

v1_api_and_json_patterns = [
    rest_path("billing/upgrade", POST=upgrade),
    rest_path("billing/sponsorship", POST=sponsorship),
    rest_path("billing/plan", PATCH=update_plan),
    rest_path("billing/session/start_card_update_session", POST=start_card_update_stripe_session),
    rest_path(
        "upgrade/session/start_card_update_session",
        POST=start_card_update_stripe_session_for_realm_upgrade,
    ),
    rest_path("billing/event/status", GET=event_status),
]

landing_page_urls = [
    # Landing page, features pages, signup form, etc.
    path("hello/", hello_view),
    path("features/", landing_view, {"template_name": "corporate/features.html"}),
    path("plans/", plans_view, name="plans"),
    path("apps/", apps_view),
    path("apps/download/<platform>", app_download_link_redirect),
    path("apps/<platform>", apps_view),
    path(
        "development-community/",
        landing_view,
        {"template_name": "corporate/development-community.html"},
    ),
    path("attribution/", landing_view, {"template_name": "corporate/attribution.html"}),
    path("team/", team_view),
    path("history/", landing_view, {"template_name": "corporate/history.html"}),
    path("values/", landing_view, {"template_name": "corporate/values.html"}),
    path("partners/", landing_view, {"template_name": "corporate/partners.html"}),
    path("why-zulip/", landing_view, {"template_name": "corporate/why-zulip.html"}),
    path("self-hosting/", landing_view, {"template_name": "corporate/self-hosting.html"}),
    path("zulip-cloud/", landing_view, {"template_name": "corporate/zulip-cloud.html"}),
    path("security/", landing_view, {"template_name": "corporate/security.html"}),
    # /for pages
    path("use-cases/", landing_view, {"template_name": "corporate/for/use-cases.html"}),
    path(
        "for/communities/",
        landing_view,
        {"template_name": "corporate/for/communities.html"},
    ),
    path("for/education/", landing_view, {"template_name": "corporate/for/education.html"}),
    path("for/events/", landing_view, {"template_name": "corporate/for/events.html"}),
    path("for/open-source/", landing_view, {"template_name": "corporate/for/open-source.html"}),
    path("for/research/", landing_view, {"template_name": "corporate/for/research.html"}),
    path("for/business/", landing_view, {"template_name": "corporate/for/business.html"}),
    # /role pages
    path("role/engineers/", landing_view, {"template_name": "corporate/role/engineers.html"}),
    # case-studies
    path(
        "case-studies/idrift/",
        landing_view,
        {"template_name": "corporate/case-studies/idrift-case-study.html"},
    ),
    path(
        "case-studies/gut-contact/",
        landing_view,
        {"template_name": "corporate/case-studies/gut-contact-case-study.html"},
    ),
    path(
        "case-studies/end-point/",
        landing_view,
        {"template_name": "corporate/case-studies/end-point-case-study.html"},
    ),
    path(
        "case-studies/atolio/",
        landing_view,
        {"template_name": "corporate/case-studies/atolio-case-study.html"},
    ),
    path(
        "case-studies/semsee/",
        landing_view,
        {"template_name": "corporate/case-studies/semsee-case-study.html"},
    ),
    path(
        "case-studies/tum/",
        landing_view,
        {"template_name": "corporate/case-studies/tum-case-study.html"},
    ),
    path(
        "case-studies/university-of-cordoba/",
        landing_view,
        {"template_name": "corporate/case-studies/university-of-cordoba-case-study.html"},
    ),
    path(
        "case-studies/ucsd/",
        landing_view,
        {"template_name": "corporate/case-studies/ucsd-case-study.html"},
    ),
    path(
        "case-studies/rust/",
        landing_view,
        {"template_name": "corporate/case-studies/rust-case-study.html"},
    ),
    path(
        "case-studies/lean/",
        landing_view,
        {"template_name": "corporate/case-studies/lean-case-study.html"},
    ),
    path(
        "case-studies/asciidoctor/",
        landing_view,
        {"template_name": "corporate/case-studies/asciidoctor-case-study.html"},
    ),
    path(
        "case-studies/recurse-center/",
        landing_view,
        {"template_name": "corporate/case-studies/recurse-center-case-study.html"},
    ),
    path(
        "case-studies/rush-stack/",
        landing_view,
        {"template_name": "corporate/case-studies/rush-stack-case-study.html"},
    ),
    path(
        "case-studies/windborne/",
        landing_view,
        {"template_name": "corporate/case-studies/windborne-case-study.html"},
    ),
    path(
        "case-studies/mixxx/",
        landing_view,
        {"template_name": "corporate/case-studies/mixxx-case-study.html"},
    ),
    path("communities/", communities_view),
]

# Redirects due to us having moved or combined landing pages:
for redirect in LANDING_PAGE_REDIRECTS:
    old_url = redirect.old_url.lstrip("/")
    landing_page_urls += [path(old_url, RedirectView.as_view(url=redirect.new_url, permanent=True))]

i18n_urlpatterns += landing_page_urls

# Make a copy of i18n_urlpatterns so that they appear without prefix for English
urlpatterns = list(i18n_urlpatterns)

urlpatterns += [
    path("remote-billing-login/<signed_billing_access_token>", remote_realm_billing_finalize_login),
    path(
        "remote-billing-login/<signed_billing_access_token>/confirm/",
        remote_realm_billing_confirm_email,
    ),
    path(
        "remote-billing-login/do_confirm/<confirmation_key>",
        remote_realm_billing_from_login_confirmation_link,
        name="remote_realm_billing_from_login_confirmation_link",
    ),
    # Remote server billing endpoints.
    path("realm/<realm_uuid>/plans/", remote_realm_plans_page, name="remote_realm_plans_page"),
    path(
        "server/<server_uuid>/plans/",
        remote_server_plans_page,
        name="remote_server_plans_page",
    ),
    path(
        "realm/<realm_uuid>/billing/", remote_realm_billing_page, name="remote_realm_billing_page"
    ),
    path(
        "server/<server_uuid>/billing/",
        remote_server_billing_page,
        name="remote_server_billing_page",
    ),
    path(
        "realm/<realm_uuid>/upgrade/", remote_realm_upgrade_page, name="remote_realm_upgrade_page"
    ),
    path(
        "server/<server_uuid>/upgrade/",
        remote_server_upgrade_page,
        name="remote_server_upgrade_page",
    ),
    path(
        "realm/<realm_uuid>/sponsorship/",
        remote_realm_sponsorship_page,
        name="remote_realm_sponsorship_page",
    ),
    path(
        "server/<server_uuid>/sponsorship/",
        remote_server_sponsorship_page,
        name="remote_server_sponsorship_page",
    ),
    path(
        "server/<server_uuid>/deactivate/",
        remote_server_deactivate_page,
        name="remote_server_deactivate_page",
    ),
    path(
        "serverlogin/",
        remote_billing_legacy_server_login,
        name="remote_billing_legacy_server_login",
    ),
    path(
        "serverlogin/<server_uuid>/confirm/",
        remote_billing_legacy_server_confirm_login,
        name="remote_billing_legacy_server_confirm_login",
    ),
    path(
        "serverlogin/do_confirm/<confirmation_key>",
        remote_billing_legacy_server_from_login_confirmation_link,
        name="remote_billing_legacy_server_from_login_confirmation_link",
    ),
    path(
        "realm/<realm_uuid>/billing/event_status/",
        remote_realm_event_status_page,
        name="remote_realm_event_status_page",
    ),
    path(
        "server/<server_uuid>/billing/event_status/",
        remote_server_event_status_page,
        name="remote_server_event_status_page",
    ),
    path(
        "realm/<realm_uuid>/invoices/",
        remote_realm_invoices_page,
        name="remote_realm_invoices_page",
    ),
    path(
        "server/<server_uuid>/invoices/",
        remote_server_invoices_page,
        name="remote_server_invoices_page",
    ),
    path(
        "realm/<realm_uuid>/customer_portal/",
        remote_realm_customer_portal,
        name="remote_realm_customer_portal_page",
    ),
    path(
        "server/<server_uuid>/customer_portal/",
        remote_server_customer_portal,
        name="remote_server_customer_portal_page",
    ),
    # Remote variants of above API endpoints.
    path("json/realm/<realm_uuid>/billing/sponsorship", remote_realm_sponsorship),
    path("json/server/<server_uuid>/billing/sponsorship", remote_server_sponsorship),
    path(
        "json/realm/<realm_uuid>/billing/session/start_card_update_session",
        start_card_update_stripe_session_for_remote_realm,
    ),
    path(
        "json/server/<server_uuid>/billing/session/start_card_update_session",
        start_card_update_stripe_session_for_remote_server,
    ),
    path(
        "json/realm/<realm_uuid>/upgrade/session/start_card_update_session",
        start_card_update_stripe_session_for_remote_realm_upgrade,
    ),
    path(
        "json/server/<server_uuid>/upgrade/session/start_card_update_session",
        start_card_update_stripe_session_for_remote_server_upgrade,
    ),
    path("json/realm/<realm_uuid>/billing/event/status", remote_realm_event_status),
    path("json/server/<server_uuid>/billing/event/status", remote_server_event_status),
    path("json/realm/<realm_uuid>/billing/upgrade", remote_realm_upgrade),
    path("json/server/<server_uuid>/billing/upgrade", remote_server_upgrade),
    path("json/realm/<realm_uuid>/billing/plan", update_plan_for_remote_realm),
    path("json/server/<server_uuid>/billing/plan", update_plan_for_remote_server),
]

urlpatterns += [
    path("api/v1/", include(v1_api_and_json_patterns)),
    path("json/", include(v1_api_and_json_patterns)),
]
```

--------------------------------------------------------------------------------

---[FILE: activity.py]---
Location: zulip-main/corporate/lib/activity.py
Signals: Django

```python
from collections import defaultdict
from collections.abc import Callable, Sequence
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Any

from django.conf import settings
from django.db import connection
from django.db.backends.utils import CursorWrapper
from django.db.models import Prefetch
from django.template import loader
from django.urls import reverse
from django.utils.timezone import now as timezone_now
from markupsafe import Markup
from psycopg2.sql import Composable

from corporate.models.licenses import LicenseLedger
from corporate.models.plans import CustomerPlan
from zerver.lib.pysa import mark_sanitized
from zerver.models import Realm
from zilencer.models import (
    RemoteCustomerUserCount,
    RemoteRealm,
    RemoteRealmAuditLog,
    RemoteZulipServer,
    get_remote_customer_user_count,
)


@dataclass
class RemoteActivityPlanData:
    current_status: str
    current_plan_name: str
    annual_revenue: int
    rate: str


@dataclass
class ActivityHeaderEntry:
    name: str
    value: str | Markup


def make_table(
    title: str,
    cols: Sequence[str],
    rows: Sequence[Any],
    *,
    header: list[ActivityHeaderEntry] | None = None,
    totals: Any | None = None,
    title_link: Markup | None = None,
    has_row_class: bool = False,
) -> str:
    if not has_row_class:

        def fix_row(row: Any) -> dict[str, Any]:
            return dict(cells=row, row_class=None)

        rows = list(map(fix_row, rows))

    data = dict(
        title=title, cols=cols, rows=rows, header=header, totals=totals, title_link=title_link
    )

    content = loader.render_to_string(
        "corporate/activity/activity_table.html",
        dict(data=data),
    )

    return content


def fix_rows(
    rows: list[list[Any]],
    i: int,
    fixup_func: Callable[[str], Markup] | Callable[[datetime], str] | Callable[[int], int],
) -> None:
    for row in rows:
        row[i] = fixup_func(row[i])


def get_query_data(query: Composable) -> list[list[Any]]:
    cursor = connection.cursor()
    cursor.execute(query)
    rows = cursor.fetchall()
    rows = list(map(list, rows))
    cursor.close()
    return rows


def dictfetchall(cursor: CursorWrapper) -> list[dict[str, Any]]:
    """Returns all rows from a cursor as a dict"""
    desc = cursor.description
    return [dict(zip((col[0] for col in desc), row, strict=False)) for row in cursor.fetchall()]


def format_optional_datetime(date: datetime | None, display_none: bool = False) -> str:
    if date:
        return date.replace(tzinfo=None).isoformat(" ", "minutes")
    elif display_none:
        return "None"
    else:
        return ""


def format_datetime_as_date(date: datetime) -> str:
    return date.date().isoformat()


def format_none_as_zero(value: int | None) -> int:
    if value:
        return value
    else:
        return 0


def user_activity_link(link_text: str, user_profile_id: int) -> Markup:
    from corporate.views.user_activity import get_user_activity

    url = reverse(get_user_activity, kwargs=dict(user_profile_id=user_profile_id))
    if link_text == "":
        return Markup('<a href="{url}"><i class="fa fa-user-circle"></i></a>').format(url=url)
    return Markup('<a href="{url}">{link_text}</a>').format(url=url, link_text=link_text)


def realm_activity_link(realm_str: str) -> Markup:
    from corporate.views.realm_activity import get_realm_activity

    url = reverse(get_realm_activity, kwargs=dict(realm_str=realm_str))
    return Markup('<a href="{url}"><i class="fa fa-table"></i></a>').format(url=url)


def realm_stats_link(realm_str: str) -> Markup:
    from analytics.views.stats import stats_for_realm

    url = reverse(stats_for_realm, kwargs=dict(realm_str=realm_str))
    return Markup('<a href="{url}"><i class="fa fa-pie-chart"></i></a>').format(url=url)


def user_support_link(email: str) -> Markup:
    url = reverse("support", query={"q": email})
    return Markup('<a href="{url}"><i class="fa fa-gear"></i></a>').format(url=url)


def realm_support_link(realm_str: str) -> Markup:
    url = reverse("support", query={"q": realm_str})
    return Markup('<a href="{url}">{realm}</i></a>').format(url=url, realm=realm_str)


def realm_url_link(realm_str: str) -> Markup:
    host = Realm.host_for_subdomain(realm_str)
    url = settings.EXTERNAL_URI_SCHEME + mark_sanitized(host)
    return Markup('<a href="{url}"><i class="fa fa-home"></i></a>').format(url=url)


def remote_installation_stats_link(server_id: int) -> Markup:
    from analytics.views.stats import stats_for_remote_installation

    url = reverse(stats_for_remote_installation, kwargs=dict(remote_server_id=server_id))
    return Markup('<a href="{url}"><i class="fa fa-pie-chart"></i></a>').format(url=url)


def remote_installation_support_link(hostname: str) -> Markup:
    url = reverse("remote_servers_support", query={"q": hostname})
    return Markup('<a href="{url}"><i class="fa fa-gear"></i></a>').format(url=url)


def get_plan_rate_percentage(discount: str | None, has_fixed_price: bool) -> str:
    # We want to clearly note plans with a fixed price, and not show
    # them as paying 100%, as they are usually a special, negotiated
    # rate with the customer.
    if has_fixed_price:
        return "Fixed"

    # CustomerPlan.discount is a string field that stores the discount.
    if discount is None or discount == "0":
        return "100%"

    rate = 100 - Decimal(discount)
    if rate * 100 % 100 == 0:
        precision = 0
    else:
        precision = 2
    return f"{rate:.{precision}f}%"


def get_remote_activity_plan_data(
    plan: CustomerPlan,
    license_ledger: LicenseLedger,
    *,
    remote_realm: RemoteRealm | None = None,
    remote_server: RemoteZulipServer | None = None,
) -> RemoteActivityPlanData:
    from corporate.lib.stripe import RemoteRealmBillingSession, RemoteServerBillingSession

    has_fixed_price = plan.fixed_price is not None
    if plan.tier == CustomerPlan.TIER_SELF_HOSTED_LEGACY or plan.status in (
        CustomerPlan.DOWNGRADE_AT_END_OF_FREE_TRIAL,
        CustomerPlan.DOWNGRADE_AT_END_OF_CYCLE,
    ):
        renewal_cents = 0
        current_rate = "---"
    elif plan.tier == CustomerPlan.TIER_SELF_HOSTED_COMMUNITY:
        renewal_cents = 0
        current_rate = "0%"
    elif remote_realm is not None:
        renewal_cents = RemoteRealmBillingSession(
            remote_realm=remote_realm
        ).get_annual_recurring_revenue_for_support_data(plan, license_ledger)
        current_rate = get_plan_rate_percentage(plan.discount, has_fixed_price)
    else:
        assert remote_server is not None
        renewal_cents = RemoteServerBillingSession(
            remote_server=remote_server
        ).get_annual_recurring_revenue_for_support_data(plan, license_ledger)
        current_rate = get_plan_rate_percentage(plan.discount, has_fixed_price)

    return RemoteActivityPlanData(
        current_status=plan.get_plan_status_as_text(),
        current_plan_name=plan.name,
        annual_revenue=renewal_cents,
        rate=current_rate,
    )


def get_estimated_arr_and_rate_by_realm() -> tuple[dict[str, int], dict[str, str]]:  # nocoverage
    from corporate.lib.stripe import RealmBillingSession

    # NOTE: Customers without a plan might still have a discount attached to them which
    # are not included in `plan_rate`.
    annual_revenue = {}
    plan_rate = {}
    plans = (
        CustomerPlan.objects.filter(
            status=CustomerPlan.ACTIVE,
            customer__remote_realm__isnull=True,
            customer__remote_server__isnull=True,
        )
        .prefetch_related(
            Prefetch(
                "licenseledger_set",
                queryset=LicenseLedger.objects.order_by("plan", "-id").distinct("plan"),
                to_attr="latest_ledger_entry",
            )
        )
        .select_related("customer__realm")
    )

    for plan in plans:
        assert plan.customer.realm is not None
        latest_ledger_entry = plan.latest_ledger_entry[0]
        assert latest_ledger_entry is not None
        renewal_cents = RealmBillingSession(
            realm=plan.customer.realm
        ).get_annual_recurring_revenue_for_support_data(plan, latest_ledger_entry)
        annual_revenue[plan.customer.realm.string_id] = renewal_cents
        has_fixed_price = plan.fixed_price is not None
        plan_rate[plan.customer.realm.string_id] = get_plan_rate_percentage(
            plan.discount, has_fixed_price
        )
    return annual_revenue, plan_rate


def get_plan_data_by_remote_server() -> dict[int, RemoteActivityPlanData]:  # nocoverage
    remote_server_plan_data: dict[int, RemoteActivityPlanData] = {}
    plans = (
        CustomerPlan.objects.filter(
            status__lt=CustomerPlan.LIVE_STATUS_THRESHOLD,
            customer__realm__isnull=True,
            customer__remote_realm__isnull=True,
            customer__remote_server__deactivated=False,
        )
        .prefetch_related(
            Prefetch(
                "licenseledger_set",
                queryset=LicenseLedger.objects.order_by("plan", "-id").distinct("plan"),
                to_attr="latest_ledger_entry",
            )
        )
        .select_related("customer__remote_server")
    )

    for plan in plans:
        server_id = None
        assert plan.customer.remote_server is not None
        server_id = plan.customer.remote_server.id
        assert server_id is not None

        latest_ledger_entry = plan.latest_ledger_entry[0]
        assert latest_ledger_entry is not None

        plan_data = get_remote_activity_plan_data(
            plan, latest_ledger_entry, remote_server=plan.customer.remote_server
        )

        current_data = remote_server_plan_data.get(server_id)
        if current_data is not None:
            current_revenue = remote_server_plan_data[server_id].annual_revenue
            current_plans = remote_server_plan_data[server_id].current_plan_name
            # There should only ever be one CustomerPlan for a remote server with
            # a status that is less than the CustomerPlan.LIVE_STATUS_THRESHOLD.
            remote_server_plan_data[server_id] = RemoteActivityPlanData(
                current_status="ERROR: MULTIPLE PLANS",
                current_plan_name=f"{current_plans}, {plan_data.current_plan_name}",
                annual_revenue=current_revenue + plan_data.annual_revenue,
                rate="",
            )
        else:
            remote_server_plan_data[server_id] = plan_data
    return remote_server_plan_data


def get_plan_data_by_remote_realm() -> dict[int, dict[int, RemoteActivityPlanData]]:  # nocoverage
    remote_server_plan_data_by_realm: dict[int, dict[int, RemoteActivityPlanData]] = {}
    plans = (
        CustomerPlan.objects.filter(
            status__lt=CustomerPlan.LIVE_STATUS_THRESHOLD,
            customer__realm__isnull=True,
            customer__remote_server__isnull=True,
            customer__remote_realm__is_system_bot_realm=False,
            customer__remote_realm__realm_deactivated=False,
        )
        .prefetch_related(
            Prefetch(
                "licenseledger_set",
                queryset=LicenseLedger.objects.order_by("plan", "-id").distinct("plan"),
                to_attr="latest_ledger_entry",
            )
        )
        .select_related("customer__remote_realm")
    )

    for plan in plans:
        server_id = None
        assert plan.customer.remote_realm is not None
        server_id = plan.customer.remote_realm.server_id
        assert server_id is not None

        latest_ledger_entry = plan.latest_ledger_entry[0]
        assert latest_ledger_entry is not None

        plan_data = get_remote_activity_plan_data(
            plan, latest_ledger_entry, remote_realm=plan.customer.remote_realm
        )

        current_server_data = remote_server_plan_data_by_realm.get(server_id)
        realm_id = plan.customer.remote_realm.id

        if current_server_data is None:
            realm_dict = {realm_id: plan_data}
            remote_server_plan_data_by_realm[server_id] = realm_dict
        else:
            assert current_server_data is not None
            current_realm_data = current_server_data.get(realm_id)
            if current_realm_data is not None:
                # There should only ever be one CustomerPlan for a remote realm with
                # a status that is less than the CustomerPlan.LIVE_STATUS_THRESHOLD.
                current_revenue = current_realm_data.annual_revenue
                current_plans = current_realm_data.current_plan_name
                current_server_data[realm_id] = RemoteActivityPlanData(
                    current_status="ERROR: MULTIPLE PLANS",
                    current_plan_name=f"{current_plans}, {plan_data.current_plan_name}",
                    annual_revenue=current_revenue + plan_data.annual_revenue,
                    rate="",
                )
            else:
                current_server_data[realm_id] = plan_data

    return remote_server_plan_data_by_realm


def get_remote_realm_user_counts(
    event_time: datetime | None = None,
) -> dict[int, RemoteCustomerUserCount]:  # nocoverage
    user_counts_by_realm: dict[int, RemoteCustomerUserCount] = {}
    for log in (
        RemoteRealmAuditLog.objects.filter(
            event_type__in=RemoteRealmAuditLog.SYNCED_BILLING_EVENTS,
            event_time__lte=timezone_now() if event_time is None else event_time,
            remote_realm__isnull=False,
        )
        # Important: extra_data is empty for some pre-2020 audit logs
        # prior to the introduction of realm_user_count_by_role
        # logging. Meanwhile, modern Zulip servers using
        # bulk_create_users to create the users in the system bot
        # realm also generate such audit logs. Such audit logs should
        # never be the latest in a normal realm.
        .exclude(extra_data={})
        .order_by("remote_realm", "-event_time")
        .distinct("remote_realm")
        .select_related("remote_realm")
    ):
        assert log.remote_realm is not None
        user_counts_by_realm[log.remote_realm.id] = get_remote_customer_user_count([log])

    return user_counts_by_realm


def get_remote_server_audit_logs(
    event_time: datetime | None = None,
) -> dict[int, list[RemoteRealmAuditLog]]:
    logs_per_server: dict[int, list[RemoteRealmAuditLog]] = defaultdict(list)
    for log in (
        RemoteRealmAuditLog.objects.filter(
            event_type__in=RemoteRealmAuditLog.SYNCED_BILLING_EVENTS,
            event_time__lte=timezone_now() if event_time is None else event_time,
        )
        # Important: extra_data is empty for some pre-2020 audit logs
        # prior to the introduction of realm_user_count_by_role
        # logging. Meanwhile, modern Zulip servers using
        # bulk_create_users to create the users in the system bot
        # realm also generate such audit logs. Such audit logs should
        # never be the latest in a normal realm.
        .exclude(extra_data={})
        .order_by("server_id", "realm_id", "-event_time")
        .distinct("server_id", "realm_id")
        .select_related("server")
    ):
        logs_per_server[log.server.id].append(log)

    return logs_per_server
```

--------------------------------------------------------------------------------

---[FILE: billing_types.py]---
Location: zulip-main/corporate/lib/billing_types.py

```python
from typing import Literal

BillingModality = Literal["send_invoice", "charge_automatically"]
BillingSchedule = Literal["annual", "monthly"]
LicenseManagement = Literal["automatic", "manual"]
```

--------------------------------------------------------------------------------

````
